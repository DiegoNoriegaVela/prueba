//=================================================================================================
// McBatchSender
//
// Proposito:
//   Envia un archivo de datos a un hub (ej. Mastercard) por TCP (Opcion 1) y genera reporte
//   de confirmacion (Opcion 2), manteniendo el comportamiento del original.
//
// Protocolo:
//   - Cada trama: header de 2 bytes (longitud big-endian) + cuerpo en EBCDIC.
//   - Opcion 1 (envio): cada parte se envia con prefijo ASCII 'R' antes del cuerpo y luego
//     se convierte a EBCDIC. Trailer final: 11 bytes = EBCDIC(acceptedCode de 7 chars) + contador(4B).
//
// Flujo (resumen):
//   Opcion 1 (Envio):
//     1) Valida permisos (CWD, dataFile, historico).
//     2) Lee dataFilePath, parte en chunkSize, determina FILE_NAME (CLI o fileNameTemplate).
//     3) Arma nombre con nameTemplate y hace handshake (acceptedCode / alreadySentSubstring).
//     4) Envia tramas y trailer 11B, espera confirmacion final (acceptedCode), actualiza historico.
//   Opcion 2 (Reporte):
//     1) Valida permisos (CWD con escritura).
//     2) Determina FILE_NAME (CLI o fileNameTemplate).
//     3) Arma nombre base desde reportNameTemplate y consulta secuencias 01..99.
//     4) Si report.process=Y: procesa headers+details; si N: escribe el contenido crudo.
//     5) Genera archivo NNNN-YYYYMMDD-Archivo de Cambio Confirmacion en el CWD y muestra su nombre.
//
// Parametrizacion (INI):
//   - host, port, connectTimeoutMs, soTimeoutMs, chunkSize
//   - dataFilePath, historyFilePath
//   - acceptedCode (lista separada por comas; uno de 7 chars se usa en trailer)
//   - alreadySentSubstring, defaultFailCode
//   - codePage (Cp037/Cp500/Cp1047)
//   - nameTemplate (p.ej. "00401{file}{julian}")
//   - fileNameTemplate (si no pasas FILE_NAME): literal, {rand}, {ddmm} -> 9 chars exactos
//   - reportNameTemplate (p.ej. "10101{file}{julian}") para Opcion 2
//   - report.process=Y|N (Y=procesa headers+details; N=escribe crudo)
//
// Uso:
//   javac McBatchSender.java
//   java McBatchSender <OPCION> <YYYYMMDD?> <seccion> [FILE_NAME]  [-Dmcsender.config=/ruta/mcsender.ini]
//   - <OPCION>    : 1=Envio, 2=Reporte
//   - <YYYYMMDD?> : (opcional) fecha a usar. Si se pasa, DEBE ir como segundo argumento.
//                   Si se omite, se usa la fecha del dia. (Soporta forma antigua sin fecha.)
//   - <seccion>   : nombre de la seccion del INI (ej. MIP, GCO)
//   - [FILE_NAME] : opcional; prioridad sobre fileNameTemplate; 9 chars exactos
//
// Ejemplos:
//   java McBatchSender 1 MIP               --> usa fecha de hoy
//   java McBatchSender 1 20250822 MIP      --> usa fecha 2025-08-22
//   java McBatchSender 2 20250822 MIP R12345678
//
// Codigos de salida:
//   0=OK | 1=error inesperado | 2=uso invalido | 3=INI no encontrado | 4=INI/argumento invalido
//=================================================================================================

import java.io.*;
import java.net.*;
import java.nio.charset.Charset;
import java.nio.charset.MalformedInputException;
import java.nio.charset.StandardCharsets;
import java.nio.file.*;
import java.nio.channels.FileChannel;
import java.time.*;
import java.time.format.DateTimeFormatter;
import java.util.*;
import java.util.logging.Logger;

public class McBatchSender {
    private static final Logger logger = Logger.getLogger(McBatchSender.class.getName());

    /**
     * Punto de entrada.
     *
     * Acepta dos formatos de CLI (retrocompatible):
     *  1) Nuevo:  <OPCION> <YYYYMMDD> <seccion> [FILE_NAME]
     *  2) Antiguo:<OPCION> <seccion> [FILE_NAME]               (usa fecha de hoy)
     *
     * @param args ver "Uso" arriba.
     *             Propiedad del sistema: -Dmcsender.config=/ruta/mcsender.ini
     */
    public static void main(String[] args) {
        if (args.length < 2) {
            System.err.println("Uso: java McBatchSender <OPCION> <YYYYMMDD?> <seccion> [FILE_NAME]  [-Dmcsender.config=/ruta/mcsender.ini]");
            System.exit(2);
        }

        final String optionStr = args[0].trim();
        final int option;
        try {
            option = Integer.parseInt(optionStr);
        } catch (NumberFormatException nfe) {
            System.err.println("OPCION debe ser 1 (envio) o 2 (reporte). Valor: '" + optionStr + "'");
            System.exit(4); return;
        }
        if (option != 1 && option != 2) {
            System.err.println("OPCION invalida. Use 1 (envio) o 2 (reporte).");
            System.exit(4);
        }

        // Soporte de dos formas:
        //   - Si args[1] es YYYYMMDD (8 digitos), se toma como fecha y la seccion es args[2].
        //   - Si NO lo es, seccion= args[1] y no hay override de fecha (se usa hoy).
        String cliDateArg = null;
        String section;
        String fileNameArg = null;

        final String maybeDateOrSection = args[1].trim();
        if (maybeDateOrSection.matches("\\d{8}")) {
            // Nuevo formato con fecha en segunda posicion
            cliDateArg = maybeDateOrSection;
            if (args.length < 3) {
                System.err.println("Falta <seccion> despues de la fecha (YYYYMMDD).");
                System.exit(2);
            }
            section = args[2].trim();
            if (args.length >= 4) fileNameArg = args[3].trim().toUpperCase();
        } else {
            // Formato antiguo (sin fecha)
            section = maybeDateOrSection;
            if (args.length >= 3) fileNameArg = args[2].trim().toUpperCase();
        }

        if (fileNameArg != null && fileNameArg.length() != 9) {
            System.err.println("FILE_NAME debe tener exactamente 9 caracteres. Valor: '" + fileNameArg + "'");
            System.exit(4);
        }
        if (cliDateArg != null && !Sender.validateDate(cliDateArg)) {
            System.err.println("Fecha invalida (YYYYMMDD): '" + cliDateArg + "'");
            System.exit(4);
        }

        final String iniPath = System.getProperty("mcsender.config", "mcsender.ini");
        final Path ini = Paths.get(iniPath);

        try {
            IniFile cfgFile = IniFile.load(ini);
            Config cfg = Config.from(cfgFile, section);

            logger.info("OPCION: " + option);
            logger.info("Host: " + cfg.host + " (" + cfg.host.length() + ")");
            logger.info("Puerto: " + cfg.port + " (" + String.valueOf(cfg.port).length() + ")");
            if (cliDateArg != null) logger.info("Fecha (CLI): " + cliDateArg);
            logger.info("nameTemplate: " + cfg.nameTemplate);
            logger.info("acceptedCodes: " + cfg.acceptedCodes);
            logger.info("trailerCode (7 chars): " + cfg.trailerCodeSeven());
            logger.info("reportNameTemplate: " + cfg.reportNameTemplate + " | report.process=" + (cfg.reportProcess ? "Y" : "N"));
            if (fileNameArg != null) {
                logger.info("FILE_NAME (CLI): " + fileNameArg + " (" + fileNameArg.length() + ")");
            } else {
                logger.info("FILE_NAME (CLI): <no provisto> -> fileNameTemplate=" + cfg.fileNameTemplate);
            }

            new Sender(cfg, option, fileNameArg, cliDateArg).run();
            System.exit(0);
        } catch (NoSuchFileException e) {
            System.err.println("No se encontro el archivo de configuracion: " + e.getFile());
            System.exit(3);
        } catch (IllegalArgumentException e) {
            System.err.println("Configuracion/argumento invalido: " + e.getMessage());
            System.exit(4);
        } catch (Exception e) {
            System.err.println("Error inesperado: " + e.getMessage());
            System.exit(1);
        }
    }

    // -------------------------------- Config --------------------------------

    /**
     * Configuracion efectiva del proceso.
     *
     * Campos:
     * - Red: host, port, connectTimeoutMs, soTimeoutMs
     * - Particionado: chunkSize
     * - Archivos: dataFilePath, historyFilePath
     * - Control: acceptedCodes, alreadySentSubstring, defaultFailCode
     * - Codificacion: codePage (EBCDIC)
     * - Plantillas: nameTemplate, fileNameTemplate, reportNameTemplate
     * - Reporte: reportProcess (Y/N)
     */
    static class Config {
        final String host;
        final int port;
        final int connectTimeoutMs;
        final int soTimeoutMs;
        final int chunkSize;
        final Path dataFilePath;
        final Path historyFilePath;
        final List<String> acceptedCodes;
        final String alreadySentSubstring;
        final String defaultFailCode;
        final Charset codePage;
        final String nameTemplate;
        final String fileNameTemplate;
        final String reportNameTemplate;
        final boolean reportProcess;

        private Config(String host, int port, int connectTimeoutMs, int soTimeoutMs, int chunkSize,
                       Path dataFilePath, Path historyFilePath, List<String> acceptedCodes,
                       String alreadySentSubstring, String defaultFailCode,
                       Charset codePage, String nameTemplate, String fileNameTemplate,
                       String reportNameTemplate, boolean reportProcess) {
            this.host = host;
            this.port = port;
            this.connectTimeoutMs = connectTimeoutMs;
            this.soTimeoutMs = soTimeoutMs;
            this.chunkSize = chunkSize;
            this.dataFilePath = dataFilePath;
            this.historyFilePath = historyFilePath;
            this.acceptedCodes = acceptedCodes;
            this.alreadySentSubstring = alreadySentSubstring;
            this.defaultFailCode = defaultFailCode;
            this.codePage = codePage;
            this.nameTemplate = nameTemplate;
            this.fileNameTemplate = fileNameTemplate;
            this.reportNameTemplate = reportNameTemplate;
            this.reportProcess = reportProcess;
        }

        /**
         * Carga y valida la seccion del INI.
         */
        static Config from(IniFile ini, String section) {
            Map<String,String> s = ini.section(section);
            if (s == null) throw new IllegalArgumentException("No existe la seccion ["+section+"].");

            String host = req(s, "host");
            int port = parseInt(s.get("port"), 1, 65535, "port");

            int connectTimeout = parseInt(s.getOrDefault("connectTimeoutMs","60000"), 1000, 300000, "connectTimeoutMs");
            int soTimeout = parseInt(s.getOrDefault("soTimeoutMs","60000"), 1000, 300000, "soTimeoutMs");
            int chunk = parseInt(s.getOrDefault("chunkSize","980"), 1, 65535, "chunkSize");

            String dataFileStr = s.getOrDefault("dataFilePath", "MIPFILE_DATI");
            String historyFileStr = s.getOrDefault("historyFilePath", "MIPFILE_HISTORY_R");

            List<String> acceptedList = parseList(s.getOrDefault("acceptedCode","9980100"));

            String already = s.getOrDefault("alreadySentSubstring","9288W");
            String failDef = s.getOrDefault("defaultFailCode","9980101");

            String codePageName = s.getOrDefault("codePage","Cp037");
            Charset cp;
            try { cp = Charset.forName(codePageName); }
            catch (Exception ex) { throw new IllegalArgumentException("codePage invalido: "+codePageName); }

            String nameTemplate = s.getOrDefault("nameTemplate", "00401{file}{julian}");
            String fileNameTemplate = s.get("fileNameTemplate");

            String reportNameTemplate = s.getOrDefault("reportNameTemplate", "10101{file}{julian}");
            String reportProcessStr   = s.getOrDefault("report.process", "Y");
            boolean reportProcess     = reportProcessStr.trim().equalsIgnoreCase("Y");

            Path dataPath = resolveAgainstCwd(dataFileStr);
            Path histPath = resolveAgainstCwd(historyFileStr);

            String trailer = pickTrailerCodeSeven(acceptedList);
            if (trailer == null) {
                throw new IllegalArgumentException("acceptedCode debe incluir al menos un valor de 7 caracteres para el trailer.");
            }

            logger.info("CWD (user.dir): " + Paths.get(System.getProperty("user.dir")).toAbsolutePath());
            logger.info("dataFilePath   : " + dataPath.toAbsolutePath());
            logger.info("historyFilePath: " + histPath.toAbsolutePath());

            return new Config(host, port, connectTimeout, soTimeout, chunk,
                              dataPath, histPath, acceptedList, already, failDef,
                              cp, nameTemplate, fileNameTemplate,
                              reportNameTemplate, reportProcess);
        }

        /** Resuelve contra el CWD si la ruta es relativa. */
        private static Path resolveAgainstCwd(String p) {
            Path path = Paths.get(p);
            if (path.isAbsolute()) return path.normalize();
            return Paths.get(System.getProperty("user.dir")).resolve(p).normalize();
        }

        /** Obtiene un valor requerido. */
        private static String req(Map<String,String> m, String key) {
            String v = m.get(key);
            if (v == null || v.trim().isEmpty()) throw new IllegalArgumentException("Falta "+key);
            return v.trim();
        }

        /** Parsea entero con rango. */
        private static int parseInt(String s, int min, int max, String name) {
            try {
                int v = Integer.parseInt(s.trim());
                if (v < min || v > max) throw new IllegalArgumentException(name+" fuera de rango ["+min+","+max+"]");
                return v;
            } catch (NumberFormatException e) {
                throw new IllegalArgumentException(name+" no numerico: "+s);
            }
        }

        /** Convierte "a,b,c" en lista haciendo trim. */
        private static List<String> parseList(String csv) {
            List<String> out = new ArrayList<>();
            if (csv == null) return Collections.emptyList();
            for (String p : csv.split(",")) {
                String t = p.trim();
                if (!t.isEmpty()) out.add(t);
            }
            return out.isEmpty() ? Collections.emptyList() : Collections.unmodifiableList(out);
        }

        /** Primer acceptedCode o defaultFailCode si vacio. */
        String firstAcceptedCodeOrDefault() {
            return acceptedCodes.isEmpty() ? defaultFailCode : acceptedCodes.get(0);
        }

        /** Devuelve un acceptedCode de 7 chars para trailer. */
        String trailerCodeSeven() {
            String t = pickTrailerCodeSeven(acceptedCodes);
            if (t == null) throw new IllegalArgumentException("acceptedCode debe incluir un valor de 7 caracteres para trailer.");
            return t;
        }

        /** Selecciona el primer codigo de longitud 7. */
        private static String pickTrailerCodeSeven(List<String> codes) {
            if (codes == null) return null;
            for (String c : codes) {
                String t = (c == null ? "" : c.trim());
                if (t.length() == 7) return t;
            }
            return null;
        }
    }

    // ----------------------------- INI simple -----------------------------

    /**
     * Parser INI minimalista (UTF-8).
     *
     * Soporta secciones [x] y pares k=v. Ignora lineas vacias y comentarios (# o ;).
     * La ultima clave repetida gana.
     */
    static class IniFile {
        private final Map<String, Map<String,String>> data = new LinkedHashMap<>();
        private IniFile() {}

        /**
         * Carga un archivo INI desde disco.
         *
         * @param path Ruta del INI
         * @return IniFile parseado
         * @throws IOException si no existe o no es legible
         */
        static IniFile load(Path path) throws IOException {
            if (!Files.exists(path)) throw new NoSuchFileException(path.toString());
            IniFile f = new IniFile();
            Map<String,String> cur = null;
            try (BufferedReader br = Files.newBufferedReader(path, StandardCharsets.UTF_8)) {
                String line;
                while ((line = br.readLine()) != null) {
                    String ln = line.trim();
                    if (ln.isEmpty() || ln.startsWith("#") || ln.startsWith(";")) continue;
                    if (ln.startsWith("[") && ln.endsWith("]")) {
                        String sec = ln.substring(1, ln.length()-1).trim();
                        cur = f.data.computeIfAbsent(sec, k -> new LinkedHashMap<>());
                    } else {
                        int eq = ln.indexOf('=');
                        if (eq < 0 || cur == null) continue;
                        String k = ln.substring(0, eq).trim();
                        String v = ln.substring(eq+1).trim();
                        cur.put(k, v);
                    }
                }
            }
            return f;
        }

        /** Devuelve el mapa de una seccion o null si no existe. */
        Map<String,String> section(String name) { return data.get(name); }
    }

    // ------------------------------ Sender ------------------------------

    /**
     * Orquesta Opcion 1 (envio) y Opcion 2 (reporte).
     *
     * - Opcion 1:
     *   Valida entorno, lee/parte payload, arma nombre, handshake, envia tramas y trailer, historico.
     * - Opcion 2:
     *   Valida entorno, arma nombre base de reporte, consulta 01..99, procesa o no segun report.process,
     *   y genera archivo de confirmacion.
     */
    static class Sender {
        private final Config cfg;
        private final int option;
        private final String fileNameArg;
        private final String cliDateArg; // YYYYMMDD o null

        Sender(Config cfg, int option, String fileNameArg, String cliDateArg) {
            this.cfg = cfg;
            this.option = option;
            this.fileNameArg = fileNameArg;
            this.cliDateArg = cliDateArg;
        }

        /** Ejecuta la opcion seleccionada. */
        void run() {
            if (option == 1) runSend();
            else if (option == 2) runReport();
            else throw new IllegalArgumentException("OPCION invalida: " + option);
        }

        // --------------------------- Opcion 1: Envio ---------------------------

        /**
         * Flujo de envio.
         * Lee dataFile, parte en chunkSize, arma nombre, handshake, envia tramas + trailer 11B,
         * espera confirmacion final y registra historico.
         */
        private void runSend() {
            logger.info("=== OPCION 1: Envio ===");

            validateEnvironmentForSend(cfg);

            byte[] payload = readPayload(cfg.dataFilePath);
            if (payload.length == 0) {
                logger.warning("El archivo de datos esta vacio: " + cfg.dataFilePath);
                createShippingHistory(cfg.defaultFailCode, "<NOFILE>", effectiveDate(cliDateArg), cfg.historyFilePath);
                return;
            }

            List<byte[]> parts = split(payload, cfg.chunkSize);
            logger.info("Partes a enviar: " + parts.size() + " (chunkSize=" + cfg.chunkSize + ")");

            String date = effectiveDate(cliDateArg);
            String effectiveFileName = (fileNameArg != null && !fileNameArg.isEmpty())
                    ? fileNameArg
                    : generateFileNameFromTemplate(cfg.fileNameTemplate, date);

            if (effectiveFileName == null || effectiveFileName.isEmpty()) {
                throw new IllegalArgumentException("No hay FILE_NAME: CLI o fileNameTemplate requerido.");
            }
            if (effectiveFileName.length() != 9) {
                throw new IllegalArgumentException("FILE_NAME efectivo debe tener 9 caracteres. Obtenido: '" + effectiveFileName + "'");
            }
            logger.info("FILE_NAME efectivo: " + effectiveFileName);

            String nameToSend = applyNameTemplate(cfg.nameTemplate, effectiveFileName, date);
            logger.info("Nombre a enviar: " + nameToSend);

            String finalStatus = cfg.defaultFailCode;
            try (Socket sock = new Socket()) {
                sock.connect(new InetSocketAddress(cfg.host, cfg.port), cfg.connectTimeoutMs);
                sock.setSoTimeout(cfg.soTimeoutMs);
                logger.info(String.format("Conectado a %s:%d (SO_TIMEOUT=%dms)", cfg.host, cfg.port, cfg.soTimeoutMs));

                // Envio de nombre
                writeNameFrame(sock, nameToSend, cfg.codePage);

                // Aprobacion
                String resp = readResponse(sock, cfg.codePage).trim();
                logger.info("Respuesta aprobacion: [" + resp + "]");

                if (!cfg.alreadySentSubstring.isEmpty() && resp.contains(cfg.alreadySentSubstring)) {
                    logger.info("Servidor indica 'ya enviado'.");
                    finalStatus = cfg.firstAcceptedCodeOrDefault();
                } else if (matchesAny(resp, cfg.acceptedCodes)) {
                    logger.info("*** Enviando Tramas... [CANT:" + parts.size() + "]");
                    for (byte[] p : parts) {
                        writeChunkFrame(sock, p, cfg.codePage);
                        logger.info("Enviando trama al MIP [OK]");
                    }

                    // Trailer 11B
                    writeTrailerFrame(sock, parts.size() + 1, cfg.codePage, cfg.trailerCodeSeven());

                    // Confirmacion final
                    logger.info("Esperando confirmacion final...");
                    String resp2 = readResponse(sock, cfg.codePage).trim();
                    logger.info("Confirmacion final: [" + resp2 + "]");
                    if (matchesAny(resp2, cfg.acceptedCodes)) {
                        finalStatus = cfg.firstAcceptedCodeOrDefault();
                        logger.info("RESULTADO DE ENVIO [OK]");
                    } else {
                        logger.warning("RESULTADO DE ENVIO [FAIL] (codigo final no coincide con acceptedCode)");
                    }
                } else {
                    logger.warning("Nombre rechazado por el hub.");
                }
            } catch (UnknownHostException e) {
                logger.severe("Host desconocido: " + e.getMessage());
            } catch (SocketTimeoutException e) {
                logger.severe("Timeout de socket: " + e.getMessage());
            } catch (ConnectException e) {
                logger.severe("No se pudo conectar a " + cfg.host + ":" + cfg.port + " - " + e.getMessage());
            } catch (IOException e) {
                logger.severe("IO de red fallo: " + e.getMessage());
            } catch (Exception e) {
                logger.severe("Error inesperado en envio: " + e.getMessage());
            } finally {
                createShippingHistory(finalStatus, effectiveFileName, date, cfg.historyFilePath);
            }

            logger.info("=== PROCESO FINALIZADO (OPCION 1) ===");
        }

        // --------------------------- Opcion 2: Reporte -------------------------
        /**
         * Flujo de reporte.
         * - Lee UN solo bloque por secuencia (01..99), como el original (lectura one-shot 1024B max).
         * - Si report.process=Y, procesa headers+details con el bloque entre corchetes (parser legacy).
         * - Si report.process=N, escribe el contenido crudo tal cual llega del servidor.
         * - Si el parser falla, hace fallback al crudo (manteniendo el comportamiento del legado).
         * - Muestra en pantalla el nombre del archivo de reporte generado.
         */
        private void runReport() {
            logger.info("=== OPCION 2: Reporte ===");

            validateEnvironmentForReport();

            String date = effectiveDate(cliDateArg);
            String effectiveFileName = (fileNameArg != null && !fileNameArg.isEmpty())
                    ? fileNameArg
                    : generateFileNameFromTemplate(cfg.fileNameTemplate, date);

            if (effectiveFileName == null || effectiveFileName.isEmpty()) {
                throw new IllegalArgumentException("No hay FILE_NAME: CLI o fileNameTemplate requerido.");
            }
            if (effectiveFileName.length() != 9) {
                throw new IllegalArgumentException("FILE_NAME efectivo debe tener 9 caracteres. Obtenido: '" + effectiveFileName + "'");
            }
            logger.info("FILE_NAME efectivo: " + effectiveFileName);

            // Nombre base de consulta (desde INI). Equivalente al original "10101{file}{julian}"
            String nameBase = applyNameTemplate(cfg.reportNameTemplate, effectiveFileName, date);
            logger.info("Nombre base de reporte: " + nameBase);

            String acceptedFirst = cfg.firstAcceptedCodeOrDefault();
            boolean found = false;

            // Acumuladores: crudo (para escribir tal cual) y con corchetes (para parser legacy)
            StringBuilder rawAcc = new StringBuilder();
            StringBuilder fmtAcc = new StringBuilder();

            try (Socket sock = new Socket()) {
                logger.info("[IP:" + cfg.host + "][PTO:" + cfg.port + "]");
                sock.connect(new InetSocketAddress(cfg.host, cfg.port), cfg.connectTimeoutMs);
                sock.setSoTimeout(cfg.soTimeoutMs);
                logger.info("Estado de conexion con el MIP: " + sock.isConnected());

                // Consulta secuencias 01..99. Por CADA una se lee UN solo bloque (one-shot 1024B)
                for (int i = 1; i <= 99; i++) {
                    String secStr = String.format("%02d", i);
                    String queryName = nameBase + secStr;

                    logger.info("*** Consultando archivo de respuesta al MIP: " + queryName);
                    writeNameFrame(sock, queryName, cfg.codePage);

                    logger.info("*** Respuesta del MIP: ");
                    rawAcc.setLength(0);
                    fmtAcc.setLength(0);

                    // Lectura one-shot como el original (un solo read de 1024 bytes max + filtrado imprimibles)
                    String chunk = readLegacyBlock(sock, cfg.codePage);
                    rawAcc.append(chunk);                           // crudo (filtrado como el legado)
                    fmtAcc.append("[").append(chunk).append("]\n"); // un solo par de corchetes (parser legacy)

                    // Archivo encontrado si coincide exactamente con algun acceptedCode
                    if (containsAny(rawAcc.toString(), cfg.acceptedCodes)) {
                        logger.info("Archivo encontrado [OK]");
                        found = true;
                        break;
                    } else {
                        logger.info("Buscando...");
                    }
                }

                if (found) {
                    logger.info("*** Generando archivo de respuesta (Reporte)...");
                    String dataToWrite;
                    if (cfg.reportProcess) {
                        // Procesado con parser legacy; si falla, fallback a crudo
                        try {
                            dataToWrite = orderDetails(fmtAcc.toString(), acceptedFirst);
                        } catch (Exception ex) {
                            logger.severe("Ocurrio un error al ordenar el contenido del archivo: " + ex.getMessage());
                            dataToWrite = rawAcc.toString(); // fallback
                        }
                    } else {
                        dataToWrite = rawAcc.toString(); // crudo
                    }

                    String reportName = writeDataToFile(date, dataToWrite, effectiveFileName);
                    if (reportName != null) {
                        // Pintar en pantalla el nombre del reporte, estilo legado
                        logger.info("Reporte: " + reportName + "[GENERADO]");
                        logger.info("*** Reporte generado: [OK]");
                    } else {
                        logger.severe("No se pudo generar el reporte.");
                    }
                } else {
                    logger.severe("*** Respuesta del MIP: Archivo no encontrado [FAIL]");
                }
            } catch (UnknownHostException e) {
                logger.severe("Host desconocido: " + e.getMessage());
            } catch (SocketTimeoutException e) {
                logger.severe("Timeout de socket: " + e.getMessage());
            } catch (ConnectException e) {
                logger.severe("No se pudo conectar a " + cfg.host + ":" + cfg.port + " - " + e.getMessage());
            } catch (IOException e) {
                logger.severe("IO de red fallo: " + e.getMessage());
            } catch (Exception e) {
                logger.severe("Error inesperado en reporte: " + e.getMessage());
            }

            logger.info("=== PROCESO FINALIZADO (OPCION 2) ===");
        }

        // ----------------------------- Utilidades -----------------------------

        /** true si value coincide exactamente con algun elemento de options. */
        private static boolean matchesAny(String value, List<String> options) {
            if (options == null || options.isEmpty()) return false;
            for (String o : options) if (value.equals(o)) return true;
            return false;
        }

        /** true si hay algun acceptedCode contenido como substring. */
        private static boolean containsAny(String haystack, List<String> options) {
            if (options == null || options.isEmpty()) return false;
            for (String o : options) if (haystack.contains(o)) return true;
            return false;
        }

        /**
         * Trailer final de 11 bytes.
         *
         * Cuerpo = EBCDIC(acceptedCode de 7 chars) + contador(4B big-endian).
         */
        private static void writeTrailerFrame(Socket s, int count, Charset ebcdic, String trailerCode7) throws IOException {
            if (trailerCode7 == null || trailerCode7.length() != 7) {
                throw new IllegalArgumentException("El codigo de trailer debe tener 7 caracteres.");
            }
            byte[] prefix = trailerCode7.getBytes(ebcdic);
            byte[] cnt = lengthToBytes(count, 4);
            byte[] body = new byte[11];
            System.arraycopy(prefix, 0, body, 0, 7);
            System.arraycopy(cnt,    0, body, 7, 4);
            writeFrameRaw(s, body);
        }

        /**
         * Genera FILE_NAME desde fileNameTemplate (case-insensitive).
         * Reglas: literal (9), {rand}=4 digitos, {ddmm}=dia+mes.
         */
        private static String generateFileNameFromTemplate(String template, String yyyymmdd) {
            if (template == null || template.trim().isEmpty()) {
                throw new IllegalArgumentException("fileNameTemplate no definido en el INI.");
            }
            String base = template.trim();
            LocalDate d = LocalDate.parse(yyyymmdd, DateTimeFormatter.BASIC_ISO_DATE);
            String ddmm = String.format("%02d%02d", d.getDayOfMonth(), d.getMonthValue());

            base = base.replaceAll("(?i)\\{ddmm\\}", ddmm);

            if (base.matches("(?i).*\\{rand\\}.*")) {
                String rand4 = String.format("%04d", new Random().nextInt(10000));
                base = base.replaceAll("(?i)\\{rand\\}", rand4);
            }

            base = base.toUpperCase(Locale.ROOT);

            if (base.length() != 9) {
                throw new IllegalArgumentException("fileNameTemplate debe producir 9 caracteres. Obtenido '" + base + "' (" + base.length() + ")");
            }
            return base;
        }

        /**
         * Aplica plantilla de nombre.
         * Tokens: {file}, {julian}, {yyyymmdd}, {yy}, {mm}, {dd} (case-insensitive).
         */
        private static String applyNameTemplate(String template, String fileName, String yyyymmdd) {
            LocalDate d = LocalDate.parse(yyyymmdd, DateTimeFormatter.BASIC_ISO_DATE);
            String julian = String.format("%03d", d.getDayOfYear());
            String yy = String.format("%02d", d.getYear() % 100);
            String mm = String.format("%02d", d.getMonthValue());
            String dd = String.format("%02d", d.getDayOfMonth());

            String out = template;
            out = out.replaceAll("(?i)\\{file\\}",     java.util.regex.Matcher.quoteReplacement(fileName));
            out = out.replaceAll("(?i)\\{julian\\}",   julian);
            out = out.replaceAll("(?i)\\{yyyymmdd\\}", yyyymmdd);
            out = out.replaceAll("(?i)\\{yy\\}",       yy);
            out = out.replaceAll("(?i)\\{mm\\}",       mm);
            out = out.replaceAll("(?i)\\{dd\\}",       dd);
            return out;
        }

        /** Devuelve fecha efectiva YYYYMMDD tomando CLI si viene; si no, hoy. */
        private static String effectiveDate(String cliDate) {
            if (cliDate != null && validateDate(cliDate)) return cliDate;
            return LocalDate.now().format(DateTimeFormatter.BASIC_ISO_DATE);
        }

        /** Valida fecha AAAAMMDD. */
        static boolean validateDate(String date) {
            try {
                DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyyMMdd");
                LocalDate.parse(date, formatter);
                return true;
            } catch (Exception e) {
                return false;
            }
        }

        /**
         * Escribe trama de nombre (texto -> EBCDIC) con header de 2 bytes.
         */
        private static void writeNameFrame(Socket s, String text, Charset ebcdic) throws IOException {
            byte[] body = text.getBytes(ebcdic);
            writeFrameRaw(s, body);
        }

        /**
         * Escribe trama de datos con prefijo 'R' (ASCII), luego convierte a EBCDIC y envia.
         */
        private static void writeChunkFrame(Socket s, byte[] asciiChunk, Charset ebcdic) throws IOException {
            ByteArrayOutputStream baos = new ByteArrayOutputStream(1 + asciiChunk.length);
            baos.write((byte) 'R');
            baos.write(asciiChunk);
            String asText = new String(baos.toByteArray(), StandardCharsets.US_ASCII);
            byte[] body = asText.getBytes(ebcdic);
            writeFrameRaw(s, body);
        }

        /** Escribe header(2B) + body en el socket y hace flush. */
        private static void writeFrameRaw(Socket s, byte[] body) throws IOException {
            int len = body.length;
            byte[] header = lengthToBytes(len, 2);
            OutputStream os = s.getOutputStream();
            os.write(header);
            os.write(body);
            os.flush();
        }

        /**
         * Lee respuesta del servidor hasta lectura corta o timeout (acumulativa).
         * Decodifica desde EBCDIC a String.
         */
        private static String readResponse(Socket s, Charset ebcdic) throws IOException {
            ByteArrayOutputStream baos = new ByteArrayOutputStream();
            InputStream is = s.getInputStream();
            byte[] buf = new byte[1024];
            int n;
            while (true) {
                try {
                    n = is.read(buf);
                    if (n == -1) break;
                    baos.write(buf, 0, n);
                    if (n < buf.length) break;
                } catch (SocketTimeoutException te) {
                    if (baos.size() == 0) throw te;
                    break;
                }
            }
            byte[] ebcdicBytes = baos.toByteArray();
            return new String(ebcdicBytes, ebcdic);
        }

        /**
         * Lectura one-shot (como el legado InSocket): un solo read() de 1024 bytes, EBCDIC->String,
         * filtrando solo ASCII imprimible (' '..'~') y salto de linea '\n'.
         */
        private static String readLegacyBlock(Socket s, Charset ebcdic) throws IOException {
            InputStream is = s.getInputStream();
            byte[] buf = new byte[1024];
            int n = is.read(buf, 0, 1024);
            if (n <= 0) return "";
            String decoded = new String(buf, 0, n, ebcdic);
            StringBuilder out = new StringBuilder(decoded.length());
            for (int i = 0; i < decoded.length(); i++) {
                char c = decoded.charAt(i);
                if (c >= ' ' && c <= '~') {
                    out.append(c);
                } else if (c == '\n') {
                    out.append('\n');
                }
            }
            return out.toString();
        }

        // ---------------------- Historico (solo Opcion 1) ----------------------

        private static void createShippingHistory(String respCode, String fileName, String dateYYYYMMDD, Path historyPath) {
            try {
                monthlyRotateIfFirstDay(historyPath);
                String record = formatHistory(respCode, fileName, dateYYYYMMDD, LocalDateTime.now());
                prependLine(historyPath, record);
                logger.info("Historico actualizado: " + historyPath);
            } catch (Exception e) {
                logger.severe("No se pudo actualizar el historico: " + e.getMessage());
            }
        }

        private static void monthlyRotateIfFirstDay(Path historyPath) {
            if (LocalDate.now().getDayOfMonth() == 1) {
                try {
                    Files.write(historyPath, new byte[0],
                            StandardOpenOption.CREATE, StandardOpenOption.TRUNCATE_EXISTING);
                } catch (IOException e) {
                    logger.warning("No se pudo rotar historico mensual: " + e.getMessage());
                }
            }
        }

        private static String formatHistory(String resp, String code, String fec, LocalDateTime now) {
            String ts = now.format(DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss"));
            return "[" + resp + "-" + code + "-" + fec + ": " + ts + "]";
        }

        private static void prependLine(Path path, String line) throws IOException {
            List<String> lines = new ArrayList<>();
            if (Files.exists(path)) {
                try {
                    lines = Files.readAllLines(path, StandardCharsets.UTF-8);
                } catch (MalformedInputException mie) {
                    lines = new ArrayList<>();
                }
            }
            lines.add(0, line);
            Files.write(path, String.join(System.lineSeparator(), lines).getBytes(StandardCharsets.UTF_8),
                    StandardOpenOption.CREATE, StandardOpenOption.TRUNCATE_EXISTING, StandardOpenOption.WRITE);
        }

        // ------------------ Helpers de reporte (Opcion 2) ---------------------

        /**
         * Genera y escribe el archivo de reporte en el CWD.
         *
         * @return nombre del archivo creado o null si fallo.
         */
        private static String writeDataToFile(String dateYYYYMMDD, String data, String fileName9) throws IOException {
            logger.info("Parametro date: " + dateYYYYMMDD + " (" + dateYYYYMMDD.length() + ")");
            if (!validateDate(dateYYYYMMDD)) {
                logger.severe("Fecha ingresada no es valida: " + dateYYYYMMDD);
                return null;
            }
            final String newName = getNameFileReport(dateYYYYMMDD, fileName9);
            logger.info("Generacion de nombre de reporte es valido: " + (newName != null));
            if (newName == null) {
                logger.severe("Nombre de reporte no pudo generarse.");
                return null;
            }
            logger.info("Creando reporte...");
            try (FileOutputStream reportFile = new FileOutputStream(newName);
                 PrintStream ps = new PrintStream(reportFile, true, "UTF-8")) {
                ps.print(data);
            }
            return newName;
        }

        /**
         * Reordena el bloque recibido como el original: headers + details.
         */
        private static String orderDetails(String dataMipDato, String allOkCode) {
            String headers = extractHeaders(dataMipDato);
            String details = extractDetails(dataMipDato, allOkCode);
            return headers + details;
        }

        /**
         * Extrae cabeceras desde el bloque recibido.
         */
        private static String extractHeaders(String data) {
            String header = data.replace(">", "").substring(0, 20) + "]\n";
            int firstIndexDetail = data.indexOf("16");
            String headerInfo;
            if (firstIndexDetail != -1) {
                headerInfo = data.substring(data.indexOf("12"), firstIndexDetail);
            } else {
                headerInfo = data.substring(data.indexOf("12"), data.indexOf("]", data.indexOf("12")));
            }
            return header + headerInfo;
        }

        /**
         * Extrae detalles desde el bloque recibido, respetando anchos fijos.
         */
        private static String extractDetails(String data, String allOkCode) {
            int firstIndexDetail = data.indexOf("16");
            StringBuilder detail = new StringBuilder();
            if (firstIndexDetail != -1) {
                String[] detailsData = data.substring(firstIndexDetail).replace("[", "").replace("]\n", "").split("D0");
                for (int i = 1; i < detailsData.length; i++) {
                    detail.append("16");
                    if (detailsData[i].substring(57).length() < 26) {
                        String codErrors = String.format("%26s", detailsData[i].substring(57).trim().substring(0, 15));
                        detail.append(detailsData[i].substring(0, 57)).append(codErrors);
                        continue;
                    }
                    if (i == detailsData.length - 1) {
                        if (detailsData[i].substring(57).length() < 26) {
                            String codErrors = String.format("%26s", detailsData[i].substring(57).trim().substring(0, 15));
                            detail.append(detailsData[i].substring(0, 57)).append(codErrors).append(allOkCode);
                        } else {
                            int codresp = detailsData[i].indexOf(allOkCode);
                            if (codresp != -1) {
                                detail.append(detailsData[i].substring(0, codresp + allOkCode.length()));
                            }
                        }
                        break;
                    }
                    detail.append(detailsData[i].substring(0, 83));
                }
                return detail.toString().replace("D0", "\nD0");
            }
            return detail.toString();
        }

        /**
         * Nombre de archivo de reporte: NNNN-YYYYMMDD-Archivo de Cambio Confirmacion
         */
        private static String getNameFileReport(String dateYYYYMMDD, String fileName9) {
            final String description = "-Archivo de Cambio Confirmacion";
            DateTimeFormatter inputFormatter = DateTimeFormatter.ofPattern("yyyyMMdd");
            DateTimeFormatter outputFormatter = DateTimeFormatter.ofPattern("yyyyMMdd");
            String prefix = fileName9.substring(0, 4) + "-";
            try {
                LocalDate fecha = LocalDate.parse(dateYYYYMMDD, inputFormatter);
                return prefix + fecha.format(outputFormatter) + description;
            } catch (Exception e) {
                logger.severe("Parametro date(" + dateYYYYMMDD + ") incorrecto.");
                return null;
            }
        }
    }
}

