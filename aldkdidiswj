//=================================================================================================
// McBatchSender
//
// Proposito:
//   Cliente TCP simple para envio y descarga de archivos contra el hub (ej. Mastercard).
//   - Opcion 1: Envio (particiona en tramas y envia trailer).
//   - Opcion 2: Descarga y genera reporte (procesa headers+details).
//   - Opcion 3: Descarga cruda (solo guarda lo recibido, sin parseo).
//   - Opcion 4: Envio manual (host/puerto/archivo por consola).
//
// Protocolo de marco:
//   Cada trama: header de 2 bytes (longitud big-endian) + cuerpo en EBCDIC.
//   - Nombre: texto plano en EBCDIC.
//   - Trama de datos: prefijo ASCII 'R' + bytes del archivo (todo convertido a EBCDIC).
//   - Trailer 11B: 7 chars de acceptedCode + contador(4B) big-endian (los 4B pasan por
//     translateByteForDiscrepancy para calzar con el legado).
//
// Notas de comportamiento:
//   - La verificacion de exito ahora es estricta: solo se considera OK si la respuesta del
//     servidor contiene al menos uno de los codigos en acceptedCode. Caso contrario, se registra
//     preview de 80B y se crea un archivo ERROR_<FILE> con el cuerpo crudo.
//   - La conversion EBCDIC es manual, basada en tablas del programa original.
//
// Uso tipico:
//   javac McBatchSender.java
//   java McBatchSender <OPCION> <SECCION> <FILE> <YYYYMMDD>
//   Si no pasas parametros, entra a modo interactivo (menu).
//
// Codigos de salida:
//   0 OK | 2 uso invalido | 3 INI no encontrado | 4 config invalida | 1 error inesperado
//=================================================================================================

import java.io.*;
import java.net.*;
import java.nio.file.*;
import java.time.*;
import java.time.format.DateTimeFormatter;
import java.util.*;
import java.util.logging.Logger;

public class McBatchSender {
    private static final Logger logger = Logger.getLogger(McBatchSender.class.getName());

    // ====== ENTRADA PRINCIPAL ======
    public static void main(String[] args) {
        System.out.println("INICIA PROCESO");

        try {
            if (args.length == 0) {
                new Interactive().run();
                return;
            }

            if (args.length != 4) {
                System.err.println("Uso: java McBatchSender <OPCION> <SECCION> <FILE> <YYYYMMDD>");
                System.exit(2);
            }

            int option = Integer.parseInt(args[0].trim());
            String section = args[1].trim();
            String fileParam = args[2].trim().toUpperCase();
            String dateStr = args[3].trim();

            Path ini = Paths.get("mcsender.ini");
            IniFile cfgFile = IniFile.load(ini);
            Config cfg = Config.from(cfgFile, section);

            // Mostrar a que seccion y a donde vamos a conectar
            logger.info("Seccion: " + section);
            logger.info("Host: " + cfg.host + " Puerto: " + cfg.port);
            logger.info("acceptedCode: " + cfg.acceptedCodes);

            // Armar el nombre efectivo segun opcion
            String namePreview = (option == 1)
                    ? applyFormat(cfg.nameTemplate, fileParam, dateStr)
                    : applyFormat(cfg.reportNameTemplate, fileParam, dateStr);
            System.out.println("Nombre a consultar/enviar: " + namePreview);

            new Sender(cfg, option, fileParam, dateStr).run();
            System.exit(0);

        } catch (NoSuchFileException e) {
            System.err.println("No se encontro el archivo INI: " + e.getFile());
            System.exit(3);
        } catch (IllegalArgumentException e) {
            System.err.println("Configuracion/argumento invalido: " + e.getMessage());
            System.exit(4);
        } catch (Exception e) {
            System.err.println("Error inesperado: " + e.getMessage());
            System.exit(1);
        }
    }

    // ====== MENU INTERACTIVO ======
    static class Interactive {
        // Menu rapido por consola. Siempre pide file y fecha.
        void run() {
            try (Scanner sc = new Scanner(System.in)) {
                System.out.println("Seleccione opcion:");
                System.out.println("1) Envio");
                System.out.println("2) Descarga y genera reporte");
                System.out.println("3) Descarga");
                System.out.println("4) Envio manual");
                System.out.print("Opcion: ");
                int opt = Integer.parseInt(sc.nextLine().trim());

                if (opt < 1 || opt > 4) {
                    System.out.println("Opcion invalida");
                    return;
                }

                if (opt == 4) {
                    // Envio manual: host/puerto/file/fecha
                    System.out.print("Host: ");
                    String host = sc.nextLine().trim();
                    System.out.print("Puerto: ");
                    int port = Integer.parseInt(sc.nextLine().trim());
                    System.out.print("FILE (nombre logico): ");
                    String file = sc.nextLine().trim().toUpperCase();
                    System.out.print("YYYYMMDD: ");
                    String date = sc.nextLine().trim();

                    // Cargar INI para otros valores comunes
                    Path ini = Paths.get("mcsender.ini");
                    IniFile cfgFile = IniFile.load(ini);
                    // Tomamos alguna seccion para acceptedCodes y plantillas, por simplicidad MIP si existe
                    Config base = Config.from(cfgFile, cfgFile.anySectionOr("MIP"));

                    Config manual = base.overrideHost(host, port);
                    // Mostrar informacion antes de enviar
                    String namePrev = applyFormat(manual.nameTemplate, file, date);
                    System.out.println("Se enviara a " + manual.host + ":" + manual.port + " con nombre: " + namePrev);

                    new Sender(manual, 1, file, date).run();
                    return;
                }

                System.out.print("Seccion del INI: ");
                String section = sc.nextLine().trim();

                // Cargar INI y validar seccion
                Path ini = Paths.get("mcsender.ini");
                IniFile cfgFile = IniFile.load(ini);
                if (!cfgFile.hasSection(section)) {
                    System.out.println("Seccion no existe: " + section);
                    return;
                }
                Config cfg = Config.from(cfgFile, section);

                // Mostrar datos de conexion y codigos OK
                System.out.println("Host: " + cfg.host + " Puerto: " + cfg.port);
                System.out.println("acceptedCode: " + cfg.acceptedCodes);

                System.out.print("FILE (nombre logico o literal segun formato): ");
                String file = sc.nextLine().trim().toUpperCase();

                System.out.print("YYYYMMDD: ");
                String date = sc.nextLine().trim();

                // Previsualizar nombre
                String namePrev = (opt == 1)
                        ? applyFormat(cfg.nameTemplate, file, date)
                        : applyFormat(cfg.reportNameTemplate, file, date);
                System.out.println("Nombre a consultar/enviar: " + namePrev);

                new Sender(cfg, opt, file, date).run();
            } catch (Exception e) {
                System.err.println("Error interactivo: " + e.getMessage());
            }
        }
    }

    // ====== CONFIG ======
    static class Config {
        final String host;
        final int port;
        final int connectTimeoutMs;
        final int soTimeoutMs;
        final int chunkSize;
        final Path dataFilePath;
        final Path historyFilePath;
        final List<String> acceptedCodes;
        final String alreadySentSubstring;
        final String defaultFailCode;
        final String nameTemplate;
        final String reportNameTemplate;

        private Config(String host, int port, int connectTimeoutMs, int soTimeoutMs, int chunkSize,
                       Path dataFilePath, Path historyFilePath, List<String> acceptedCodes,
                       String alreadySentSubstring, String defaultFailCode,
                       String nameTemplate, String reportNameTemplate) {
            this.host = host;
            this.port = port;
            this.connectTimeoutMs = connectTimeoutMs;
            this.soTimeoutMs = soTimeoutMs;
            this.chunkSize = chunkSize;
            this.dataFilePath = dataFilePath;
            this.historyFilePath = historyFilePath;
            this.acceptedCodes = acceptedCodes;
            this.alreadySentSubstring = alreadySentSubstring;
            this.defaultFailCode = defaultFailCode;
            this.nameTemplate = nameTemplate;
            this.reportNameTemplate = reportNameTemplate;
        }

        static Config from(IniFile ini, String section) {
            Map<String, String> s = ini.section(section);
            if (s == null) throw new IllegalArgumentException("No existe la seccion [" + section + "]");

            String host = req(s, "host");
            int port = parseInt(s.get("port"), 1, 65535, "port");
            int connectTimeout = parseInt(s.getOrDefault("connectTimeoutMs", "60000"), 1000, 300000, "connectTimeoutMs");
            int soTimeout = parseInt(s.getOrDefault("soTimeoutMs", "60000"), 1000, 300000, "soTimeoutMs");
            int chunk = parseInt(s.getOrDefault("chunkSize", "980"), 1, 65535, "chunkSize");

            Path dataPath = resolve("dataFilePath", s.getOrDefault("dataFilePath", "MIPFILE_DATI"));
            Path histPath = resolve("historyFilePath", s.getOrDefault("historyFilePath", "MIPFILE_HISTORY_R"));

            List<String> accepted = parseList(s.getOrDefault("acceptedCode", "9980100"));
            String already = s.getOrDefault("alreadySentSubstring", "9288W");
            String failDef = s.getOrDefault("defaultFailCode", "9980101");

            String nameTpl = s.getOrDefault("nameTemplate", "00401{FILE}{julianDate}");
            String rptTpl = s.getOrDefault("reportNameTemplate", "10101{FILE}{julianDate}");

            return new Config(host, port, connectTimeout, soTimeout, chunk,
                    dataPath, histPath, accepted, already, failDef, nameTpl, rptTpl);
        }

        Config overrideHost(String h, int p) {
            return new Config(h, p, connectTimeoutMs, soTimeoutMs, chunkSize,
                    dataFilePath, historyFilePath, acceptedCodes, alreadySentSubstring, defaultFailCode,
                    nameTemplate, reportNameTemplate);
        }

        static String req(Map<String, String> m, String k) {
            String v = m.get(k);
            if (v == null || v.trim().isEmpty()) throw new IllegalArgumentException("Falta " + k);
            return v.trim();
        }

        static int parseInt(String s, int min, int max, String name) {
            try {
                int v = Integer.parseInt(s.trim());
                if (v < min || v > max) throw new IllegalArgumentException(name + " fuera de rango");
                return v;
            } catch (Exception e) {
                throw new IllegalArgumentException(name + " no numerico: " + s);
            }
        }

        static List<String> parseList(String csv) {
            List<String> out = new ArrayList<>();
            for (String p : csv.split(",")) {
                String t = p.trim();
                if (!t.isEmpty()) out.add(t);
            }
            return out;
        }

        static Path resolve(String label, String p) {
            Path path = Paths.get(p);
            if (path.isAbsolute()) return path.normalize();
            return Paths.get(System.getProperty("user.dir")).resolve(p).normalize();
        }
    }

    // ====== INI SIMPLE ======
    static class IniFile {
        private final Map<String, Map<String, String>> data = new LinkedHashMap<>();

        static IniFile load(Path path) throws IOException {
            if (!Files.exists(path)) throw new NoSuchFileException(path.toString());
            IniFile f = new IniFile();
            Map<String, String> cur = null;
            try (BufferedReader br = Files.newBufferedReader(path)) {
                String line;
                while ((line = br.readLine()) != null) {
                    String ln = line.trim();
                    if (ln.isEmpty() || ln.startsWith("#") || ln.startsWith(";")) continue;
                    if (ln.startsWith("[") && ln.endsWith("]")) {
                        String sec = ln.substring(1, ln.length() - 1).trim();
                        cur = f.data.computeIfAbsent(sec, k -> new LinkedHashMap<>());
                    } else {
                        int eq = ln.indexOf('=');
                        if (eq < 0 || cur == null) continue;
                        String k = ln.substring(0, eq).trim();
                        String v = ln.substring(eq + 1).trim();
                        cur.put(k, v);
                    }
                }
            }
            return f;
        }

        boolean hasSection(String name) { return data.containsKey(name); }
        String anySectionOr(String fallback) {
            if (!data.isEmpty()) return data.keySet().iterator().next();
            return fallback;
        }
        Map<String, String> section(String name) { return data.get(name); }
    }

    // ====== SENDER ======
    static class Sender {
        private final Config cfg;
        private final int option;
        private final String fileNameArg;
        private final String date;

        Sender(Config cfg, int option, String fileNameArg, String cliDateParam) {
            this.cfg = cfg;
            this.option = option;
            this.fileNameArg = fileNameArg;
            this.date = cliDateParam;
        }

        void run() {
            switch (option) {
                case 1: runSend(); break;
                case 2: runReport(); break;
                case 3: runDownloadRaw(); break;
                case 4: runManualSend(); break;
                default:
                    throw new IllegalArgumentException("OPCION invalida: " + option);
            }
        }

        // ----- Opcion 1: Envio -----
        private void runSend() {
            logger.info("=== OPCION 1: Envio ===");
            validateEnvForSend();

            byte[] payload = readAll(cfg.dataFilePath);
            if (payload.length == 0) {
                logger.warning("Archivo de datos vacio");
                createHistory(cfg.defaultFailCode, fileNameArg, date, cfg.historyFilePath);
                return;
            }

            List<byte[]> parts = split(payload, cfg.chunkSize);

            String nameToSend = applyFormat(cfg.nameTemplate, fileNameArg, date);
            System.out.println("Nombre a enviar: " + nameToSend);
            String finalStatus = cfg.defaultFailCode;

            try (Socket sock = new Socket()) {
                sock.connect(new InetSocketAddress(cfg.host, cfg.port), cfg.connectTimeoutMs);
                sock.setSoTimeout(cfg.soTimeoutMs);
                logger.info("Conectado a " + cfg.host + ":" + cfg.port);

                // 1) enviar nombre
                writeNameFrame(sock, nameToSend);

                // 2) respuesta de aprobacion
                String resp = readResponse(sock).trim();
                logger.info("Aprobacion: [" + resp + "]");

                if (!cfg.alreadySentSubstring.isEmpty() && resp.contains(cfg.alreadySentSubstring)) {
                    logger.info("Servidor indica ya enviado");
                    finalStatus = firstAcceptedOrDefault(cfg);
                } else if (hasAccepted(resp, cfg.acceptedCodes)) {
                    // 3) enviar tramas R + trailer
                    for (byte[] p : parts) writeChunkFrame(sock, p);
                    writeTrailerFrame(sock, parts.size() + 1, trailerSeven(cfg));

                    // 4) confirmacion final
                    String resp2 = readResponse(sock).trim();
                    logger.info("Confirmacion final: [" + resp2 + "]");
                    if (hasAccepted(resp2, cfg.acceptedCodes)) {
                        finalStatus = firstAcceptedOrDefault(cfg);
                        logger.info("RESULTADO ENVIO OK");
                    } else {
                        logger.warning("RESULTADO ENVIO FAIL");
                    }
                } else {
                    logger.warning("Nombre rechazado");
                }
            } catch (Exception e) {
                logger.severe("Error envio: " + e.getMessage());
            } finally {
                createHistory(finalStatus, fileNameArg, date, cfg.historyFilePath);
            }
            logger.info("=== FIN OPCION 1 ===");
        }

        // ----- Opcion 2: Reporte (procesa) -----
        private void runReport() {
            logger.info("=== OPCION 2: Reporte ===");
            validateEnvForReport();

            String base = applyFormat(cfg.reportNameTemplate, fileNameArg, date);
            System.out.println("Nombre base de reporte: " + base);

            boolean found = false;
            String raw = "";

            try (Socket sock = new Socket()) {
                sock.connect(new InetSocketAddress(cfg.host, cfg.port), cfg.connectTimeoutMs);
                sock.setSoTimeout(cfg.soTimeoutMs);
                logger.info("Conectado a " + cfg.host + ":" + cfg.port);

                for (int i = 1; i <= 99; i++) {
                    String sec = String.format("%02d", i);
                    String qName = base + sec;
                    logger.info("Consultando: " + qName);
                    writeNameFrame(sock, qName);

                    raw = readLegacyBlock(sock);
                    if (hasAccepted(raw, cfg.acceptedCodes)) {
                        found = true;
                        break;
                    } else {
                        logger.info("Buscando...");
                    }
                }

                if (!found) {
                    logger.severe("*** Reporte FALLIDO (no se encontro acceptedCode)");
                    System.out.println("[Preview 80B] " + preview80(raw));
                    writeErrorDump(fileNameArg, date, raw);
                    logger.info("=== FIN OPCION 2 ===");
                    return;
                }

                // Procesar headers + detalles
                String dataToWrite;
                try {
                    String fmt = "[" + first20(raw) + "]\n" + extractHeaders(raw) + extractDetailsReport(raw, firstAcceptedOrDefault(cfg));
                    // extractHeaders(raw) espera H y 12..; usamos el comportamiento de legado: ya lo empaquetamos
                    dataToWrite = orderDetailsLegacy("[" + raw + "]\n", firstAcceptedOrDefault(cfg));
                } catch (Exception ex) {
                    // Fallback al legado directo
                    try {
                        dataToWrite = orderDetailsLegacy("[" + raw + "]\n", firstAcceptedOrDefault(cfg));
                    } catch (Exception e) {
                        dataToWrite = raw;
                    }
                }

                writeReportFile(date, dataToWrite, fileNameArg);
                logger.info("*** Reporte generado OK");
            } catch (Exception e) {
                logger.severe("Error reporte: " + e.getMessage());
            }
            logger.info("=== FIN OPCION 2 ===");
        }

        // ----- Opcion 3: Descarga cruda -----
        private void runDownloadRaw() {
            logger.info("=== OPCION 3: Descarga ===");
            validateEnvForReport();

            String q = applyFormat(cfg.reportNameTemplate, fileNameArg, date);
            System.out.println("Nombre a solicitar: " + q);

            String raw = "";
            boolean ok;

            try (Socket sock = new Socket()) {
                sock.connect(new InetSocketAddress(cfg.host, cfg.port), cfg.connectTimeoutMs);
                sock.setSoTimeout(cfg.soTimeoutMs);
                logger.info("Conectado a " + cfg.host + ":" + cfg.port);

                writeNameFrame(sock, q);
                raw = readLegacyBlock(sock);

                ok = hasAccepted(raw, cfg.acceptedCodes);
                if (!ok) {
                    logger.severe("*** Descarga FALLIDA (no se encontro acceptedCode)");
                    System.out.println("[Preview 80B] " + preview80(raw));
                    writeErrorDump(fileNameArg, date, raw);
                    logger.info("=== FIN OPCION 3 ===");
                    return;
                }

                // Exito: escribir tal cual
                writeRawFile(q, raw);
                logger.info("*** Descarga OK");
            } catch (Exception e) {
                logger.severe("Error descarga: " + e.getMessage());
            }
            logger.info("=== FIN OPCION 3 ===");
        }

        // ----- Opcion 4: Envio manual (ya armado en Interactive) -----
        private void runManualSend() {
            logger.info("=== OPCION 4: Envio manual ===");
            runSend();
        }

        // ===== Utilidades de envio/descarga =====

        private void validateEnvForSend() {
            File cwd = new File(System.getProperty("user.dir"));
            if (!cwd.canRead() || !cwd.canExecute()) {
                throw new IllegalStateException("CWD sin permisos");
            }

            File f = cfg.dataFilePath.toFile();
            if (!f.exists() || !f.canRead()) {
                throw new IllegalStateException("No existe o no es legible dataFilePath");
            }

            try (FileOutputStream os = new FileOutputStream(cfg.historyFilePath.toFile(), true)) {
                // ok
            } catch (IOException e) {
                throw new IllegalStateException("No se puede abrir historyFilePath: " + e.getMessage());
            }
        }

        private void validateEnvForReport() {
            File cwd = new File(System.getProperty("user.dir"));
            if (!cwd.canRead() || !cwd.canWrite() || !cwd.canExecute()) {
                throw new IllegalStateException("CWD sin permisos para reporte/descarga");
            }
        }

        private static byte[] readAll(Path p) {
            try { return Files.readAllBytes(p); }
            catch (IOException e) { throw new RuntimeException(e); }
        }

        private static List<byte[]> split(byte[] data, int chunk) {
            List<byte[]> out = new ArrayList<>();
            for (int off = 0; off < data.length; off += chunk) {
                int len = Math.min(chunk, data.length - off);
                out.add(Arrays.copyOfRange(data, off, off + len));
            }
            return out;
        }

        // Envia header(2B) + cuerpo EBCDIC(nombre)
        private static void writeNameFrame(Socket s, String text) throws IOException {
            byte[] eb = toEbcdic(text.getBytes()); // manual
            writeFrameRaw(s, eb);
        }

        // Envia trama R + bytes ASCII del chunk, todo en EBCDIC
        private static void writeChunkFrame(Socket s, byte[] asciiChunk) throws IOException {
            ByteArrayOutputStream baos = new ByteArrayOutputStream(1 + asciiChunk.length);
            baos.write((byte) 'R');
            baos.write(asciiChunk);
            byte[] eb = toEbcdic(baos.toByteArray());
            writeFrameRaw(s, eb);
        }

        // Trailer 11B = 7 chars + 4 bytes contador (ajuste de discrepancia)
        private static void writeTrailerFrame(Socket s, int count, String trailer7) throws IOException {
            if (trailer7 == null || trailer7.length() != 7) {
                throw new IllegalArgumentException("Trailer 7 invalido");
            }
            byte[] body = new byte[11];
            byte[] prefix = toEbcdic(trailer7.getBytes());
            System.arraycopy(prefix, 0, body, 0, 7);

            byte[] cnt = lengthToBytes(count, 4);
            // Ajuste legado
            for (int i = 0; i < 4; i++) {
                cnt[i] = (byte) translateByteForDiscrepancy(cnt[i]);
            }
            System.arraycopy(cnt, 0, body, 7, 4);

            writeFrameRaw(s, body);
        }

        private static void writeFrameRaw(Socket s, byte[] body) throws IOException {
            int len = body.length;
            byte[] header = lengthToBytes(len, 2);
            OutputStream os = s.getOutputStream();
            os.write(header);
            os.write(body);
            os.flush();
        }

        private static byte[] lengthToBytes(int num, int byts) {
            byte[] r = new byte[byts];
            for (int i = byts - 1; i >= 0; --i) {
                r[i] = (byte) (num & 0xFF);
                num >>>= 8;
            }
            return r;
        }

        // Lectura generica con EBCDIC->ASCII manual
        private static String readResponse(Socket s) throws IOException {
            ByteArrayOutputStream baos = new ByteArrayOutputStream();
            InputStream is = s.getInputStream();
            byte[] buf = new byte[1024];
            int n;
            while (true) {
                try {
                    n = is.read(buf);
                    if (n == -1) break;
                    baos.write(buf, 0, n);
                    if (n < buf.length) break;
                } catch (SocketTimeoutException te) {
                    if (baos.size() == 0) throw te;
                    break;
                }
            }
            byte[] eb = baos.toByteArray();
            return fromEbcdicToAsciiString(eb);
        }

        // Lectura one-shot (legado) con filtrado de imprimibles
        private static String readLegacyBlock(Socket s) throws IOException {
            InputStream is = s.getInputStream();
            byte[] buf = new byte[1024];
            int n = is.read(buf, 0, 1024);
            if (n <= 0) return "";
            String decoded = fromEbcdicToAsciiString(Arrays.copyOf(buf, n));
            StringBuilder out = new StringBuilder(decoded.length());
            for (int i = 0; i < decoded.length(); i++) {
                char c = decoded.charAt(i);
                if (c >= ' ' && c <= '~') out.append(c);
                else if (c == '\n') out.append('\n');
            }
            return out.toString();
        }

        private static void writeReportFile(String yyyymmdd, String data, String fileName9) throws IOException {
            final String newName = fileName9.substring(0, 4) + "-" + yyyymmdd + "-Archivo de Cambio Confirmacion";
            try (PrintStream ps = new PrintStream(new FileOutputStream(newName), true, "UTF-8")) {
                ps.print(data);
            }
            logger.info("Reporte: " + newName + " [GENERADO]");
        }

        private static void writeRawFile(String queryName, String data) throws IOException {
            String out = "DESCARGA_" + sanitize(queryName);
            try (PrintStream ps = new PrintStream(new FileOutputStream(out), true, "UTF-8")) {
                ps.print(data);
            }
            logger.info("Archivo escrito: " + out);
        }

        private static String sanitize(String s) {
            return s.replaceAll("[^A-Za-z0-9._-]", "_");
        }

        private static void createHistory(String respCode, String fileName, String yyyymmdd, Path historyPath) {
            try {
                String ts = LocalDateTime.now().format(DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss"));
                String rec = "[" + respCode + "-" + fileName + "-" + yyyymmdd + ": " + ts + "]";
                prependLine(historyPath, rec);
            } catch (Exception e) {
                logger.severe("No se pudo actualizar history: " + e.getMessage());
            }
        }

        private static void prependLine(Path path, String line) throws IOException {
            List<String> lines = new ArrayList<>();
            if (Files.exists(path)) {
                try { lines = Files.readAllLines(path); }
                catch (Exception ignore) { lines = new ArrayList<>(); }
            }
            lines.add(0, line);
            Files.write(path, String.join(System.lineSeparator(), lines).getBytes(),
                    StandardOpenOption.CREATE, StandardOpenOption.TRUNCATE_EXISTING, StandardOpenOption.WRITE);
        }

        private static String trailerSeven(Config c) {
            for (String s : c.acceptedCodes) if (s != null && s.trim().length() == 7) return s.trim();
            throw new IllegalArgumentException("acceptedCode debe incluir uno de 7 chars para trailer");
        }

        private static String firstAcceptedOrDefault(Config c) {
            return c.acceptedCodes.isEmpty() ? c.defaultFailCode : c.acceptedCodes.get(0);
        }

        // Helpers de reporte legado
        private static String orderDetailsLegacy(String dataBracketed, String okCode) {
            String headers = extractHeaders(dataBracketed);
            String details = extractDetailsReport(dataBracketed, okCode);
            return headers + details;
        }

        // Primeros 20
        private static String first20(String s) {
            if (s == null) return "";
            return s.replace(">", "").substring(0, Math.min(20, s.length()));
        }
    }

    // ====== FORMATEO DE NOMBRE (plantillas) ======
    private static String applyFormat(String template, String file, String yyyymmdd) {
        if (template == null) template = "";
        if (file == null) file = "";
        LocalDate d = LocalDate.parse(yyyymmdd, DateTimeFormatter.BASIC_ISO_DATE);

        String jul = String.format("%03d", d.getDayOfYear());
        String yy = String.format("%02d", d.getYear() % 100);
        String mm = String.format("%02d", d.getMonthValue());
        String dd = String.format("%02d", d.getDayOfMonth());

        return template
                .replace("{FILE}", file)
                .replace("{julianDate}", jul)
                .replace("{yyyymmdd}", yyyymmdd)
                .replace("{yy}", yy)
                .replace("{mm}", mm)
                .replace("{dd}", dd);
    }

    // ====== VERIFICACION DE EXITO + PREVIEW + ERROR ======
    private static boolean hasAccepted(String text, List<String> acceptedCodes) {
        if (text == null || acceptedCodes == null || acceptedCodes.isEmpty()) return false;
        for (String c : acceptedCodes) {
            if (c != null && !c.isEmpty() && text.contains(c)) return true;
        }
        return false;
    }

    private static String preview80(String s) {
        if (s == null) return "";
        String p = s.replace("\r", " ").replace("\n", " ");
        return p.length() > 80 ? p.substring(0, 80) : p;
    }

    private static void writeErrorDump(String fileParam, String yyyymmdd, String content) {
        String safe = (fileParam == null || fileParam.isEmpty()) ? "NONAME" : fileParam;
        String outName = "ERROR_" + safe;
        try (PrintStream ps = new PrintStream(new FileOutputStream(outName), true, "UTF-8")) {
            ps.print(content == null ? "" : content);
        } catch (Exception e) {
            logger.severe("No se pudo escribir archivo de error: " + outName + " - " + e.getMessage());
        }
    }

    // ====== PARSER LEGADO (headers + details) ======
    private static String extractHeaders(String data) {
        String header = data.replace(">", "").substring(0, 20) + "]\n";
        int firstIndexDetail = data.indexOf("16");
        String headerInfo;
        if (firstIndexDetail != -1) {
            headerInfo = data.substring(data.indexOf("12"), firstIndexDetail);
        } else {
            headerInfo = data.substring(data.indexOf("12"), data.indexOf("]", data.indexOf("12")));
        }
        return header + headerInfo;
    }

    private static String extractDetailsReport(String data, String allOkCode) {
        int firstIndexDetail = data.indexOf("16");
        StringBuilder detail = new StringBuilder();
        if (firstIndexDetail != -1) {
            String[] detailsData = data.substring(firstIndexDetail).replace("[", "").replace("]\n", "").split("D0");
            for (int i = 1; i < detailsData.length; i++) {
                detail.append("16");
                if (detailsData[i].substring(57).length() < 26) {
                    String codErrors = String.format("%26s", detailsData[i].substring(57).trim().substring(0, 15));
                    detail.append(detailsData[i].substring(0, 57)).append(codErrors);
                    continue;
                }
                if (i == detailsData.length - 1) {
                    if (detailsData[i].substring(57).length() < 26) {
                        String codErrors = String.format("%26s", detailsData[i].substring(57).trim().substring(0, 15));
                        detail.append(detailsData[i].substring(0, 57)).append(codErrors).append(allOkCode);
                    } else {
                        int codresp = detailsData[i].indexOf(allOkCode);
                        if (codresp != -1) {
                            detail.append(detailsData[i].substring(0, codresp + allOkCode.length()));
                        }
                    }
                    break;
                }
                detail.append(detailsData[i].substring(0, 83));
            }
            return detail.toString().replace("D0", "\nD0");
        }
        return detail.toString();
    }

    // ====== CONVERSION EBCDIC MANUAL (del original) ======
    private static byte[] toEbcdic(byte[] ascii) {
        byte[] out = new byte[ascii.length];
        for (int i = 0; i < ascii.length; i++) {
            int v = ascii[i] & 0xFF;
            out[i] = (byte) translateByte("toEBC", v);
        }
        return out;
    }

    private static String fromEbcdicToAsciiString(byte[] ebcdic) {
        StringBuilder sb = new StringBuilder(ebcdic.length);
        for (byte b : ebcdic) {
            int i = b & 0xFF;
            char c = (char) translateByte("toASC", i);
            sb.append(c);
        }
        return sb.toString();
    }

    private static int translateByte(final String translationType, final int paramInt) {
        final int[] asciiArray  = { 32, 33,  34,  35, 36,  37, 38,  39, 40, 41, 42, 43,  44, 45, 46, 47,  48,  49,  50,  51,  52,  53,  54,  55,  56,  57,  58, 59, 60,  61,  62,  63,  64,  65,  66,  67,  68,  69,  70,  71,  72,  73,  74,  75,  76,  77,  78,  79,  80,  81,  82,  83,  84,  85,  86,  87,  88,  89,  90,  91,  92,  93, 94,  95,  96,  97,  98,  99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126 };
        final int[] ebcdicArray = { 64, 90, 127, 123, 91, 108, 80, 125, 77, 93, 92, 78, 107, 96, 75, 97, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 122, 94, 76, 126, 110, 111, 124, 193, 194, 195, 196, 197, 198, 199, 200, 201, 209, 210, 211, 212, 213, 214, 215, 216, 217, 226, 227, 228, 229, 230, 231, 232, 233, 173, 224, 189, 95, 109, 121, 129, 130, 131, 132, 133, 134, 135, 136, 137, 145, 146, 147, 148, 149, 150, 151, 152, 153, 162, 163, 164, 165, 166, 167, 168, 169, 192, 106, 208, 161 };
        for (int i = 0; i < asciiArray.length; i++) {
            if (translationType.equals("toEBC")) {
                if (paramInt == asciiArray[i]) return ebcdicArray[i];
            } else {
                if (paramInt == ebcdicArray[i]) return asciiArray[i];
            }
        }
        return paramInt;
    }

    private static int translateByteForDiscrepancy(final int paramInt) {
        int[] discrepancyArray = new int[126];
        for (int i = 0; i < discrepancyArray.length; i++) discrepancyArray[i] = i + 1;
        for (int x : discrepancyArray) if (paramInt == x) return x;
        return paramInt;
    }
}
