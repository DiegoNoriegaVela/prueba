import java.io.*;
import java.net.*;
import java.nio.charset.Charset;
import java.nio.file.*;
import java.time.*;
import java.time.format.DateTimeFormatter;
import java.util.*;
import java.util.logging.Logger;

public class McBatchSender {
    private static final Logger logger = Logger.getLogger(McBatchSender.class.getName());
    private static final Charset EBCDIC = Charset.forName("Cp037"); // IBM EBCDIC US/Canada (común en AS/400)

    // ============================== MAIN ==============================
    public static void main(String[] args) {
        try {
            if (args == null || args.length == 0) {
                Interactive.run();
                return;
            }
            // Modo CLI
            int option = Integer.parseInt(args[0].trim());

            if (option == 4) {
                // Envio manual: 4 <IP> <PUERTO> <FULL_NAME>
                if (args.length < 4) {
                    System.err.println("Uso: java McBatchSender 4 <IP> <PUERTO> <FULL_NAME>");
                    System.exit(2);
                }
                String ip = args[1].trim();
                int port = Integer.parseInt(args[2].trim());
                String fullName = args[3].trim();

                IniFile ini = IniFile.load(Paths.get("mcsender.ini"));
                General general = General.from(ini);
                Sender.runManualSend(general, ip, port, fullName);
                return;
            }

            if (args.length < 4) {
                System.err.println("Uso: java McBatchSender <OPCION> <SECCION> <FILE> <YYYYMMDD>");
                System.exit(2);
            }

            String section = args[1].trim();
            String fileParam = args[2].trim();
            String yyyymmdd = args[3].trim();

            if (!validateDate(yyyymmdd)) {
                System.err.println("Fecha invalida: " + yyyymmdd);
                System.exit(4);
            }

            IniFile ini = IniFile.load(Paths.get("mcsender.ini"));
            General general = General.from(ini);
            Business biz = Business.from(ini, section);

            final boolean isMIP = isMIPSection(section); // <-- selecciona reglas por sección

            if (option == 1) {
                Sender.runSend(general, biz, fileParam, yyyymmdd);
            } else if (option == 2) {
                Sender.runReport(general, biz, fileParam, yyyymmdd, isMIP); // <-- pasa el flag
            } else if (option == 3) {
                Sender.runDownload(general, biz, fileParam, yyyymmdd);
            } else {
                System.err.println("Opcion invalida.");
                System.exit(4);
            }
        } catch (NoSuchFileException e) {
            System.err.println("INI no encontrado: " + e.getFile());
            System.exit(3);
        } catch (Exception e) {
            System.err.println("Error: " + e.getMessage());
            System.exit(1);
        }
    }

    // ============================== CONFIG ==============================

    static class General {
        final int connectTimeoutMs;
        final int soTimeoutMs;
        final int chunkSize;
        final List<String> acceptedCode;
        final String alreadySentSubstring;
        final String defaultFailCode;

        General(int cto, int sto, int chunk, List<String> acc, String already, String fail) {
            this.connectTimeoutMs = cto;
            this.soTimeoutMs = sto;
            this.chunkSize = chunk;
            this.acceptedCode = acc;
            this.alreadySentSubstring = already;
            this.defaultFailCode = fail;
        }

        static General from(IniFile ini) {
            Map<String,String> g = ini.section("GENERAL");
            if (g == null) throw new IllegalArgumentException("Falta seccion [GENERAL]");

            int cto = parseIntStrict(g.getOrDefault("connectTimeoutMs","60000"), 1000, 300000, "connectTimeoutMs");
            int sto = parseIntStrict(g.getOrDefault("soTimeoutMs","60000"), 1000, 300000, "soTimeoutMs");
            int chunk = parseIntStrict(g.getOrDefault("chunkSize","980"), 2, 65535, "chunkSize");
            List<String> acc = parseList(g.getOrDefault("acceptedCode","9980100"));
            String already = g.getOrDefault("alreadySentSubstring","9288W");
            String fail = g.getOrDefault("defaultFailCode","9980101");
            return new General(cto, sto, chunk, acc, already, fail);
        }
    }

    static class Business {
        final String host; // resuelto desde [HOST_xxx]
        final int port;
        final String originalFile;
        final String historyFile;
        final String formatSendMC;
        final String formatRecieveMC;

        Business(String host, int port, String of, String hf, String fs, String fr) {
            this.host = host;
            this.port = port;
            this.originalFile = of;
            this.historyFile = hf;
            this.formatSendMC = fs;
            this.formatRecieveMC = fr;
        }

        static Business from(IniFile ini, String section) {
            Map<String,String> s = ini.section(section);
            if (s == null) throw new IllegalArgumentException("No existe la seccion ["+section+"]");

            // Host mapping
            String hostSec = s.getOrDefault("hostSection", "HOST_MC");
            Map<String,String> hs = ini.section(hostSec);
            if (hs == null) throw new IllegalArgumentException("No existe la seccion ["+hostSec+"]");
            String host = req(hs, "host");
            int port = parseIntStrict(req(hs, "port"), 1, 65535, "port");

            String of = req(s, "originalFile");
            String hf = req(s, "historyFile");
            String fs = req(s, "formatSendMC");
            String fr = req(s, "formatRecieveMC");

            return new Business(host, port, of, hf, fs, fr);
        }
    }

    // ============================== INI SIMPLE ==============================

    static class IniFile {
        private final Map<String, Map<String,String>> data = new LinkedHashMap<>();
        private IniFile() {}

        static IniFile load(Path path) throws IOException {
            if (!Files.exists(path)) throw new NoSuchFileException(path.toString());
            IniFile f = new IniFile();
            Map<String,String> cur = null;

            for (String raw : Files.readAllLines(path)) {
                String line = raw.trim();
                if (line.isEmpty() || line.startsWith("#") || line.startsWith(";")) continue;
                if (line.startsWith("[") && line.endsWith("]")) {
                    String name = line.substring(1, line.length()-1).trim();
                    cur = new LinkedHashMap<>();
                    f.data.put(name, cur);
                } else if (cur != null) {
                    int p = line.indexOf('=');
                    if (p > 0) {
                        String k = line.substring(0, p).trim();
                        String v = line.substring(p+1).trim();
                        cur.put(k, v);
                    }
                }
            }
            return f;
        }

        Map<String,String> section(String name) { return data.get(name); }
    }

    // ============================== SENDER ==============================

    static class Sender {

        // ------------------- Opcion 1: Envio -------------------
        static void runSend(General g, Business b, String fileParam, String yyyymmdd) {
            logger.info("=== OPCION 1: Envio ===");
            logger.info("Host: " + b.host + " Puerto: " + b.port);

            // Validar entorno
            File cwd = new File(System.getProperty("user.dir"));
            if (!cwd.exists() || !cwd.isDirectory()) {
                throw new IllegalStateException("CWD invalido");
            }
            if (!cwd.canRead() || !cwd.canExecute()) {
                throw new IllegalStateException("CWD sin permisos de lectura/ejecucion");
            }
            Path dataFile = Paths.get(b.originalFile);
            Path history = Paths.get(b.historyFile);

            byte[] payload = readAllBytesOrEmpty(dataFile);
            if (payload.length == 0) {
                logger.warning("Archivo de datos vacio: " + dataFile);
                createHistoryRecord(g.defaultFailCode, fileParam, yyyymmdd, history);
                logger.info("=== FIN OPCION 1 ===");
                return;
            }

            List<byte[]> parts = splitWithPrefixR(payload, g.chunkSize);
            String nameToSend = applyFormat(b.formatSendMC, fileParam, yyyymmdd);

            logger.info("Nombre a enviar  : " + nameToSend);
            logger.info("Partes a enviar  : " + parts.size());
            logger.info("ChunkSize (bytes): " + g.chunkSize);

            String finalStatus = g.defaultFailCode;
            try (Socket sock = new Socket()) {
                sock.connect(new InetSocketAddress(b.host, b.port), g.connectTimeoutMs);
                sock.setSoTimeout(g.soTimeoutMs);

                // 1) Enviar el nombre
                writeFrameName(sock, nameToSend);

                // 2) Enviar cada parte con prefijo 'R'
                int count = 0;
                for (byte[] p : parts) {
                    writeFrameData(sock, p);
                    count++;
                }

                // 3) Trailer (accepted + count)
                writeTrailer(sock, count);

                // 4) Leer respuesta (completa)
                String resp = readResponse(sock);
                logger.info("Resp (envio): " + preview80(resp));

                if (resp != null && resp.contains(g.alreadySentSubstring)) {
                    logger.warning("*** Advertencia: el servidor indico que ya estaba enviado (" + g.alreadySentSubstring + ")");
                    finalStatus = g.defaultFailCode;
                } else if (hasAccepted(resp, g.acceptedCode)) {
                    finalStatus = firstAcceptedOrDefault(g);
                    logger.info("Envio OK (" + finalStatus + ")");
                } else {
                    logger.severe("*** Envio FALLIDO (sin acceptedCode)");
                    finalStatus = g.defaultFailCode;
                }
            } catch (Exception ex) {
                logger.severe("Error envio: " + ex.getMessage());
            } finally {
                createHistoryRecord(finalStatus, fileParam, yyyymmdd, history);
                logger.info("=== FIN OPCION 1 ===");
            }
        }

        // ------------------- Opcion 2: Descarga y genera reporte -------------------
        static void runReport(General g, Business b, String fileParam, String yyyymmdd, boolean isMIP) {
            logger.info("=== OPCION 2: Descarga y genera reporte ===");
            logger.info("Host: " + b.host + " Puerto: " + b.port);

            String base = applyFormat(b.formatRecieveMC, fileParam, yyyymmdd);
            logger.info("Nombre base: " + base);

            boolean found = false;
            StringBuilder rawAcc = new StringBuilder();

            try (Socket sock = new Socket()) {
                sock.connect(new InetSocketAddress(b.host, b.port), g.connectTimeoutMs);
                sock.setSoTimeout(g.soTimeoutMs);

                for (int i = 1; i <= 99; i++) {
                    String sec = String.format("%02d", i);
                    String query = base + sec;

                    logger.info("Consultando: " + query);
                    writeFrameName(sock, query);

                    // lectura one-shot legacy y acumulación EXACTA como el original
                    String chunk = readLegacyOneShot(sock);
                    rawAcc.setLength(0);
                    rawAcc.append("[").append(chunk).append("]\n");

                    if (hasAccepted(rawAcc.toString(), g.acceptedCode)) {
                        found = true;
                        break;
                    } else {
                        logger.info("Buscando...");
                    }
                }

                if (!found) {
                    logger.severe("*** Archivo no encontrado [FAIL]");
                    String rr = rawAcc.toString(); // mantiene el formato con []
                    logger.info("[Preview 80B] " + preview80(rr));
                    writeErrorDump(fileParam, yyyymmdd, rr);
                    logger.info("=== FIN OPCION 2 ===");
                    return;
                }

                // Éxito: ordenar usando reglas GCO o MIP
                String dataToWrite;
                String allOk = firstAcceptedOrDefault(g);
                try {
                    dataToWrite = isMIP
                            ? orderDetailsMIP(rawAcc.toString(), allOk)  // reglas MIP (H/D0)
                            : orderDetails(rawAcc.toString(), allOk);    // reglas GCO (12/16)
                } catch (Exception ex) {
                    logger.severe("Error al ordenar; se guarda crudo");
                    dataToWrite = rawAcc.toString();
                }

                // escribir reporte con nombre original
                writeReportFile(yyyymmdd, dataToWrite, fileParam);
                logger.info("Reporte OK");

            } catch (Exception ex) {
                logger.severe("Error reporte: " + ex.getMessage());
            } finally {
                logger.info("=== FIN OPCION 2 ===");
            }
        }

        // ------------------- Opcion 3: Descarga (cruda, con busqueda secuencial + lectura completa) -------------------
        static void runDownload(General g, Business b, String fileParam, String yyyymmdd) {
            logger.info("=== OPCION 3: Descarga ===");
            logger.info("Host: " + b.host + " Puerto: " + b.port);

            String base = applyFormat(b.formatRecieveMC, fileParam, yyyymmdd);
            logger.info("Nombre base: " + base);

            boolean found = false;
            String foundRaw = null;
            String lastRaw = null;

            try (Socket sock = new Socket()) {
                sock.connect(new InetSocketAddress(b.host, b.port), g.connectTimeoutMs);
                sock.setSoTimeout(g.soTimeoutMs);

                for (int i = 1; i <= 99; i++) {
                    String sec = String.format("%02d", i);
                    String query = base + sec;

                    logger.info("Consultando: " + query);
                    writeFrameName(sock, query);

                    // leer todo el bloque (no solo 80B)
                    String raw = readResponse(sock);
                    lastRaw = raw;

                    if (hasAccepted(raw, g.acceptedCode)) {
                        found = true;
                        foundRaw = raw;
                        break;
                    } else {
                        logger.info("Buscando...");
                    }
                }

                if (!found) {
                    logger.severe("*** Archivo no encontrado [FAIL]");
                    String rr = (lastRaw == null ? "" : lastRaw);
                    logger.info("[Preview 80B] " + preview80(rr));
                    writeErrorDump(fileParam, yyyymmdd, rr);
                    logger.info("=== FIN OPCION 3 ===");
                    return;
                }

                // exito: escribir tal cual lo recibido
                writeRawDownloadFile(yyyymmdd, foundRaw, fileParam);
                logger.info("Descarga OK");
                logger.info("[Preview 80B] " + preview80(foundRaw));

            } catch (Exception ex) {
                logger.severe("Error descarga: " + ex.getMessage());
            } finally {
                logger.info("=== FIN OPCION 3 ===");
            }
        }

        // ------------------- Opcion 4: Envio manual -------------------
        static void runManualSend(General g, String ip, int port, String fullName) {
            logger.info("=== OPCION 4: Envio manual ===");
            logger.info("Host: " + ip + " Puerto: " + port);
            logger.info("Nombre a enviar: " + fullName);

            try (Socket sock = new Socket()) {
                sock.connect(new InetSocketAddress(ip, port), g.connectTimeoutMs);
                sock.setSoTimeout(g.soTimeoutMs);

                writeFrameName(sock, fullName);

                // leer bloque de respuesta completo
                String raw = readResponse(sock);

                // Escribir exactamente en el archivo indicado por 'fullName'
                try (PrintStream ps = new PrintStream(new FileOutputStream(fullName), true, "UTF-8")) {
                    ps.print(raw == null ? "" : raw);
                }

                // Log compacto de la respuesta
                logger.info("Resp: [" + (raw == null ? "" : raw.trim()) + "]");
            } catch (Exception ex) {
                logger.severe("Error envio manual: " + ex.getMessage());
            } finally {
                logger.info("=== FIN OPCION 4 ===");
            }
        }

        // ==================== I/O de red y framing ====================

        private static void writeFrameName(Socket s, String name) throws IOException {
            // nombre en EBCDIC con header 2B
            byte[] body = toEbcdic(name.getBytes("UTF-8"));
            writeRawFrame(s, body);
        }

        private static void writeFrameData(Socket s, byte[] asciiChunkWithR) throws IOException {
            // asciiChunkWithR ya contiene 'R' al inicio; convertir a EBCDIC y enviar
            byte[] body = toEbcdic(asciiChunkWithR);
            writeRawFrame(s, body);
        }

        private static void writeTrailer(Socket s, int count) throws IOException {
            // 11B = "9980100"(7) + contador BE(4), con posible traduccion adicional por discrepancia
            String ok = "9980100";
            byte[] pre = toEbcdic(ok.getBytes("UTF-8"));
            byte[] cntBE = intToBytesBE(count, 4);
            for (int i = 0; i < cntBE.length; i++) {
                cntBE[i] = (byte) translateByteForDiscrepancy(cntBE[i] & 0xFF);
            }
            byte[] cnt = toEbcdic(cntBE); // pasar por mapeo tambien
            byte[] body = new byte[11];
            System.arraycopy(pre, 0, body, 0, 7);
            System.arraycopy(cnt, 0, body, 7, 4);
            writeRawFrame(s, body);
        }

        private static void writeRawFrame(Socket s, byte[] body) throws IOException {
            int len = body.length;
            byte[] header = intToBytesBE(len, 2);
            OutputStream os = s.getOutputStream();
            os.write(header);
            os.write(body);
            os.flush();
        }

        private static String readResponse(Socket s) throws IOException {
            ByteArrayOutputStream baos = new ByteArrayOutputStream();
            InputStream is = s.getInputStream();
            byte[] buf = new byte[4096];
            int n;
            while (true) {
                try {
                    n = is.read(buf);
                    if (n == -1) break;
                    baos.write(buf, 0, n);
                    if (n < buf.length) break; // leyó menos que el buffer -> no hay mas disponible inmediato
                } catch (SocketTimeoutException te) {
                    if (baos.size() == 0) throw te;
                    break;
                }
            }
            byte[] ebcdicBytes = baos.toByteArray();
            if (ebcdicBytes.length == 0) return "";
            return fromEbcdic(ebcdicBytes);
        }

        private static String readLegacyOneShot(Socket s) throws IOException {
            InputStream is = s.getInputStream();
            byte[] buf = new byte[1024];
            int n = is.read(buf, 0, 1024);
            if (n <= 0) return "";
            String decoded = fromEbcdic(Arrays.copyOf(buf, n));
            // Sanitizar a ASCII visible + saltos de linea
            StringBuilder out = new StringBuilder(decoded.length());
            for (int i = 0; i < decoded.length(); i++) {
                char c = decoded.charAt(i);
                if (c >= ' ' && c <= '~') out.append(c);
                else if (c == '\n') out.append('\n');
            }
            return out.toString();
        }

        // ==================== Archivos locales ====================

        private static byte[] readAllBytesOrEmpty(Path p) {
            try { return Files.readAllBytes(p); }
            catch (Exception e) { return new byte[0]; }
        }

        private static List<byte[]> splitWithPrefixR(byte[] payload, int chunkSize) {
            List<byte[]> out = new ArrayList<>();
            int maxDataPerChunk = Math.max(1, chunkSize - 1); // 1 para 'R'
            int pos = 0;
            while (pos < payload.length) {
                int len = Math.min(maxDataPerChunk, payload.length - pos);
                byte[] part = new byte[len + 1];
                part[0] = 'R'; // prefijo ASCII
                System.arraycopy(payload, pos, part, 1, len);
                out.add(part);
                pos += len;
            }
            return out;
        }

        private static void writeReportFile(String yyyymmdd, String content, String fileName9) throws IOException {
            String name = reportFileName(yyyymmdd, fileName9);
            try (PrintStream ps = new PrintStream(new FileOutputStream(name), true, "UTF-8")) {
                ps.print(content == null ? "" : content);
            }
            logger.info("Reporte escrito: " + name);
        }

        private static void writeRawDownloadFile(String yyyymmdd, String data, String fileParam) throws IOException {
            String out = (fileParam == null || fileParam.isEmpty()) ? "DESCARGA" : fileParam;
            String name = out + "-" + yyyymmdd + ".out";
            try (PrintStream ps = new PrintStream(new FileOutputStream(name), true, "UTF-8")) {
                ps.print(data == null ? "" : data);
            }
            logger.info("Archivo escrito: " + name);
        }

        private static void createHistoryRecord(String respCode, String fileName, String yyyymmdd, Path historyPath) {
            try {
                String record = "[" + respCode + "-" + fileName + "-" + yyyymmdd + ": " +
                        LocalDateTime.now().format(DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss")) + "]";
                prependLine(historyPath, record);
            } catch (Exception e) {
                logger.severe("No se pudo actualizar el historico: " + e.getMessage());
            }
        }

        private static void prependLine(Path path, String line) throws IOException {
            List<String> lines = new ArrayList<>();
            if (Files.exists(path)) {
                try { lines = Files.readAllLines(path); } catch (Exception ignore) {}
            }
            lines.add(0, line);
            Files.write(path, String.join(System.lineSeparator(), lines).getBytes(),
                    StandardOpenOption.CREATE, StandardOpenOption.TRUNCATE_EXISTING, StandardOpenOption.WRITE);
        }

        private static String reportFileName(String yyyymmdd, String fileName9) {
            String prefix = (fileName9 == null || fileName9.length() < 4) ? "FILE" : fileName9.substring(0, 4);
            return prefix + "-" + yyyymmdd + "-Archivo de Cambio Confirmacion";
        }
    }

    // ============================== HELPERS GLOBALES ==============================

    // detecta si la sección indica MIP (exactamente "MIP")
    private static boolean isMIPSection(String sectionName) {
        return sectionName != null && sectionName.trim().equalsIgnoreCase("MIP");
    }

    // acceptedCode check
    private static boolean hasAccepted(String text, List<String> acceptedCodes) {
        if (text == null || acceptedCodes == null || acceptedCodes.isEmpty()) return false;
        for (String c : acceptedCodes) {
            if (c != null && !c.isEmpty() && text.contains(c)) return true;
        }
        return false;
    }

    // -- Devuélveme el primer acceptedCode no vacío; si no hay, usa el defaultFailCode
    private static String firstAcceptedOrDefault(McBatchSender.General g) {
        if (g != null && g.acceptedCode != null) {
            for (String c : g.acceptedCode) {
                if (c != null && !c.trim().isEmpty()) {
                    return c.trim();
                }
            }
        }
        return (g != null && g.defaultFailCode != null && !g.defaultFailCode.isEmpty())
                ? g.defaultFailCode
                : "9980101"; // fallback defensivo
    }

    // preview 80B
    private static String preview80(String s) {
        if (s == null) return "";
        String p = s.replace("\r", " ").replace("\n", " ");
        return p.length() > 80 ? p.substring(0, 80) : p;
    }

    // dump de error
    private static void writeErrorDump(String fileParam, String yyyymmdd, String content) {
        String safe = (fileParam == null || fileParam.isEmpty()) ? "NONAME" : fileParam;
        String outName = "ERROR_" + safe;
        try (PrintStream ps = new PrintStream(new FileOutputStream(outName), true, "UTF-8")) {
            ps.print(content == null ? "" : content);
        } catch (Exception e) {
            logger.severe("No se pudo escribir " + outName + ": " + e.getMessage());
        }
    }

    // aplica formato {FILE}, {julianDate}, {yyyymmdd}, {yy},{mm},{dd}
    private static String applyFormat(String template, String file, String yyyymmdd) {
        if (template == null) template = "";
        if (file == null) file = "";
        LocalDate d = LocalDate.parse(yyyymmdd, DateTimeFormatter.BASIC_ISO_DATE);
        String jul = String.format("%03d", d.getDayOfYear());
        String yy = String.format("%02d", d.getYear() % 100);
        String mm = String.format("%02d", d.getMonthValue());
        String dd = String.format("%02d", d.getDayOfMonth());
        return template
                .replace("{FILE}", file)
                .replace("{julianDate}", jul)
                .replace("{yyyymmdd}", yyyymmdd)
                .replace("{yy}", yy)
                .replace("{mm}", mm)
                .replace("{dd}", dd);
    }

    // Conversion EBCDIC/ASCII usando Charset
    private static byte[] toEbcdic(byte[] ascii) {
        if (ascii == null || ascii.length == 0) return new byte[0];
        String asStr = new String(ascii, Charset.forName("UTF-8"));
        return asStr.getBytes(EBCDIC);
    }
    private static String fromEbcdic(byte[] ebcdic) {
        if (ebcdic == null || ebcdic.length == 0) return "";
        return new String(ebcdic, EBCDIC);
    }

    // Discrepancia de bytes (identidad por defecto; ajusta si necesitas)
    private static int translateByteForDiscrepancy(final int paramInt) {
        return paramInt; // mantener identidad salvo reglas especiales
    }

    // parse helpers y utilidades basicas
    private static boolean validateDate(String date) {
        try { LocalDate.parse(date, DateTimeFormatter.BASIC_ISO_DATE); return true; }
        catch (Exception e) { return false; }
    }
    private static List<String> parseList(String csv) {
        if (csv == null) return Collections.emptyList();
        List<String> out = new ArrayList<>();
        for (String p : csv.split(",")) {
            String t = p.trim();
            if (!t.isEmpty()) out.add(t);
        }
        return out;
    }
    private static String req(Map<String,String> m, String key) {
        String v = (m == null) ? null : m.get(key);
        if (v == null || v.trim().isEmpty())
            throw new IllegalArgumentException("Falta clave obligatoria: " + key);
        return v.trim();
    }
    private static int parseIntStrict(String s, int min, int max, String k) {
        int v = Integer.parseInt(s.trim());
        if (v < min || v > max) throw new IllegalArgumentException("Parametro fuera de rango: " + k + " ("+v+")");
        return v;
    }
    private static byte[] intToBytesBE(int value, int size) {
        if (size <= 0 || size > 8) throw new IllegalArgumentException("size invalido");
        byte[] out = new byte[size];
        for (int i = 0; i < size; i++) {
            int shift = (size - 1 - i) * 8;
            out[i] = (byte)((value >> shift) & 0xFF);
        }
        return out;
    }

    // ====================== REGLAS GCO (las que ya tenías) ======================

    // Compone el reporte como antes: encabezado + detalle ordenado (GCO)
    private static String orderDetails(String dataMipDato, String allOkCode) {
        String headers = extractHeaders(dataMipDato);
        String details = extractDetails(dataMipDato, allOkCode);
        return headers + details;
    }

    // Encabezado EXACTO: "[<nombre>]\n" + bloque entre "12" y el primer "16"
    private static String extractHeaders(String data) {
        // toma los primeros 20 caracteres (ya vienen con "[" al inicio por runReport)
        String header = data.replace(">", "").substring(0, 20) + "]\n";
        int firstIndexDetail = data.indexOf("16");
        String headerInfo;
        if (firstIndexDetail != -1) {
            headerInfo = data.substring(data.indexOf("12"), firstIndexDetail);
        } else {
            headerInfo = data.substring(data.indexOf("12"), data.indexOf("]", data.indexOf("12")));
        }
        return header + headerInfo;
    }

    // Detalle EXACTO (GCO): parte desde el primer "16", splitea por "D0", arma líneas "16..." y corta en allOkCode
    private static String extractDetails(String data, String allOkCode) {
        int firstIndexDetail = data.indexOf("16");
        StringBuilder detail = new StringBuilder();
        if (firstIndexDetail != -1) {
            String[] detailsData = data.substring(firstIndexDetail)
                                    .replace("[", "")
                                    .replace("]\n", "")
                                    .split("D0");
            for (int i = 1; i < detailsData.length; i++) {
                detail.append("16");
                if (detailsData[i].substring(57).length() < 26) {
                    String codErrors = String.format("%26s", detailsData[i].substring(57).trim().substring(0, 15));
                    detail.append(detailsData[i].substring(0, 57)).append(codErrors);
                    continue;
                }
                if (i == detailsData.length - 1) {
                    if (detailsData[i].substring(57).length() < 26) {
                        String codErrors = String.format("%26s", detailsData[i].substring(57).trim().substring(0, 15));
                        detail.append(detailsData[i].substring(0, 57)).append(codErrors).append(allOkCode);
                    } else {
                        int codresp = detailsData[i].indexOf(allOkCode);
                        if (codresp != -1) {
                            detail.append(detailsData[i].substring(0, codresp + allOkCode.length()));
                        }
                    }
                    break;
                }
                detail.append(detailsData[i].substring(0, 83));
            }
            return detail.toString().replace("D0", "\nD0");
        }
        return detail.toString();
    }

    // ====================== REGLAS MIP (según tus screenshots) ======================

    private static String orderDetailsMIP(String data, String allOkCode) {
        String headers = extractHeadersMIP(data);
        String details = extractDetailsMIP(data, allOkCode);
        return headers + details;
    }

    // Header MIP: primera línea "[...]\n" + bloque desde 'H' hasta antes del primer 'D' (o hasta ']')
    private static String extractHeadersMIP(String data) {
        String header = data.replace(">", "").substring(0, 20) + "]\n";
        int firstIndexDetail = data.indexOf("D");      // en MIP los detalles empiezan en 'D...'
        int idxH = data.indexOf("H");
        if (idxH == -1) idxH = 0;                      // defensivo
        String headerInfo;
        if (firstIndexDetail != -1 && firstIndexDetail > idxH) {
            headerInfo = data.substring(idxH, firstIndexDetail);
        } else {
            headerInfo = data.substring(idxH, data.indexOf("]", idxH));
        }
        return header + headerInfo;
    }

    // Detalles MIP: bloques "D0...", padding de 26 si tail<26, y corte en allOkCode al final
    private static String extractDetailsMIP(String data, String allOkCode) {
        int firstIndexDetail = data.indexOf("D"); // MIP
        StringBuilder detail = new StringBuilder();
        if (firstIndexDetail != -1) {
            String[] detailsData = data.substring(firstIndexDetail)
                                       .replace("[", "")
                                       .replace("]\n", "")
                                       .split("D0");
            for (int i = 1; i < detailsData.length; i++) {
                detail.append("D0");
                String cur = detailsData[i];
                String tail = (cur.length() > 57) ? cur.substring(57) : "";

                if (tail.length() < 26) {
                    String codErrors = String.format("%26s", tail.trim().substring(0, Math.min(15, tail.trim().length())));
                    detail.append(cur.substring(0, Math.min(57, cur.length()))).append(codErrors);
                    if (i == detailsData.length - 1) detail.append(allOkCode);
                    continue;
                }

                if (i == detailsData.length - 1) {
                    int codresp = cur.indexOf(allOkCode);
                    if (codresp != -1) {
                        detail.append(cur.substring(0, Math.min(codresp + allOkCode.length(), cur.length())));
                        break;
                    }
                }

                detail.append(cur.substring(0, Math.min(83, cur.length())));
            }
            return detail.toString().replace("D0", "\nD0");
        }
        return detail.toString();
    }

    // ============================== INTERACTIVO ==============================
    static class Interactive {
        static void run() throws Exception {
            IniFile ini = IniFile.load(Paths.get("mcsender.ini"));
            General general = General.from(ini);
            Scanner sc = new Scanner(System.in);

            System.out.println("1) Envio");
            System.out.println("2) Descarga y genera reporte");
            System.out.println("3) Descarga");
            System.out.println("4) Envio manual");
            System.out.print("Opcion: ");
            int op = Integer.parseInt(sc.nextLine().trim());

            if (op == 4) {
                System.out.print("IP: ");
                String ip = sc.nextLine().trim();
                System.out.print("Puerto: ");
                int port = Integer.parseInt(sc.nextLine().trim());
                System.out.print("Nombre completo a enviar: ");
                String full = sc.nextLine().trim();
                Sender.runManualSend(general, ip, port, full);
                return;
            }

            System.out.print("Seccion INI: ");
            String sec = sc.nextLine().trim();
            System.out.print("FILE param : ");
            String fileParam = sc.nextLine().trim();
            System.out.print("Fecha (YYYYMMDD): ");
            String date = sc.nextLine().trim();

            IniFile ini2 = IniFile.load(Paths.get("mcsender.ini"));
            Business biz = Business.from(ini2, sec);

            if (!validateDate(date)) {
                System.err.println("Fecha invalida");
                return;
            }

            // Mostrar nombre exacto a consultar/enviar
            String preview = (op == 1)
                    ? applyFormat(biz.formatSendMC, fileParam, date)
                    : applyFormat(biz.formatRecieveMC, fileParam, date);
            System.out.println("Nombre exacto: " + preview);

            boolean isMIP = isMIPSection(sec); // <-- reglas por sección en modo interactivo

            if (op == 1) Sender.runSend(general, biz, fileParam, date);
            else if (op == 2) Sender.runReport(general, biz, fileParam, date, isMIP);
            else if (op == 3) Sender.runDownload(general, biz, fileParam, date);
            else System.err.println("Opcion invalida");
        }
    }
}
