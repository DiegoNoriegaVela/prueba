//=================================================================================================
// McBatchSender
//
// Proposito:
//   Envia un archivo de datos a un hub (ej. Mastercard) por TCP (Opcion 1) y genera reporte
//   de confirmacion (Opcion 2), manteniendo el comportamiento del original.
//
// Protocolo:
//   - Cada trama: header de 2 bytes (longitud big-endian) + cuerpo en EBCDIC.
//   - Opcion 1 (envio): cada parte se envia con prefijo ASCII 'R' antes del cuerpo y luego
//     se convierte a EBCDIC. Trailer final: 11 bytes = EBCDIC(acceptedCode de 7 chars) + contador(4B).
//
// Flujo (resumen):
//   Opcion 1 (Envio):
//     1) Valida permisos (CWD, dataFile, historico).
//     2) Lee dataFilePath, parte en chunkSize, determina FILE_NAME (CLI o fileNameTemplate).
//     3) Arma nombre con nameTemplate y hace handshake (acceptedCode / alreadySentSubstring).
//     4) Envia tramas y trailer 11B, espera confirmacion final (acceptedCode), actualiza historico.
//   Opcion 2 (Reporte):
//     1) Valida permisos (CWD con escritura).
//     2) Determina FILE_NAME (CLI o fileNameTemplate).
//     3) Arma nombre base desde reportNameTemplate y consulta secuencias 01..99.
//     4) Si report.process=Y: procesa headers+details; si N: escribe el contenido crudo.
//     5) Genera archivo NNNN-YYYYMMDD-Archivo de Cambio Confirmacion en el CWD.
//
// Parametrizacion (INI):
//   - host, port, connectTimeoutMs, soTimeoutMs, chunkSize
//   - dataFilePath, historyFilePath
//   - acceptedCode (lista separada por comas; uno de 7 chars se usa en trailer)
//   - alreadySentSubstring, defaultFailCode
//   - codePage (Cp037/Cp500/Cp1047), date (YYYYMMDD opcional)
//   - nameTemplate (p.ej. "00401{file}{julian}")
//   - fileNameTemplate (si no pasas FILE_NAME): literal, {rand}, {ddmm} -> 9 chars exactos
//   - reportNameTemplate (p.ej. "10101{file}{julian}") para Opcion 2
//   - report.process=Y|N (Y=procesa headers+details; N=escribe crudo)
//
// Nota: si pasas DATE por CLI, se usa ese valor y la clave `date` del INI se ignora.
// Uso:
//   javac McBatchSender.java
//   java McBatchSender <OPCION> <seccion> [FILE_NAME] [DATE]
//   - <OPCION>    : 1=Envio, 2=Reporte
//   - <seccion>   : nombre de la seccion del INI (ej. MIP, GCO)
//   - [DATE]      : opcional; AAAAMMDD. Si se omite, se usa la fecha del dia.
//   - [FILE_NAME] : opcional; prioridad sobre fileNameTemplate; debe tener 9 chars
//
// Codigos de salida:
//   0=OK | 1=error inesperado | 2=uso invalido | 3=INI no encontrado | 4=INI/argumento invalido
//=================================================================================================

import java.io.*;
import java.net.*;
import java.nio.charset.Charset;
import java.nio.charset.MalformedInputException;
import java.nio.charset.StandardCharsets;
import java.nio.file.*;
import java.nio.channels.FileChannel;
import java.time.*;
import java.time.format.DateTimeFormatter;
import java.util.*;
import java.util.logging.Logger;

public class McBatchSender {
    private static final Logger logger = Logger.getLogger(McBatchSender.class.getName());

    /**
     * Punto de entrada.
     *
     * Lee la opcion (1 envio / 2 reporte), la seccion INI y la configuracion.
     * Toma FILE_NAME desde CLI si se provee; si no, lo genera desde fileNameTemplate del INI.
     * Ejecuta el flujo segun la opcion indicada.
     *
     * @param args args[0]=OPCION(1|2), args[1]=seccion INI, args[2]=DATE o FILE_NAME (opcional),
     *             args[3]=FILE_NAME si args[2] fue DATE.
     *             Propiedad del sistema: -Dmcsender.config=/ruta/mcsender.ini
     */
    public static void main(String[] args) {
        if (args.length < 2) {
            System.err.println("Uso: java McBatchSender <OPCION> <seccion> [DATE] [FILE_NAME]  [-Dmcsender.config=/ruta/mcsender.ini]");
            System.exit(2);
        }

        final String optionStr = args[0].trim();
        final int option;
        try {
            option = Integer.parseInt(optionStr);
        } catch (NumberFormatException nfe) {
            System.err.println("OPCION debe ser 1 (envio) o 2 (reporte). Valor: '" + optionStr + "'");
            System.exit(4); return;
        }
        if (option != 1 && option != 2) {
            System.err.println("OPCION invalida. Use 1 (envio) o 2 (reporte).");
            System.exit(4);
        }

        final String section = args[1].trim();

        // --- PARSEO CLI ---
        // Formatos soportados (prioridad al nuevo orden):
        //   1) <OPCION> <seccion> <FILE_NAME> <DATE>
        //   2) <OPCION> <seccion> <FILE_NAME>
        //   3) <OPCION> <seccion> <DATE>
        //   4) <OPCION> <seccion> <DATE> <FILE_NAME>
        String cliDateParam = null;
        String fileNameArg = null;

        if (args.length >= 3) {
            String third  = args[2].trim();
            String fourth = (args.length >= 4 ? args[3].trim() : null);

            // Preferimos el nuevo orden: tercero = FILE_NAME(9), cuarto = DATE(8)
            if (third.length() == 9 && !looksLikeDate(third)) {
                // 9 chars (pueden ser o no dígitos) -> FILE_NAME
                fileNameArg = third.toUpperCase();
                if (fourth != null && looksLikeDate(fourth)) cliDateParam = fourth;
            } else if (third.length() == 9) {
                // También aceptar 9 dígitos como FILE_NAME
                fileNameArg = third.toUpperCase();
                if (fourth != null && looksLikeDate(fourth)) cliDateParam = fourth;
            } else if (looksLikeDate(third)) {
                // Retrocompatibilidad: tercero = DATE
                cliDateParam = third;
                if (forthcomingNonNull(fourth) && fourth.length() == 9) fileNameArg = fourth.toUpperCase();
            } else {
                // Si no es ni DATE ni 9 chars, lo asumimos como FILE_NAME y validamos abajo
                fileNameArg = third.toUpperCase();
                if (fourth != null && looksLikeDate(fourth)) cliDateParam = fourth;
            }
        }
        // ----------------------------------------------------------------


        final String iniPath = System.getProperty("mcsender.config", "mcsender.ini");
        final Path ini = Paths.get(iniPath);

        if (fileNameArg != null && fileNameArg.length() != 9) {
            System.err.println("FILE_NAME debe tener exactamente 9 caracteres. Valor: '" + fileNameArg + "'");
            System.exit(4);
        }

        try {
            IniFile cfgFile = IniFile.load(ini);
            Config cfg = Config.from(cfgFile, section);

            logger.info("OPCION: " + option);
            logger.info("Host: " + cfg.host + " (" + cfg.host.length() + ")");
            logger.info("Puerto: " + cfg.port + " (" + String.valueOf(cfg.port).length() + ")");
            logger.info("nameTemplate: " + cfg.nameTemplate);
            logger.info("acceptedCodes: " + cfg.acceptedCodes);
            logger.info("trailerCode (7 chars): " + cfg.trailerCodeSeven());
            logger.info("reportNameTemplate: " + cfg.reportNameTemplate + " | report.process=" + (cfg.reportProcess ? "Y" : "N"));
            if (cliDateParam != null) {
                logger.info("DATE (CLI): " + cliDateParam);
            } else {
                logger.info("DATE (CLI): <no provisto> -> se usara fecha del dia");
            }
            if (fileNameArg != null) {
                logger.info("FILE_NAME (CLI): " + fileNameArg + " (" + fileNameArg.length() + ")");
            } else {
                logger.info("FILE_NAME (CLI): <no provisto> -> fileNameTemplate=" + cfg.fileNameTemplate);
            }

            new Sender(cfg, option, fileNameArg, cliDateParam).run();
            System.exit(0);
        } catch (NoSuchFileException e) {
            System.err.println("No se encontro el archivo de configuracion: " + e.getFile());
            System.exit(3);
        } catch (IllegalArgumentException e) {
            System.err.println("Configuracion/argumento invalido: " + e.getMessage());
            System.exit(4);
        } catch (Exception e) {
            System.err.println("Error inesperado: " + e.getMessage());
            System.exit(1);
        }
    }

    // NUEVO: helper para detectar YYYYMMDD simple (8 digitos)
    private static boolean looksLikeDate(String s) { return s != null && s.matches("\\d{8}"); }
    private static boolean forthcomingNonNull(String s) { return s != null && !s.isEmpty(); }

    // -------------------------------- Config --------------------------------

    /**
     * Configuracion efectiva del proceso.
     *
     * Campos:
     * - Red: host, port, connectTimeoutMs, soTimeoutMs
     * - Particionado: chunkSize
     * - Archivos: dataFilePath, historyFilePath
     * - Control: acceptedCodes, alreadySentSubstring, defaultFailCode
     * - Codificacion: codePage (EBCDIC), dateOverride
     * - Plantillas: nameTemplate, fileNameTemplate, reportNameTemplate
     * - Reporte: reportProcess (Y/N)
     */
    static class Config {
        final String host;
        final int port;
        final int connectTimeoutMs;
        final int soTimeoutMs;
        final int chunkSize;
        final Path dataFilePath;
        final Path historyFilePath;
        final List<String> acceptedCodes;
        final String alreadySentSubstring;
        final String defaultFailCode;
        final Charset codePage;
        final String dateOverride;
        final String nameTemplate;
        final String fileNameTemplate;
        final String reportNameTemplate;
        final boolean reportProcess;

        private Config(String host, int port, int connectTimeoutMs, int soTimeoutMs, int chunkSize,
                       Path dataFilePath, Path historyFilePath, List<String> acceptedCodes,
                       String alreadySentSubstring, String defaultFailCode,
                       Charset codePage, String dateOverride,
                       String nameTemplate, String fileNameTemplate,
                       String reportNameTemplate, boolean reportProcess) {
            this.host = host;
            this.port = port;
            this.connectTimeoutMs = connectTimeoutMs;
            this.soTimeoutMs = soTimeoutMs;
            this.chunkSize = chunkSize;
            this.dataFilePath = dataFilePath;
            this.historyFilePath = historyFilePath;
            this.acceptedCodes = acceptedCodes;
            this.alreadySentSubstring = alreadySentSubstring;
            this.defaultFailCode = defaultFailCode;
            this.codePage = codePage;
            this.dateOverride = dateOverride;
            this.nameTemplate = nameTemplate;
            this.fileNameTemplate = fileNameTemplate;
            this.reportNameTemplate = reportNameTemplate;
            this.reportProcess = reportProcess;
        }

        /**
         * Carga y valida la seccion del INI.
         *
         * Reglas:
         * - Rutas relativas se resuelven contra user.dir.
         * - acceptedCode acepta lista separada por comas.
         * - Debe existir un acceptedCode de 7 chars para el trailer.
         *
         * @param ini     INI cargado
         * @param section Nombre de la seccion
         * @return Config validada
         */
        static Config from(IniFile ini, String section) {
            Map<String,String> s = ini.section(section);
            if (s == null) throw new IllegalArgumentException("No existe la seccion ["+section+"].");

            String host = req(s, "host");
            int port = parseInt(s.get("port"), 1, 65535, "port");

            int connectTimeout = parseInt(s.getOrDefault("connectTimeoutMs","60000"), 1000, 300000, "connectTimeoutMs");
            int soTimeout = parseInt(s.getOrDefault("soTimeoutMs","60000"), 1000, 300000, "soTimeoutMs");
            int chunk = parseInt(s.getOrDefault("chunkSize","980"), 1, 65535, "chunkSize");

            String dataFileStr = s.getOrDefault("dataFilePath", "MIPFILE_DATI");
            String historyFileStr = s.getOrDefault("historyFilePath", "MIPFILE_HISTORY_R");

            List<String> acceptedList = parseList(s.getOrDefault("acceptedCode","9980100"));

            String already = s.getOrDefault("alreadySentSubstring","9288W");
            String failDef = s.getOrDefault("defaultFailCode","9980101");

            String codePageName = s.getOrDefault("codePage","Cp037");
            Charset cp;
            try { cp = Charset.forName(codePageName); }
            catch (Exception ex) { throw new IllegalArgumentException("codePage invalido: "+codePageName); }

            String dateOverride = s.get("date");

            String nameTemplate = s.getOrDefault("nameTemplate", "00401{file}{julian}");
            String fileNameTemplate = s.get("fileNameTemplate");

            String reportNameTemplate = s.getOrDefault("reportNameTemplate", "10101{file}{julian}");
            String reportProcessStr   = s.getOrDefault("report.process", "Y");
            boolean reportProcess     = reportProcessStr.trim().equalsIgnoreCase("Y");

            Path dataPath = resolveAgainstCwd(dataFileStr);
            Path histPath = resolveAgainstCwd(historyFileStr);

            String trailer = pickTrailerCodeSeven(acceptedList);
            if (trailer == null) {
                throw new IllegalArgumentException("acceptedCode debe incluir al menos un valor de 7 caracteres para el trailer.");
            }

            logger.info("CWD (user.dir): " + Paths.get(System.getProperty("user.dir")).toAbsolutePath());
            logger.info("dataFilePath   : " + dataPath.toAbsolutePath());
            logger.info("historyFilePath: " + histPath.toAbsolutePath());

            return new Config(host, port, connectTimeout, soTimeout, chunk,
                              dataPath, histPath, acceptedList, already, failDef,
                              cp, dateOverride, nameTemplate, fileNameTemplate,
                              reportNameTemplate, reportProcess);
        }

        /** Resuelve contra el CWD si la ruta es relativa. */
        private static Path resolveAgainstCwd(String p) {
            Path path = Paths.get(p);
            if (path.isAbsolute()) return path.normalize();
            return Paths.get(System.getProperty("user.dir")).resolve(p).normalize();
        }

        /** Obtiene un valor requerido. */
        private static String req(Map<String,String> m, String key) {
            String v = m.get(key);
            if (v == null || v.trim().isEmpty()) throw new IllegalArgumentException("Falta "+key);
            return v.trim();
        }

        /** Parsea entero con rango. */
        private static int parseInt(String s, int min, int max, String name) {
            try {
                int v = Integer.parseInt(s.trim());
                if (v < min || v > max) throw new IllegalArgumentException(name+" fuera de rango ["+min+","+max+"]");
                return v;
            } catch (NumberFormatException e) {
                throw new IllegalArgumentException(name+" no numerico: "+s);
            }
        }

        /** Convierte "a,b,c" en lista haciendo trim. */
        private static List<String> parseList(String csv) {
            List<String> out = new ArrayList<>();
            if (csv == null) return Collections.emptyList();
            for (String p : csv.split(",")) {
                String t = p.trim();
                if (!t.isEmpty()) out.add(t);
            }
            return out.isEmpty() ? Collections.emptyList() : Collections.unmodifiableList(out);
        }

        /** Primer acceptedCode o defaultFailCode si vacio. */
        String firstAcceptedCodeOrDefault() {
            return acceptedCodes.isEmpty() ? defaultFailCode : acceptedCodes.get(0);
        }

        /** Devuelve un acceptedCode de 7 chars para trailer. */
        String trailerCodeSeven() {
            String t = pickTrailerCodeSeven(acceptedCodes);
            if (t == null) throw new IllegalArgumentException("acceptedCode debe incluir un valor de 7 caracteres para trailer.");
            return t;
        }

        /** Selecciona el primer codigo de longitud 7. */
        private static String pickTrailerCodeSeven(List<String> codes) {
            if (codes == null) return null;
            for (String c : codes) {
                String t = (c == null ? "" : c.trim());
                if (t.length() == 7) return t;
            }
            return null;
        }
    }

    // ----------------------------- INI simple -----------------------------

    /**
     * Parser INI minimalista (UTF-8).
     *
     * Soporta secciones [x] y pares k=v. Ignora lineas vacias y comentarios (# o ;).
     * La ultima clave repetida gana.
     */
    static class IniFile {
        private final Map<String, Map<String,String>> data = new LinkedHashMap<>();
        private IniFile() {}

        /**
         * Carga un archivo INI desde disco.
         *
         * @param path Ruta del INI
         * @return IniFile parseado
         * @throws IOException si no existe o no es legible
         */
        static IniFile load(Path path) throws IOException {
            if (!Files.exists(path)) throw new NoSuchFileException(path.toString());
            IniFile f = new IniFile();
            Map<String,String> cur = null;
            try (BufferedReader br = Files.newBufferedReader(path, StandardCharsets.UTF_8)) {
                String line;
                while ((line = br.readLine()) != null) {
                    String ln = line.trim();
                    if (ln.isEmpty() || ln.startsWith("#") || ln.startsWith(";")) continue;
                    if (ln.startsWith("[") && ln.endsWith("]")) {
                        String sec = ln.substring(1, ln.length()-1).trim();
                        cur = f.data.computeIfAbsent(sec, k -> new LinkedHashMap<>());
                    } else {
                        int eq = ln.indexOf('=');
                        if (eq < 0 || cur == null) continue;
                        String k = ln.substring(0, eq).trim();
                        String v = ln.substring(eq+1).trim();
                        cur.put(k, v);
                    }
                }
            }
            return f;
        }

        /** Devuelve el mapa de una seccion o null si no existe. */
        Map<String,String> section(String name) { return data.get(name); }
    }

    // ------------------------------ Sender ------------------------------

    /**
     * Orquesta Opcion 1 (envio) y Opcion 2 (reporte).
     *
     * - Opcion 1:
     *   Valida entorno, lee/parte payload, arma nombre, handshake, envia tramas y trailer, historico.
     * - Opcion 2:
     *   Valida entorno, arma nombre base de reporte, consulta 01..99, procesa o no segun report.process,
     *   y genera archivo de confirmacion.
     */
    static class Sender {
        private final Config cfg;
        private final int option;
        private final String fileNameArg;
        private final String date; // NUEVO: fecha efectiva (CLI u hoy)

        Sender(Config cfg, int option, String fileNameArg, String cliDateParam) {
            this.cfg = cfg;
            this.option = option;
            this.fileNameArg = fileNameArg;
            // NUEVO: decidir fecha efectiva (CLI si viene, si no hoy)
            this.date = (cliDateParam != null && validateDate(cliDateParam))
                    ? cliDateParam
                    : LocalDate.now().format(DateTimeFormatter.BASIC_ISO_DATE);
            logger.info("Fecha efectiva: " + this.date + (cliDateParam != null ? " (CLI)" : " (hoy)"));
        }

        /** Ejecuta la opcion seleccionada. */
        void run() {
            if (option == 1) runSend();
            else if (option == 2) runReport();
            else throw new IllegalArgumentException("OPCION invalida: " + option);
        }

        // --------------------------- Opcion 1: Envio ---------------------------

        /**
         * Flujo de envio.
         * Lee dataFile, parte en chunkSize, arma nombre, handshake, envia tramas + trailer 11B,
         * espera confirmacion final y registra historico.
         */
        private void runSend() {
            logger.info("=== OPCION 1: Envio ===");

            validateEnvironmentForSend(cfg);

            byte[] payload = readPayload(cfg.dataFilePath);
            if (payload.length == 0) {
                logger.warning("El archivo de datos esta vacio: " + cfg.dataFilePath);
                createShippingHistory(cfg.defaultFailCode, "<NOFILE>", this.date, cfg.historyFilePath);
                return;
            }

            List<byte[]> parts = split(payload, cfg.chunkSize);
            logger.info("Partes a enviar: " + parts.size() + " (chunkSize=" + cfg.chunkSize + ")");

            String effectiveFileName = (fileNameArg != null && !fileNameArg.isEmpty())
                    ? fileNameArg
                    : generateFileNameFromTemplate(cfg.fileNameTemplate, this.date);

            if (effectiveFileName == null || effectiveFileName.isEmpty()) {
                throw new IllegalArgumentException("No hay FILE_NAME: CLI o fileNameTemplate requerido.");
            }
            if (effectiveFileName.length() != 9) {
                throw new IllegalArgumentException("FILE_NAME efectivo debe tener 9 caracteres. Obtenido: '" + effectiveFileName + "'");
            }
            logger.info("FILE_NAME efectivo: " + effectiveFileName);

            String nameToSend = applyNameTemplate(cfg.nameTemplate, effectiveFileName, this.date);
            logger.info("Nombre a enviar: " + nameToSend);

            String finalStatus = cfg.defaultFailCode;
            try (Socket sock = new Socket()) {
                sock.connect(new InetSocketAddress(cfg.host, cfg.port), cfg.connectTimeoutMs);
                sock.setSoTimeout(cfg.soTimeoutMs);
                logger.info(String.format("Conectado a %s:%d (SO_TIMEOUT=%dms)", cfg.host, cfg.port, cfg.soTimeoutMs));

                // Envio de nombre
                writeNameFrame(sock, nameToSend, cfg.codePage);

                // Aprobacion
                String resp = readResponse(sock, cfg.codePage).trim();
                logger.info("Respuesta aprobacion: [" + resp + "]");

                if (!cfg.alreadySentSubstring.isEmpty() && resp.contains(cfg.alreadySentSubstring)) {
                    logger.info("Servidor indica 'ya enviado'.");
                    finalStatus = cfg.firstAcceptedCodeOrDefault();
                } else if (matchesAny(resp, cfg.acceptedCodes)) {
                    logger.info("*** Enviando Tramas... [CANT:" + parts.size() + "]");
                    for (byte[] p : parts) {
                        writeChunkFrame(sock, p, cfg.codePage);
                        logger.info("Enviando trama al MIP [OK]");
                    }

                    // Trailer 11B
                    writeTrailerFrame(sock, parts.size() + 1, cfg.codePage, cfg.trailerCodeSeven());

                    // Confirmacion final
                    logger.info("Esperando confirmacion final...");
                    String resp2 = readResponse(sock, cfg.codePage).trim();
                    logger.info("Confirmacion final: [" + resp2 + "]");
                    if (matchesAny(resp2, cfg.acceptedCodes)) {
                        finalStatus = cfg.firstAcceptedCodeOrDefault();
                        logger.info("RESULTADO DE ENVIO [OK]");
                    } else {
                        logger.warning("RESULTADO DE ENVIO [FAIL] (codigo final no coincide con acceptedCode)");
                    }
                } else {
                    logger.warning("Nombre rechazado por el hub.");
                }
            } catch (UnknownHostException e) {
                logger.severe("Host desconocido: " + e.getMessage());
            } catch (SocketTimeoutException e) {
                logger.severe("Timeout de socket: " + e.getMessage());
            } catch (ConnectException e) {
                logger.severe("No se pudo conectar a " + cfg.host + ":" + cfg.port + " - " + e.getMessage());
            } catch (IOException e) {
                logger.severe("IO de red fallo: " + e.getMessage());
            } catch (Exception e) {
                logger.severe("Error inesperado en envio: " + e.getMessage());
            } finally {
                createShippingHistory(finalStatus, effectiveFileName, this.date, cfg.historyFilePath);
            }

            logger.info("=== PROCESO FINALIZADO (OPCION 1) ===");
        }

        // --------------------------- Opcion 2: Reporte -------------------------
        /**
         * Flujo de reporte.
         * - Lee UN solo bloque por secuencia (01..99), como el original (lectura one-shot 1024B max).
         * - Si report.process=Y, procesa headers+details con el bloque entre corchetes (parser legacy).
         * - Si report.process=N, escribe el contenido crudo tal cual llega del servidor.
         * - Si el parser falla, hace fallback al crudo (manteniendo el comportamiento del legado).
         *
         * *** ACTUALIZADO: Comportamiento calcado del código original (GCO_MIP) ***
         * Para cada secuencia:
         *   - Enviar nombre; leer múltiples bloques "legacy" en formato: '[' + chunk + "]\n"
         *   - Cortar cuando aparezca el PREFIJO de algún acceptedCode (p.ej. "998010")
         *   - Considerar "encontrado" cuando aparezca algún acceptedCode COMPLETO (p.ej. "9980100")
         *   - report.process = Y -> procesar con parser robusto; si falla -> fallback a crudo
         *   - report.process = N -> escribir crudo sin corchetes
         */
        private void runReport() {
            logger.info("=== OPCION 2: Reporte ===");

            validateEnvironmentForReport();

            String effectiveFileName = (fileNameArg != null && !fileNameArg.isEmpty())
                    ? fileNameArg
                    : generateFileNameFromTemplate(cfg.fileNameTemplate, this.date);

            if (effectiveFileName == null || effectiveFileName.isEmpty()) {
                throw new IllegalArgumentException("No hay FILE_NAME: CLI o fileNameTemplate requerido.");
            }
            if (effectiveFileName.length() != 9) {
                throw new IllegalArgumentException("FILE_NAME efectivo debe tener 9 caracteres. Obtenido: '" + effectiveFileName + "'");
            }
            logger.info("FILE_NAME efectivo: " + effectiveFileName);

            // Nombre base de consulta (desde INI). Equivalente al original "10101{file}{julian}"
            String nameBase = applyNameTemplate(cfg.reportNameTemplate, effectiveFileName, this.date);
            logger.info("Nombre base de reporte: " + nameBase);

            String acceptedFirst = cfg.firstAcceptedCodeOrDefault();
            boolean found = false;

            // Acumuladores finales (se llenan solo cuando "found")
            StringBuilder finalRaw = new StringBuilder();
            StringBuilder finalFmt = new StringBuilder();

            try (Socket sock = new Socket()) {
                logger.info("[IP:" + cfg.host + "][PTO:" + cfg.port + "]");
                sock.connect(new InetSocketAddress(cfg.host, cfg.port), cfg.connectTimeoutMs);
                sock.setSoTimeout(cfg.soTimeoutMs);
                logger.info("Estado de conexion con el MIP: " + sock.isConnected());

                // Consulta secuencias 01..99 (como el original)
                for (int i = 1; i <= 99; i++) {
                    String secStr = String.format("%02d", i);
                    String queryName = nameBase + secStr;

                    logger.info("*** Consultando archivo de respuesta al MIP: " + queryName);
                    writeNameFrame(sock, queryName, cfg.codePage);

                    // === LECTURA MÚLTIPLE AL ESTILO ORIGINAL ===
                    StringBuilder rawAcc = new StringBuilder(); // crudo SIN corchetes (para N)
                    StringBuilder fmtAcc = new StringBuilder(); // con corchetes (para Y)

                    boolean moreData = true;
                    while (moreData) {
                        String chunk = readLegacyBlock(sock, cfg.codePage); // un solo read(1024) + filtro imprimibles
                        fmtAcc.append('[').append(chunk).append("]\n");
                        rawAcc.append(chunk);

                        // DEBUG opcional (tal como el que mostraste)
                        String fmt = fmtAcc.toString();
                        String sansGt = fmt.replace(">", "");
                        int take = Math.min(20, sansGt.length());
                        logger.info("DBG fmt startsWith '[': " + fmt.startsWith("[") + ", len=" + fmt.length());
                        logger.info("DBG first20(after removing '>'): [" + sansGt.substring(0, take) + "]");
                        logger.info("DBG first64(raw, \\n shown): " + fmt.replace("\n","\\n").substring(0, Math.min(64, fmt.length())));

                        // Cortar cuando aparece el PREFIJO de un acceptedCode (p.ej. "998010")
                        if (chunk.isEmpty() || containsAnyAcceptedPrefix(fmtAcc.toString(), cfg.acceptedCodes)) {
                            moreData = false;
                        }
                    }

                    // Archivo encontrado si el contenido incluye algún acceptedCode COMPLETO
                    if (containsAny(rawAcc.toString(), cfg.acceptedCodes)) {
                        logger.info("Archivo encontrado [OK]");
                        found = true;
                        finalRaw.setLength(0);
                        finalFmt.setLength(0);
                        finalRaw.append(rawAcc);
                        finalFmt.append(fmtAcc);
                        break; // dejamos de iterar 01..99
                    } else {
                        logger.info("Buscando...");
                    }
                }

                if (found) {
                    logger.info("*** Generando archivo de respuesta (Reporte)...");
                    String dataToWrite;
                    if (cfg.reportProcess) {
                        // Procesado con parser legacy robusto; si falla, fallback a crudo
                        try {
                            dataToWrite = orderDetails(finalFmt.toString(), acceptedFirst);
                        } catch (Exception ex) {
                            logger.severe("Ocurrio un error al ordenar el contenido del archivo: " + ex.getMessage());
                            dataToWrite = finalRaw.toString(); // fallback
                        }
                    } else {
                        // N: escribir crudo tal cual (SIN corchetes)
                        dataToWrite = finalRaw.toString();
                    }

                    // Escribe el archivo y muestra el nombre en logs
                    writeDataToFile(this.date, dataToWrite, effectiveFileName);
                    logger.info("*** Reporte generado: [OK]");
                } else {
                    logger.severe("*** Respuesta del MIP: Archivo no encontrado [FAIL]");
                }
            } catch (UnknownHostException e) {
                logger.severe("Host desconocido: " + e.getMessage());
            } catch (SocketTimeoutException e) {
                logger.severe("Timeout de socket: " + e.getMessage());
            } catch (ConnectException e) {
                logger.severe("No se pudo conectar a " + cfg.host + ":" + cfg.port + " - " + e.getMessage());
            } catch (IOException e) {
                logger.severe("IO de red fallo: " + e.getMessage());
            } catch (Exception e) {
                logger.severe("Error inesperado en reporte: " + e.getMessage());
            }

            logger.info("=== PROCESO FINALIZADO (OPCION 2) ===");
        }

        // ----------------------------- Utilidades -----------------------------

        /** true si value coincide exactamente con algun elemento de options. */
        private static boolean matchesAny(String value, List<String> options) {
            if (options == null || options.isEmpty()) return false;
            for (String o : options) if (value.equals(o)) return true;
            return false;
        }

        /** true si hay algun acceptedCode contenido como substring. */
        private static boolean containsAny(String haystack, List<String> options) {
            if (options == null || options.isEmpty()) return false;
            for (String o : options) if (haystack.contains(o)) return true;
            return false;
        }

        /** true si aparece el prefijo (primeros 6) de algun acceptedCode. (No usado en Opcion 2 v2) */
        private static boolean containsAnyAcceptedPrefix(String haystack, List<String> options) {
            if (options == null || options.isEmpty()) return false;
            for (String o : options) {
                String p = o.trim();
                if (p.isEmpty()) continue;
                String pref = (p.length() >= 6 ? p.substring(0, 6) : p);
                if (haystack.contains(pref)) return true;
            }
            return false;
        }

        /**
         * Trailer final de 11 bytes.
         *
         * Cuerpo = EBCDIC(acceptedCode de 7 chars) + contador(4B big-endian).
         *
         * @param s            socket conectado
         * @param count        numero total de tramas de datos + 1
         * @param ebcdic       code page EBCDIC
         * @param trailerCode7 codigo de 7 caracteres (desde acceptedCode)
         */
        private static void writeTrailerFrame(Socket s, int count, Charset ebcdic, String trailerCode7) throws IOException {
            if (trailerCode7 == null || trailerCode7.length() != 7) {
                throw new IllegalArgumentException("El codigo de trailer debe tener 7 caracteres.");
            }
            byte[] prefix = trailerCode7.getBytes(ebcdic);
            byte[] cnt = lengthToBytes(count, 4);
            byte[] body = new byte[11];
            System.arraycopy(prefix, 0, body, 0, 7);
            System.arraycopy(cnt,    0, body, 7, 4);
            writeFrameRaw(s, body);
        }

        /**
         * Genera FILE_NAME desde fileNameTemplate (case-insensitive).
         *
         * Reglas: literal (9), {rand}=4 digitos, {ddmm}=dia+mes.
         *
         * @param template  plantilla del INI
         * @param yyyymmdd  fecha efectiva YYYYMMDD
         * @return nombre de 9 caracteres
         */
        private static String generateFileNameFromTemplate(String template, String yyyymmdd) {
            if (template == null || template.trim().isEmpty()) {
                throw new IllegalArgumentException("fileNameTemplate no definido en el INI.");
            }
            String base = template.trim();
            LocalDate d = LocalDate.parse(yyyymmdd, DateTimeFormatter.BASIC_ISO_DATE);
            String ddmm = String.format("%02d%02d", d.getDayOfMonth(), d.getMonthValue());

            base = base.replaceAll("(?i)\\{ddmm\\}", ddmm);

            if (base.matches("(?i).*\\{rand\\}.*")) {
                String rand4 = String.format("%04d", new Random().nextInt(10000));
                base = base.replaceAll("(?i)\\{rand\\}", rand4);
            }

            base = base.toUpperCase(Locale.ROOT);

            if (base.length() != 9) {
                throw new IllegalArgumentException("fileNameTemplate debe producir 9 caracteres. Obtenido '" + base + "' (" + base.length() + ")");
            }
            return base;
        }

        /**
         * Aplica plantilla de nombre.
         *
         * Tokens: {file}, {julian}, {yyyymmdd}, {yy}, {mm}, {dd} (case-insensitive).
         *
         * @param template plantilla a aplicar
         * @param fileName nombre logico (9 chars)
         * @param yyyymmdd fecha efectiva
         * @return nombre final
         */
        private static String applyNameTemplate(String template, String fileName, String yyyymmdd) {
            LocalDate d = LocalDate.parse(yyyymmdd, DateTimeFormatter.BASIC_ISO_DATE);
            String julian = String.format("%03d", d.getDayOfYear());
            String yy = String.format("%02d", d.getYear() % 100);
            String mm = String.format("%02d", d.getMonthValue());
            String dd = String.format("%02d", d.getDayOfMonth());

            String out = template;
            out = out.replaceAll("(?i)\\{file\\}",     java.util.regex.Matcher.quoteReplacement(fileName));
            out = out.replaceAll("(?i)\\{julian\\}",   julian);
            out = out.replaceAll("(?i)\\{yyyymmdd\\}", yyyymmdd);
            out = out.replaceAll("(?i)\\{yy\\}",       yy);
            out = out.replaceAll("(?i)\\{mm\\}",       mm);
            out = out.replaceAll("(?i)\\{dd\\}",       dd);
            return out;
        }

        /**
         * Valida permisos para envio.
         *
         * Requiere: CWD legible/ejecutable, dataFile legible, dir del historico escribible/ejecutable.
         */
        private static void validateEnvironmentForSend(Config cfg) {
            File cwd = new File(System.getProperty("user.dir"));
            logDirPerms("Directorio actual", cwd);
            if (!cwd.canRead() || !cwd.canExecute()) {
                throw new IllegalStateException("El directorio actual no tiene permisos suficientes (lectura y ejecucion).");
            }

            File dataFile = cfg.dataFilePath.toFile();
            if (!dataFile.exists() || !dataFile.isFile()) {
                throw new IllegalStateException("No existe el archivo de datos o no es regular: " + cfg.dataFilePath);
            }
            logger.info("Permisos del archivo de datos (" + dataFile.getName() + "):");
            logger.info("Lectura: " + (dataFile.canRead() ? "Permitido" : "No permitido"));
            logger.info("Escritura: " + (dataFile.canWrite() ? "Permitido" : "No permitido"));
            if (!dataFile.canRead()) {
                throw new IllegalStateException("No hay permisos de lectura sobre el archivo de datos: " + dataFile.getAbsolutePath());
            }

            File histFile = cfg.historyFilePath.toFile();
            File histDir  = histFile.getAbsoluteFile().getParentFile();
            if (histDir != null) {
                logDirPerms("Directorio del historico", histDir);
                if (!histDir.canWrite() || !histDir.canExecute()) {
                    throw new IllegalStateException("El directorio del historico no permite escribir/ejecutar: " + histDir.getAbsolutePath());
                }
            }

            try (FileChannel ignore = FileChannel.open(cfg.historyFilePath,
                    StandardOpenOption.CREATE, StandardOpenOption.WRITE, StandardOpenOption.APPEND)) {
                // OK
            } catch (IOException e) {
                throw new IllegalStateException("No se puede crear/escribir en el historico: " + cfg.historyFilePath + " - " + e.getMessage(), e);
            }
        }

        /**
         * Valida permisos para reporte.
         *
         * Requiere: CWD legible/ejecutable/escribible para crear el archivo de reporte.
         */
        private static void validateEnvironmentForReport() {
            File cwd = new File(System.getProperty("user.dir"));
            logDirPerms("Directorio actual", cwd);
            if (!cwd.canRead() || !cwd.canExecute() || !cwd.canWrite()) {
                throw new IllegalStateException("El directorio actual no tiene permisos suficientes (lectura/ejecucion/escritura) para generar el reporte.");
            }
        }

        /** Log de permisos de un directorio. */
        private static void logDirPerms(String label, File dir) {
            logger.info(label + " (" + dir.getAbsolutePath() + "):");
            logger.info("Lectura: " + (dir.canRead() ? "Permitido" : "No permitido"));
            logger.info("Escritura: " + (dir.canWrite() ? "Permitido" : "No permitido"));
            logger.info("Ejecucion: " + (dir.canExecute() ? "Permitido" : "No permitido"));
        }

        /**
         * Lee bytes del archivo de datos.
         *
         * @param p ruta del archivo de entrada
         * @return bytes del payload
         */
        private static byte[] readPayload(Path p) {
            logger.info("Leyendo payload: " + p.toAbsolutePath());
            try {
                byte[] data = Files.readAllBytes(p);
                logger.info("Tamano payload: " + data.length + " bytes");
                return data;
            } catch (AccessDeniedException e) {
                throw new RuntimeException("Sin permisos para leer: " + p, e);
            } catch (NoSuchFileException e) {
                throw new RuntimeException("No existe el archivo: " + p, e);
            } catch (IOException e) {
                throw new RuntimeException("Error leyendo archivo: " + p + " - " + e.getMessage(), e);
            }
        }

        /**
         * Parte bytes en trozos de tamano fijo.
         *
         * @param data bytes de entrada
         * @param chunkSize tamano maximo por parte
         * @return lista de partes (cada una <= chunkSize)
         */
        private static List<byte[]> split(byte[] data, int chunkSize) {
            List<byte[]> parts = new ArrayList<>();
            int total = data.length;
            for (int off = 0; off < total; off += chunkSize) {
                int len = Math.min(chunkSize, total - off);
                parts.add(Arrays.copyOfRange(data, off, off + len));
            }
            return parts;
        }

        /**
         * Codifica entero sin signo en big-endian usando N bytes.
         *
         * @param num valor
         * @param byts cantidad de bytes
         * @return arreglo big-endian
         */
        private static byte[] lengthToBytes(int num, int byts) {
            byte[] r = new byte[byts];
            for (int i = byts - 1; i >= 0; --i) {
                r[i] = (byte)(num & 0xFF);
                num >>>= 8;
            }
            return r;
        }

        /**
         * Devuelve fecha efectiva YYYYMMDD (override desde INI o fecha del sistema).
         *
         * @param cfg configuracion
         * @return AAAAMMDD
         */
        private static String effectiveDate(Config cfg) {
            return (cfg.dateOverride != null && !cfg.dateOverride.isEmpty())
                    ? cfg.dateOverride
                    : LocalDate.now().format(DateTimeFormatter.BASIC_ISO_DATE);
        }

        /**
         * Escribe trama de nombre (texto -> EBCDIC) con header de 2 bytes.
         *
         * @param s socket
         * @param text cuerpo textual
         * @param ebcdic code page
         */
        private static void writeNameFrame(Socket s, String text, Charset ebcdic) throws IOException {
            byte[] body = text.getBytes(ebcdic);
            writeFrameRaw(s, body);
        }

        /**
         * Escribe trama de datos con prefijo 'R' (ASCII), luego convierte a EBCDIC y envia.
         *
         * @param s socket
         * @param asciiChunk bloque ASCII sin prefijo
         * @param ebcdic code page
         */
        private static void writeChunkFrame(Socket s, byte[] asciiChunk, Charset ebcdic) throws IOException {
            ByteArrayOutputStream baos = new ByteArrayOutputStream(1 + asciiChunk.length);
            baos.write((byte) 'R');
            baos.write(asciiChunk);
            String asText = new String(baos.toByteArray(), StandardCharsets.US_ASCII);
            byte[] body = asText.getBytes(ebcdic);
            writeFrameRaw(s, body);
        }

        /**
         * Escribe header(2B) + body en el socket y hace flush.
         *
         * @param s socket
         * @param body cuerpo sin header
         */
        private static void writeFrameRaw(Socket s, byte[] body) throws IOException {
            int len = body.length;
            byte[] header = lengthToBytes(len, 2);
            OutputStream os = s.getOutputStream();
            os.write(header);
            os.write(body);
            os.flush();
        }

        /**
         * Lee respuesta del servidor hasta lectura corta o timeout.
         * Decodifica desde EBCDIC a String.
         *
         * Corta si:
         * - read() retorna -1 (fin)
         * - la ultima lectura < tamano de buffer
         * - timeout: si ya hay datos, devuelve; si no, relanza
         *
         * @param s socket
         * @param ebcdic code page
         * @return texto decodificado
         */
        private static String readResponse(Socket s, Charset ebcdic) throws IOException {
            ByteArrayOutputStream baos = new ByteArrayOutputStream();
            InputStream is = s.getInputStream();
            byte[] buf = new byte[1024];
            int n;
            while (true) {
                try {
                    n = is.read(buf);
                    if (n == -1) break;
                    baos.write(buf, 0, n);
                    if (n < buf.length) break;
                } catch (SocketTimeoutException te) {
                    if (baos.size() == 0) throw te;
                    break;
                }
            }
            byte[] ebcdicBytes = baos.toByteArray();
            return new String(ebcdicBytes, ebcdic);
        }

        /**
         * Lectura one-shot (como el legado InSocket): un solo read() de 1024 bytes, EBCDIC->String,
         * filtrando solo ASCII imprimible (' '..'~') y salto de linea '\n'.
         *
         * @param s socket conectado
         * @param ebcdic code page EBCDIC
         * @return bloque decodificado y filtrado; "" si no hubo datos
         * @throws IOException si falla la lectura
         */
        private static String readLegacyBlock(Socket s, Charset ebcdic) throws IOException {
            InputStream is = s.getInputStream();
            byte[] buf = new byte[1024];
            int n = is.read(buf, 0, 1024);
            if (n <= 0) return "";
            String decoded = new String(buf, 0, n, ebcdic);
            StringBuilder out = new StringBuilder(decoded.length());
            for (int i = 0; i < decoded.length(); i++) {
                char c = decoded.charAt(i);
                if (c >= ' ' && c <= '~') {
                    out.append(c);
                } else if (c == '\n') {
                    out.append('\n');
                }
                // otros (incl. '\r' y controles) se descartan para calcar el legado
            }
            return out.toString();
        }

        // ---------------------- Historico (solo Opcion 1) ----------------------

        /**
         * Agrega un registro al historico (prepend) y rota mensualmente si corresponde.
         *
         * @param respCode codigo final (acceptedCode o defaultFailCode)
         * @param fileName nombre logico (9 chars)
         * @param dateYYYYMMDD fecha efectiva
         * @param historyPath ruta del historico
         */
        private static void createShippingHistory(String respCode, String fileName, String dateYYYYMMDD, Path historyPath) {
            try {
                monthlyRotateIfFirstDay(historyPath);
                String record = formatHistory(respCode, fileName, dateYYYYMMDD, LocalDateTime.now());
                prependLine(historyPath, record);
                logger.info("Historico actualizado: " + historyPath);
            } catch (Exception e) {
                logger.severe("No se pudo actualizar el historico: " + e.getMessage());
            }
        }

        /** Si es dia 1, trunca/crea historico. */
        private static void monthlyRotateIfFirstDay(Path historyPath) {
            if (LocalDate.now().getDayOfMonth() == 1) {
                try {
                    Files.write(historyPath, new byte[0],
                            StandardOpenOption.CREATE, StandardOpenOption.TRUNCATE_EXISTING);
                } catch (IOException e) {
                    logger.warning("No se pudo rotar historico mensual: " + e.getMessage());
                }
            }
        }

        /** Formatea linea de historico. */
        private static String formatHistory(String resp, String code, String fec, LocalDateTime now) {
            String ts = now.format(DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss"));
            return "[" + resp + "-" + code + "-" + fec + ": " + ts + "]";
        }

        /**
         * Inserta una linea al inicio del archivo (prepend).
         *
         * @param path ruta del archivo
         * @param line contenido a insertar
         */
        private static void prependLine(Path path, String line) throws IOException {
            List<String> lines = new ArrayList<>();
            if (Files.exists(path)) {
                try {
                    lines = Files.readAllLines(path, StandardCharsets.UTF_8);
                } catch (MalformedInputException mie) {
                    lines = new ArrayList<>();
                }
            }
            lines.add(0, line);
            Files.write(path, String.join(System.lineSeparator(), lines).getBytes(StandardCharsets.UTF_8),
                    StandardOpenOption.CREATE, StandardOpenOption.TRUNCATE_EXISTING, StandardOpenOption.WRITE);
        }

        // ------------------ Helpers de reporte (Opcion 2) ---------------------

        /**
         * Genera y escribe el archivo de reporte en el CWD.
         *
         * @param dateYYYYMMDD fecha AAAAMMDD
         * @param data contenido a escribir (procesado o crudo)
         * @param fileName9 FILE_NAME (9 chars) para prefijo del nombre
         */
        private static void writeDataToFile(String dateYYYYMMDD, String data, String fileName9) throws IOException {
            logger.info("Parametro date: " + dateYYYYMMDD + " (" + dateYYYYMMDD.length() + ")");
            if (!validateDate(dateYYYYMMDD)) {
                logger.severe("Fecha ingresada no es valida: " + dateYYYYMMDD);
                return;
            }
            final String newName = getNameFileReport(dateYYYYMMDD, fileName9);
            logger.info("Generacion de nombre de reporte es valido: " + (newName != null));
            if (newName == null) {
                logger.severe("Nombre de reporte no pudo generarse.");
                return;
            }
            logger.info("Creando reporte...");
            try (FileOutputStream reportFile = new FileOutputStream(newName);
                 PrintStream ps = new PrintStream(reportFile, true, "UTF-8")) {
                ps.print(data);
            }
            // NUEVO: mostrar el nombre del archivo generado
            logger.info("Reporte: " + newName + "[GENERADO]");
        }

        /**
         * Reordena el bloque recibido como el original: headers + details.
         * Si algo falla en el parseo, la excepcion se propaga y el llamador decide fallback.
         *
         * @param dataMipDato cadena cruda con corchetes agregados por lectura
         * @param allOkCode   codigo OK final (ej. 9980100)
         * @return cadena con headers y detalles formateados
         */
        private static String orderDetails(String dataMipDato, String allOkCode) {
            // Normaliza artefacto 'T' al inicio de linea antes de 'H' ("]\nTH..." -> "]\nH...")
            String fixed = normalizeTHArtifact(dataMipDato);

            String headers = extractHeaders(fixed);
            String details = extractDetails(fixed, allOkCode);
            return headers + details;
        }

        /**
         * Extrae cabeceras desde el bloque recibido.
         *
         * Regla:
         * - Encabezado corto: primeros 20 chars (sin '>') + "]\n"
         * - Cabecera: desde "12" (legacy) o "H0" (formato nuevo) hasta antes del primer "16" o "D0".
         *   Si no hay "16"/"D0", hasta el ']' siguiente o fin.
         *
         * @param data bloque con corchetes
         * @return cabecera formateada
         */
        private static String extractHeaders(String data) {
            String src = (data == null) ? "" : data;

            // Encabezado corto (20) y corchete cierre como el legado
            String sansGt  = src.replace(">", "");
            String first20 = sansGt.length() >= 20 ? sansGt.substring(0, 20)
                                                   : String.format("%-20s", sansGt);
            String header = first20 + "]\n";

            // Inicios posibles: "12" (legacy) o "H0" (formato con H/D0)
            int start12 = src.indexOf("12");
            int startH  = src.indexOf("H0");
            int start   = (start12 >= 0) ? start12 : (startH >= 0 ? startH : -1);

            if (start < 0) return header; // no hay header info reconocible

            // Fines posibles: "16" (legacy) o "D0" (H/D0) o el primer ']' o fin
            int end16   = src.indexOf("16", start);
            int endD0   = src.indexOf("D0", start);
            int endBrkt = src.indexOf("]",  start);

            int end = firstNonNegMin(end16, endD0, endBrkt);
            if (end < 0) end = src.length();

            return header + safeSub(src, start, end);
        }

        /**
         * Extrae detalles desde el bloque recibido, respetando anchos fijos.
         *
         * NOTA: Se añade un salto de línea ANTES del primer registro para que
         * la línea de detalle "D0..." comience en una NUEVA línea, incluso si
         * los headers no terminaron con '\n'.
         */
        private static String extractDetails(String data, String allOkCode) {
            String src = (data == null) ? "" : data;

            int start16 = src.indexOf("16");
            int startD0 = src.indexOf("D0");
            int start   = (start16 >= 0) ? start16 : (startD0 >= 0 ? startD0 : -1);
            if (start < 0) return "";

            // Limpiar corchetes de bloques (legado)
            String cleaned = safeSub(src, start, src.length()).replace("[","").replace("]\n","");

            // Separar por D0 (delimitador de registros de detalle)
            String[] detailsData = cleaned.split("D0", -1);

            StringBuilder out = new StringBuilder();
            // Asegurar que el primer D0 va en una NUEVA línea respecto a los headers
            out.append('\n');

            boolean first = true;
            for (int i = 1; i < detailsData.length; i++) {
                String seg = detailsData[i];

                // Para el primer item ya metimos el salto; para los siguientes, agrega uno
                if (!first) out.append('\n');
                first = false;

                // Prefijo requerido
                out.append("D0");

                // Partes fijas
                String head = seg.length() >= 57 ? seg.substring(0,57) : String.format("%-57s", seg);
                String tail = seg.length()  > 57 ? seg.substring(57)   : "";

                if (i == detailsData.length - 1) {
                    // Último item
                    if (tail.length() < 26) {
                        String t = tail.trim();
                        if (t.length() > 15) t = t.substring(0, 15);
                        String codErrors = String.format("%26s", t);
                        out.append(head).append(codErrors).append(allOkCode);
                    } else {
                        int okPos = seg.indexOf(allOkCode);
                        if (okPos >= 0) {
                            out.append(seg, 0, okPos + allOkCode.length());
                        } else {
                            // Fallback legacy si no aparece el OK
                            out.append(seg, 0, Math.min(83, seg.length()));
                        }
                    }
                    break;
                }

                // Items intermedios: 83 chars
                out.append(seg, 0, Math.min(83, seg.length()));
            }

            return out.toString();
        }

        /** Valida fecha AAAAMMDD. */
        private static boolean validateDate(String date) {
            DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyyMMdd");
            try {
                LocalDate.parse(date, formatter);
                return true;
            } catch (Exception e) {
                return false;
            }
        }

        /**
         * Nombre de archivo de reporte: NNNN-YYYYMMDD-Archivo de Cambio Confirmacion
         *
         * @param dateYYYYMMDD fecha AAAAMMDD
         * @param fileName9 FILE_NAME (9 chars)
         * @return nombre del archivo o null si la fecha es invalida
         */
        private static String getNameFileReport(String dateYYYYMMDD, String fileName9) {
            final String description = "-Archivo de Cambio Confirmacion";
            DateTimeFormatter inputFormatter = DateTimeFormatter.ofPattern("yyyyMMdd");
            DateTimeFormatter outputFormatter = DateTimeFormatter.ofPattern("yyyyMMdd");
            String prefix = fileName9.substring(0, 4) + "-";
            try {
                LocalDate fecha = LocalDate.parse(dateYYYYMMDD, inputFormatter);
                return prefix + fecha.format(outputFormatter) + description;
            } catch (Exception e) {
                logger.severe("Parametro date(" + dateYYYYMMDD + ") incorrecto.");
                return null;
            }
        }

        /** Quita un 'T' al inicio de línea justo antes de 'H' (caso visto: "]\nTH000..." -> "]\nH000..."). */
        private static String normalizeTHArtifact(String s) {
            if (s == null) return "";
            return s.replaceAll("(?m)^T(?=H)", "");
        }

        /** substring seguro (evita OOB). */
        private static String safeSub(String s, int from, int to) {
            if (s == null) return "";
            int a = Math.max(0, Math.min(from, s.length()));
            int b = Math.max(a, Math.min(to,   s.length()));
            return s.substring(a, b);
        }

        /** mínimo entre índices >=0; retorna -1 si ninguno es válido. */
        private static int firstNonNegMin(int... idx) {
            int best = -1;
            for (int v : idx) if (v >= 0 && (best < 0 || v < best)) best = v;
            return best;
        }
    }
}


