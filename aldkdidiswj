//=================================================================================================
// McBatchSender
//
// Proposito:
//   Envia un archivo de datos a un hub (ej. Mastercard) por TCP (Opcion 1) y genera reporte
//   de confirmacion (Opcion 2), fiel al comportamiento del original.
//
// Protocolo:
//   - Cada trama: header de 2 bytes (longitud big-endian) + cuerpo en EBCDIC.
//   - Opcion 1 (envio): cada bloque de datos se envía con prefijo ASCII 'R' y luego se convierte
//     a EBCDIC. Trailer final: 11 bytes = EBCDIC(acceptedCode de 7 chars) + contador(4B).
//
// Flujo (resumen):
//   Opcion 1 (Envio):
//     1) Valida permisos (CWD, dataFile, historico).
//     2) Lee dataFilePath, parte en chunkSize, determina FILE_NAME (CLI o fileNameTemplate).
//     3) Arma nombre con nameTemplate y hace handshake (acceptedCode / alreadySentSubstring).
//     4) Envia tramas y trailer 11B, espera confirmacion final (acceptedCode) y actualiza historico.
//   Opcion 2 (Reporte):
//     1) Valida permisos (CWD con escritura).
//     2) Determina FILE_NAME (CLI o fileNameTemplate).
//     3) Arma nombre base desde reportNameTemplate y consulta secuencias 01..99.
//     4) Si report.process=Y: procesa headers+details; si N: escribe contenido crudo.
//     5) Genera archivo NNNN-YYYYMMDD-Archivo de Cambio Confirmacion y muestra su nombre.
//
// Parametrizacion (INI):
//   - host, port, connectTimeoutMs, soTimeoutMs, chunkSize
//   - dataFilePath, historyFilePath
//   - acceptedCode (lista; uno de 7 chars se usa en trailer)
//   - alreadySentSubstring, defaultFailCode
//   - codePage (Cp037/Cp500/Cp1047)
//   - nameTemplate (p.ej. "00401{file}{julian}")
//   - fileNameTemplate (literal | {rand} | {ddmm} -> 9 chars exactos)
//   - reportNameTemplate (p.ej. "10101{file}{julian}")
//   - report.process=Y|N
//
// Uso:
//   javac McBatchSender.java
//   java McBatchSender <OPCION> <YYYYMMDD?> <seccion> [FILE_NAME]  [-Dmcsender.config=/ruta/mcsender.ini]
//   - <OPCION>    : 1=Envio, 2=Reporte
//   - <YYYYMMDD?> : (opcional) fecha. Si se pasa, debe ir como 2do argumento; si no, se usa hoy.
//   - <seccion>   : nombre de la seccion del INI (ej. MIP, GCO)
//   - [FILE_NAME] : opcional; prioridad sobre fileNameTemplate; 9 chars exactos
//
// Codigos de salida:
//   0=OK | 1=error inesperado | 2=uso invalido | 3=INI no encontrado | 4=INI/argumento invalido
//=================================================================================================

import java.io.ByteArrayOutputStream;
import java.io.BufferedReader;
import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.NoSuchFileException;
import java.io.OutputStream;
import java.io.PrintStream;
import java.net.ConnectException;
import java.net.InetSocketAddress;
import java.net.Socket;
import java.net.SocketTimeoutException;
import java.net.UnknownHostException;
import java.nio.channels.FileChannel;
import java.nio.charset.Charset;
import java.nio.charset.MalformedInputException;
import java.nio.charset.StandardCharsets;
import java.nio.file.AccessDeniedException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.nio.file.StandardOpenOption;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.Random;
import java.util.logging.Logger;

public class McBatchSender {
    private static final Logger logger = Logger.getLogger(McBatchSender.class.getName());

    // ---------------------------------------------------------------------------------------------
    // main: parsea CLI (con fecha opcional como 2do argumento), carga INI y despacha opcion.
    // ---------------------------------------------------------------------------------------------
    public static void main(String[] args) {
        if (args.length < 2) {
            System.err.println("Uso: java McBatchSender <OPCION> <YYYYMMDD?> <seccion> [FILE_NAME]  [-Dmcsender.config=/ruta/mcsender.ini]");
            System.exit(2);
        }

        final String optionStr = args[0].trim();
        final int option;
        try {
            option = Integer.parseInt(optionStr);
        } catch (NumberFormatException nfe) {
            System.err.println("OPCION debe ser 1 (envio) o 2 (reporte). Valor: '" + optionStr + "'");
            System.exit(4);
            return;
        }
        if (option != 1 && option != 2) {
            System.err.println("OPCION invalida. Use 1 (envio) o 2 (reporte).");
            System.exit(4);
        }

        // Soporte de dos formatos:
        //   - Si args[1] es YYYYMMDD, se toma como fecha y la seccion es args[2].
        //   - Si NO lo es, seccion = args[1] y se usa fecha de hoy.
        String cliDateArg = null;
        String section;
        String fileNameArg = null;

        final String maybeDateOrSection = args[1].trim();
        if (maybeDateOrSection.matches("\\d{8}")) {
            cliDateArg = maybeDateOrSection;
            if (args.length < 3) {
                System.err.println("Falta <seccion> despues de la fecha (YYYYMMDD).");
                System.exit(2);
            }
            section = args[2].trim();
            if (args.length >= 4) fileNameArg = args[3].trim().toUpperCase(Locale.ROOT);
        } else {
            section = maybeDateOrSection;
            if (args.length >= 3) fileNameArg = args[2].trim().toUpperCase(Locale.ROOT);
        }

        if (fileNameArg != null && fileNameArg.length() != 9) {
            System.err.println("FILE_NAME debe tener exactamente 9 caracteres. Valor: '" + fileNameArg + "'");
            System.exit(4);
        }
        if (cliDateArg != null && !Sender.validateDate(cliDateArg)) {
            System.err.println("Fecha invalida (YYYYMMDD): '" + cliDateArg + "'");
            System.exit(4);
        }

        final String iniPath = System.getProperty("mcsender.config", "mcsender.ini");
        final Path ini = Paths.get(iniPath);

        try {
            IniFile cfgFile = IniFile.load(ini);
            Config cfg = Config.from(cfgFile, section);

            logger.info("OPCION: " + option);
            logger.info("Host: " + cfg.host + " (" + cfg.host.length() + ")");
            logger.info("Puerto: " + cfg.port + " (" + String.valueOf(cfg.port).length() + ")");
            if (cliDateArg != null) logger.info("Fecha (CLI): " + cliDateArg);
            logger.info("nameTemplate: " + cfg.nameTemplate);
            logger.info("acceptedCodes: " + cfg.acceptedCodes);
            logger.info("trailerCode (7 chars): " + cfg.trailerCodeSeven());
            logger.info("reportNameTemplate: " + cfg.reportNameTemplate + " | report.process=" + (cfg.reportProcess ? "Y" : "N"));
            if (fileNameArg != null) {
                logger.info("FILE_NAME (CLI): " + fileNameArg + " (" + fileNameArg.length() + ")");
            } else {
                logger.info("FILE_NAME (CLI): <no provisto> -> fileNameTemplate=" + cfg.fileNameTemplate);
            }

            new Sender(cfg, option, fileNameArg, cliDateArg).run();
            System.exit(0);
        } catch (NoSuchFileException e) {
            System.err.println("No se encontro el archivo de configuracion: " + e.getFile());
            System.exit(3);
        } catch (IllegalArgumentException e) {
            System.err.println("Configuracion/argumento invalido: " + e.getMessage());
            System.exit(4);
        } catch (Exception e) {
            System.err.println("Error inesperado: " + e.getMessage());
            System.exit(1);
        }
    }

    // -------------------------------- Config ---------------------------------

    /**
     * Configuracion efectiva.
     * Campos: red, archivos, control, charset, plantillas y flags de reporte.
     */
    static class Config {
        final String host;
        final int port;
        final int connectTimeoutMs;
        final int soTimeoutMs;
        final int chunkSize;
        final Path dataFilePath;
        final Path historyFilePath;
        final List<String> acceptedCodes;
        final String alreadySentSubstring;
        final String defaultFailCode;
        final Charset codePage;
        final String nameTemplate;
        final String fileNameTemplate;
        final String reportNameTemplate;
        final boolean reportProcess;

        private Config(String host, int port, int connectTimeoutMs, int soTimeoutMs, int chunkSize,
                       Path dataFilePath, Path historyFilePath, List<String> acceptedCodes,
                       String alreadySentSubstring, String defaultFailCode,
                       Charset codePage, String nameTemplate, String fileNameTemplate,
                       String reportNameTemplate, boolean reportProcess) {
            this.host = host;
            this.port = port;
            this.connectTimeoutMs = connectTimeoutMs;
            this.soTimeoutMs = soTimeoutMs;
            this.chunkSize = chunkSize;
            this.dataFilePath = dataFilePath;
            this.historyFilePath = historyFilePath;
            this.acceptedCodes = acceptedCodes;
            this.alreadySentSubstring = alreadySentSubstring;
            this.defaultFailCode = defaultFailCode;
            this.codePage = codePage;
            this.nameTemplate = nameTemplate;
            this.fileNameTemplate = fileNameTemplate;
            this.reportNameTemplate = reportNameTemplate;
            this.reportProcess = reportProcess;
        }

        /** Carga/valida la seccion del INI. */
        static Config from(IniFile ini, String section) {
            Map<String,String> s = ini.section(section);
            if (s == null) throw new IllegalArgumentException("No existe la seccion ["+section+"].");

            String host = req(s, "host");
            int port = parseInt(s.get("port"), 1, 65535, "port");

            int connectTimeout = parseInt(s.getOrDefault("connectTimeoutMs","60000"), 1000, 300000, "connectTimeoutMs");
            int soTimeout = parseInt(s.getOrDefault("soTimeoutMs","60000"), 1000, 300000, "soTimeoutMs");
            int chunk = parseInt(s.getOrDefault("chunkSize","980"), 1, 65535, "chunkSize");

            String dataFileStr = s.getOrDefault("dataFilePath", "MIPFILE_DATI");
            String historyFileStr = s.getOrDefault("historyFilePath", "MIPFILE_HISTORY_R");

            List<String> acceptedList = parseList(s.getOrDefault("acceptedCode","9980100"));

            String already = s.getOrDefault("alreadySentSubstring","9288W");
            String failDef = s.getOrDefault("defaultFailCode","9980101");

            String codePageName = s.getOrDefault("codePage","Cp037");
            Charset cp;
            try { cp = Charset.forName(codePageName); }
            catch (Exception ex) { throw new IllegalArgumentException("codePage invalido: "+codePageName); }

            String nameTemplate = s.getOrDefault("nameTemplate", "00401{file}{julian}");
            String fileNameTemplate = s.get("fileNameTemplate");

            String reportNameTemplate = s.getOrDefault("reportNameTemplate", "10101{file}{julian}");
            String reportProcessStr   = s.getOrDefault("report.process", "Y");
            boolean reportProcess     = reportProcessStr.trim().equalsIgnoreCase("Y");

            Path dataPath = resolveAgainstCwd(dataFileStr);
            Path histPath = resolveAgainstCwd(historyFileStr);

            String trailer = pickTrailerCodeSeven(acceptedList);
            if (trailer == null) {
                throw new IllegalArgumentException("acceptedCode debe incluir al menos un valor de 7 caracteres para el trailer.");
            }

            logger.info("CWD (user.dir): " + Paths.get(System.getProperty("user.dir")).toAbsolutePath());
            logger.info("dataFilePath   : " + dataPath.toAbsolutePath());
            logger.info("historyFilePath: " + histPath.toAbsolutePath());

            return new Config(host, port, connectTimeout, soTimeout, chunk,
                              dataPath, histPath, acceptedList, already, failDef,
                              cp, nameTemplate, fileNameTemplate,
                              reportNameTemplate, reportProcess);
        }

        // Helpers de parseo ---------------------------------------------------
        private static Path resolveAgainstCwd(String p) {
            Path path = Paths.get(p);
            if (path.isAbsolute()) return path.normalize();
            return Paths.get(System.getProperty("user.dir")).resolve(p).normalize();
        }
        private static String req(Map<String,String> m, String key) {
            String v = m.get(key);
            if (v == null || v.trim().isEmpty()) throw new IllegalArgumentException("Falta "+key);
            return v.trim();
        }
        private static int parseInt(String s, int min, int max, String name) {
            try {
                int v = Integer.parseInt(s.trim());
                if (v < min || v > max) throw new IllegalArgumentException(name+" fuera de rango ["+min+","+max+"]");
                return v;
            } catch (NumberFormatException e) {
                throw new IllegalArgumentException(name+" no numerico: "+s);
            }
        }
        private static List<String> parseList(String csv) {
            List<String> out = new ArrayList<>();
            if (csv == null) return Collections.emptyList();
            for (String p : csv.split(",")) {
                String t = p.trim();
                if (!t.isEmpty()) out.add(t);
            }
            return out.isEmpty() ? Collections.emptyList() : Collections.unmodifiableList(out);
        }
        String firstAcceptedCodeOrDefault() {
            return acceptedCodes.isEmpty() ? defaultFailCode : acceptedCodes.get(0);
        }
        String trailerCodeSeven() {
            String t = pickTrailerCodeSeven(acceptedCodes);
            if (t == null) throw new IllegalArgumentException("acceptedCode debe incluir un valor de 7 caracteres para trailer.");
            return t;
        }
        private static String pickTrailerCodeSeven(List<String> codes) {
            if (codes == null) return null;
            for (String c : codes) {
                String t = (c == null ? "" : c.trim());
                if (t.length() == 7) return t;
            }
            return null;
        }
    }

    // ----------------------------- INI parser --------------------------------

    /**
     * Parser INI simple (UTF-8). Secciones [x] y pares k=v. Ignora lineas vacias y #/;.
     */
    static class IniFile {
        private final Map<String, Map<String,String>> data = new LinkedHashMap<>();
        private IniFile() {}
        static IniFile load(Path path) throws IOException {
            if (!Files.exists(path)) throw new NoSuchFileException(path.toString());
            IniFile f = new IniFile();
            Map<String,String> cur = null;
            try (BufferedReader br = Files.newBufferedReader(path, StandardCharsets.UTF_8)) {
                String line;
                while ((line = br.readLine()) != null) {
                    String ln = line.trim();
                    if (ln.isEmpty() || ln.startsWith("#") || ln.startsWith(";")) continue;
                    if (ln.startsWith("[") && ln.endsWith("]")) {
                        String sec = ln.substring(1, ln.length()-1).trim();
                        cur = f.data.computeIfAbsent(sec, k -> new LinkedHashMap<>());
                    } else {
                        int eq = ln.indexOf('=');
                        if (eq < 0 || cur == null) continue;
                        String k = ln.substring(0, eq).trim();
                        String v = ln.substring(eq+1).trim();
                        cur.put(k, v);
                    }
                }
            }
            return f;
        }
        Map<String,String> section(String name) { return data.get(name); }
    }

    // -------------------------------- Sender ---------------------------------

    /**
     * Orquesta Opcion 1 (envio) y Opcion 2 (reporte).
     */
    static class Sender {
        private final Config cfg;
        private final int option;
        private final String fileNameArg;
        private final String cliDateArg; // YYYYMMDD o null

        Sender(Config cfg, int option, String fileNameArg, String cliDateArg) {
            this.cfg = cfg;
            this.option = option;
            this.fileNameArg = fileNameArg;
            this.cliDateArg = cliDateArg;
        }

        /** Ejecuta la opcion seleccionada. */
        void run() {
            if (option == 1) runSend();
            else if (option == 2) runReport();
            else throw new IllegalArgumentException("OPCION invalida: " + option);
        }

        // --------------------------- Opcion 1: Envio ---------------------------

        /** Flujo de envio: valida, lee/parte, arma nombre, handshake, envia tramas y trailer, historico. */
        private void runSend() {
            logger.info("=== OPCION 1: Envio ===");

            validateEnvironmentForSend(cfg);

            byte[] payload = readPayload(cfg.dataFilePath);
            if (payload.length == 0) {
                logger.warning("El archivo de datos esta vacio: " + cfg.dataFilePath);
                createShippingHistory(cfg.defaultFailCode, "<NOFILE>", effectiveDate(cliDateArg), cfg.historyFilePath);
                return;
            }

            List<byte[]> parts = split(payload, cfg.chunkSize);
            logger.info("Partes a enviar: " + parts.size() + " (chunkSize=" + cfg.chunkSize + ")");

            String date = effectiveDate(cliDateArg);
            String effectiveFileName = (fileNameArg != null && !fileNameArg.isEmpty())
                    ? fileNameArg
                    : generateFileNameFromTemplate(cfg.fileNameTemplate, date);

            if (effectiveFileName == null || effectiveFileName.isEmpty()) {
                throw new IllegalArgumentException("No hay FILE_NAME: CLI o fileNameTemplate requerido.");
            }
            if (effectiveFileName.length() != 9) {
                throw new IllegalArgumentException("FILE_NAME efectivo debe tener 9 caracteres. Obtenido: '" + effectiveFileName + "'");
            }
            logger.info("FILE_NAME efectivo: " + effectiveFileName);

            String nameToSend = applyNameTemplate(cfg.nameTemplate, effectiveFileName, date);
            logger.info("Nombre a enviar: " + nameToSend);

            String finalStatus = cfg.defaultFailCode;
            try (Socket sock = new Socket()) {
                sock.connect(new InetSocketAddress(cfg.host, cfg.port), cfg.connectTimeoutMs);
                sock.setSoTimeout(cfg.soTimeoutMs);
                logger.info(String.format("Conectado a %s:%d (SO_TIMEOUT=%dms)", cfg.host, cfg.port, cfg.soTimeoutMs));

                // Envio de nombre
                writeNameFrame(sock, nameToSend, cfg.codePage);

                // Aprobacion
                String resp = readResponse(sock, cfg.codePage).trim();
                logger.info("Respuesta aprobacion: [" + resp + "]");

                if (!cfg.alreadySentSubstring.isEmpty() && resp.contains(cfg.alreadySentSubstring)) {
                    logger.info("Servidor indica 'ya enviado'.");
                    finalStatus = cfg.firstAcceptedCodeOrDefault();
                } else if (matchesAny(resp, cfg.acceptedCodes)) {
                    logger.info("*** Enviando Tramas... [CANT:" + parts.size() + "]");
                    for (byte[] p : parts) {
                        writeChunkFrame(sock, p, cfg.codePage);
                        logger.info("Enviando trama al MIP [OK]");
                    }

                    // Trailer 11B
                    writeTrailerFrame(sock, parts.size() + 1, cfg.codePage, cfg.trailerCodeSeven());

                    // Confirmacion final
                    logger.info("Esperando confirmacion final...");
                    String resp2 = readResponse(sock, cfg.codePage).trim();
                    logger.info("Confirmacion final: [" + resp2 + "]");
                    if (matchesAny(resp2, cfg.acceptedCodes)) {
                        finalStatus = cfg.firstAcceptedCodeOrDefault();
                        logger.info("RESULTADO DE ENVIO [OK]");
                    } else {
                        logger.warning("RESULTADO DE ENVIO [FAIL] (codigo final no coincide con acceptedCode)");
                    }
                } else {
                    logger.warning("Nombre rechazado por el hub.");
                }
            } catch (UnknownHostException e) {
                logger.severe("Host desconocido: " + e.getMessage());
            } catch (SocketTimeoutException e) {
                logger.severe("Timeout de socket: " + e.getMessage());
            } catch (ConnectException e) {
                logger.severe("No se pudo conectar a " + cfg.host + ":" + cfg.port + " - " + e.getMessage());
            } catch (IOException e) {
                logger.severe("IO de red fallo: " + e.getMessage());
            } catch (Exception e) {
                logger.severe("Error inesperado en envio: " + e.getMessage());
            } finally {
                createShippingHistory(finalStatus, effectiveFileName, date, cfg.historyFilePath);
            }

            logger.info("=== PROCESO FINALIZADO (OPCION 1) ===");
        }

        // --------------------------- Opcion 2: Reporte -------------------------

        /**
         * Flujo de reporte:
         * - Lee UN solo bloque por secuencia (01..99), como el original (one-shot 1024B filtrando).
         * - Si report.process=Y, procesa headers+details; si falla, fallback a crudo.
         * - Si report.process=N, escribe crudo.
         * - Imprime el nombre del archivo de reporte creado.
         */
        private void runReport() {
            logger.info("=== OPCION 2: Reporte ===");

            validateEnvironmentForReport();

            String date = effectiveDate(cliDateArg);
            String effectiveFileName = (fileNameArg != null && !fileNameArg.isEmpty())
                    ? fileNameArg
                    : generateFileNameFromTemplate(cfg.fileNameTemplate, date);

            if (effectiveFileName == null || effectiveFileName.isEmpty()) {
                throw new IllegalArgumentException("No hay FILE_NAME: CLI o fileNameTemplate requerido.");
            }
            if (effectiveFileName.length() != 9) {
                throw new IllegalArgumentException("FILE_NAME efectivo debe tener 9 caracteres. Obtenido: '" + effectiveFileName + "'");
            }
            logger.info("FILE_NAME efectivo: " + effectiveFileName);

            String nameBase = applyNameTemplate(cfg.reportNameTemplate, effectiveFileName, date);
            logger.info("Nombre base de reporte: " + nameBase);

            String acceptedFirst = cfg.firstAcceptedCodeOrDefault();
            boolean found = false;

            StringBuilder rawAcc = new StringBuilder();
            StringBuilder fmtAcc = new StringBuilder();

            try (Socket sock = new Socket()) {
                logger.info("[IP:" + cfg.host + "][PTO:" + cfg.port + "]");
                sock.connect(new InetSocketAddress(cfg.host, cfg.port), cfg.connectTimeoutMs);
                sock.setSoTimeout(cfg.soTimeoutMs);
                logger.info("Estado de conexion con MC: " + sock.isConnected());

                for (int i = 1; i <= 99; i++) {
                    String secStr = String.format("%02d", i);
                    String queryName = nameBase + secStr;

                    logger.info("*** Consultando archivo de respuesta a MC: " + queryName);
                    writeNameFrame(sock, queryName, cfg.codePage);

                    logger.info("*** Respuesta del MC: ");
                    rawAcc.setLength(0);
                    fmtAcc.setLength(0);

                    // Lectura one-shot como el legado
                    String chunk = readLegacyBlock(sock, cfg.codePage);
                    rawAcc.append(chunk);
                    fmtAcc.append("[").append(chunk).append("]\n");

                    if (containsAny(rawAcc.toString(), cfg.acceptedCodes)) {
                        logger.info("Archivo encontrado [OK]");
                        found = true;
                        break;
                    } else {
                        logger.info("Buscando...");
                    }
                }

                if (found) {
                    logger.info("*** Generando archivo de respuesta (Reporte)...");
                    String dataToWrite;
                    if (cfg.reportProcess) {
                        try {
                            dataToWrite = orderDetails(fmtAcc.toString(), acceptedFirst);
                        } catch (Exception ex) {
                            logger.severe("Ocurrio un error al ordenar el contenido del archivo: " + ex.getMessage());
                            dataToWrite = rawAcc.toString(); // fallback
                        }
                    } else {
                        dataToWrite = rawAcc.toString();
                    }

                    String reportName = writeDataToFile(date, dataToWrite, effectiveFileName);
                    if (reportName != null) {
                        logger.info("Reporte: " + reportName + "[GENERADO]");
                        logger.info("*** Reporte generado: [OK]");
                    } else {
                        logger.severe("No se pudo generar el reporte.");
                    }
                } else {
                    logger.severe("*** Respuesta del MIP: Archivo no encontrado [FAIL]");
                }
            } catch (UnknownHostException e) {
                logger.severe("Host desconocido: " + e.getMessage());
            } catch (SocketTimeoutException e) {
                logger.severe("Timeout de socket: " + e.getMessage());
            } catch (ConnectException e) {
                logger.severe("No se pudo conectar a " + cfg.host + ":" + cfg.port + " - " + e.getMessage());
            } catch (IOException e) {
                logger.severe("IO de red fallo: " + e.getMessage());
            } catch (Exception e) {
                logger.severe("Error inesperado en reporte: " + e.getMessage());
            }

            logger.info("=== PROCESO FINALIZADO (OPCION 2) ===");
        }

        // ----------------------------- Utilidades -----------------------------

        /** true si value coincide exactamente con algun elemento de options. */
        private static boolean matchesAny(String value, List<String> options) {
            if (options == null || options.isEmpty()) return false;
            for (String o : options) if (value.equals(o)) return true;
            return false;
        }

        /** true si hay algun acceptedCode contenido como substring. */
        private static boolean containsAny(String haystack, List<String> options) {
            if (options == null || options.isEmpty()) return false;
            for (String o : options) if (haystack.contains(o)) return true;
            return false;
        }

        /** Trailer final (11B): EBCDIC(7) + contador(4B BE). */
        private static void writeTrailerFrame(Socket s, int count, Charset ebcdic, String trailerCode7) throws IOException {
            if (trailerCode7 == null || trailerCode7.length() != 7) {
                throw new IllegalArgumentException("El codigo de trailer debe tener 7 caracteres.");
            }
            byte[] prefix = trailerCode7.getBytes(ebcdic);
            byte[] cnt = lengthToBytes(count, 4);
            byte[] body = new byte[11];
            System.arraycopy(prefix, 0, body, 0, 7);
            System.arraycopy(cnt,    0, body, 7, 4);
            writeFrameRaw(s, body);
        }

        /** FILE_NAME desde template: literal (9), {rand}=4 digitos, {ddmm}=dia+mes. */
        private static String generateFileNameFromTemplate(String template, String yyyymmdd) {
            if (template == null || template.trim().isEmpty()) {
                throw new IllegalArgumentException("fileNameTemplate no definido en el INI.");
            }
            String base = template.trim();
            LocalDate d = LocalDate.parse(yyyymmdd, DateTimeFormatter.BASIC_ISO_DATE);
            String ddmm = String.format("%02d%02d", d.getDayOfMonth(), d.getMonthValue());

            base = base.replaceAll("(?i)\\{ddmm\\}", ddmm);
            if (base.matches("(?i).*\\{rand\\}.*")) {
                String rand4 = String.format("%04d", new Random().nextInt(10000));
                base = base.replaceAll("(?i)\\{rand\\}", rand4);
            }
            base = base.toUpperCase(Locale.ROOT);
            if (base.length() != 9) {
                throw new IllegalArgumentException("fileNameTemplate debe producir 9 caracteres. Obtenido '" + base + "' (" + base.length() + ")");
            }
            return base;
        }

        /** Aplica plantilla: {file},{julian},{yyyymmdd},{yy},{mm},{dd} (case-insensitive). */
        private static String applyNameTemplate(String template, String fileName, String yyyymmdd) {
            LocalDate d = LocalDate.parse(yyyymmdd, DateTimeFormatter.BASIC_ISO_DATE);
            String julian = String.format("%03d", d.getDayOfYear());
            String yy = String.format("%02d", d.getYear() % 100);
            String mm = String.format("%02d", d.getMonthValue());
            String dd = String.format("%02d", d.getDayOfMonth());

            String out = template;
            out = out.replaceAll("(?i)\\{file\\}", java.util.regex.Matcher.quoteReplacement(fileName));
            out = out.replaceAll("(?i)\\{julian\\}", julian);
            out = out.replaceAll("(?i)\\{yyyymmdd\\}", yyyymmdd);
            out = out.replaceAll("(?i)\\{yy\\}", yy);
            out = out.replaceAll("(?i)\\{mm\\}", mm);
            out = out.replaceAll("(?i)\\{dd\\}", dd);
            return out;
        }

        /** Fecha efectiva YYYYMMDD (toma CLI si viene; si no, hoy). */
        private static String effectiveDate(String cliDate) {
            if (cliDate != null && validateDate(cliDate)) return cliDate;
            return LocalDate.now().format(DateTimeFormatter.BASIC_ISO_DATE);
        }

        /** Valida AAAAMMDD. */
        static boolean validateDate(String date) {
            try {
                DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyyMMdd");
                LocalDate.parse(date, formatter);
                return true;
            } catch (Exception e) {
                return false;
            }
        }

        /** Envia trama de nombre (texto->EBCDIC) con header(2B). */
        private static void writeNameFrame(Socket s, String text, Charset ebcdic) throws IOException {
            byte[] body = text.getBytes(ebcdic);
            writeFrameRaw(s, body);
        }

        /** Envia trama de datos con prefijo 'R' (ASCII), luego EBCDIC y header(2B). */
        private static void writeChunkFrame(Socket s, byte[] asciiChunk, Charset ebcdic) throws IOException {
            ByteArrayOutputStream baos = new ByteArrayOutputStream(1 + asciiChunk.length);
            baos.write((byte) 'R');
            baos.write(asciiChunk);
            String asText = new String(baos.toByteArray(), StandardCharsets.US_ASCII);
            byte[] body = asText.getBytes(ebcdic);
            writeFrameRaw(s, body);
        }

        /** Escribe header(2B) + body en socket (flush). */
        private static void writeFrameRaw(Socket s, byte[] body) throws IOException {
            int len = body.length;
            byte[] header = lengthToBytes(len, 2);
            OutputStream os = s.getOutputStream();
            os.write(header);
            os.write(body);
            os.flush();
        }

        /** Lee respuesta acumulativa (EBCDIC->String) hasta lectura corta o timeout con datos. */
        private static String readResponse(Socket s, Charset ebcdic) throws IOException {
            ByteArrayOutputStream baos = new ByteArrayOutputStream();
            InputStream is = s.getInputStream();
            byte[] buf = new byte[1024];
            int n;
            while (true) {
                try {
                    n = is.read(buf);
                    if (n == -1) break;
                    baos.write(buf, 0, n);
                    if (n < buf.length) break;
                } catch (SocketTimeoutException te) {
                    if (baos.size() == 0) throw te;
                    break;
                }
            }
            byte[] ebcdicBytes = baos.toByteArray();
            return new String(ebcdicBytes, ebcdic);
        }

        /** Lectura one-shot (como InSocket legacy): un read(1024), EBCDIC->String, filtrando imprimibles. */
        private static String readLegacyBlock(Socket s, Charset ebcdic) throws IOException {
            InputStream is = s.getInputStream();
            byte[] buf = new byte[1024];
            int n = is.read(buf, 0, 1024);
            if (n <= 0) return "";
            String decoded = new String(buf, 0, n, ebcdic);
            StringBuilder out = new StringBuilder(decoded.length());
            for (int i = 0; i < decoded.length(); i++) {
                char c = decoded.charAt(i);
                if (c >= ' ' && c <= '~') {
                    out.append(c);
                } else if (c == '\n') {
                    out.append('\n');
                }
            }
            return out.toString();
        }

        // ---------------------- Historico (solo Opcion 1) ----------------------

        /** Agrega registro al historico (prepend) y rota en dia 1. */
        private static void createShippingHistory(String respCode, String fileName, String dateYYYYMMDD, Path historyPath) {
            try {
                monthlyRotateIfFirstDay(historyPath);
                String record = formatHistory(respCode, fileName, dateYYYYMMDD, LocalDateTime.now());
                prependLine(historyPath, record);
                logger.info("Historico actualizado: " + historyPath);
            } catch (Exception e) {
                logger.severe("No se pudo actualizar el historico: " + e.getMessage());
            }
        }
        private static void monthlyRotateIfFirstDay(Path historyPath) {
            if (LocalDate.now().getDayOfMonth() == 1) {
                try {
                    Files.write(historyPath, new byte[0],
                            StandardOpenOption.CREATE, StandardOpenOption.TRUNCATE_EXISTING);
                } catch (IOException e) {
                    logger.warning("No se pudo rotar historico mensual: " + e.getMessage());
                }
            }
        }
        private static String formatHistory(String resp, String code, String fec, LocalDateTime now) {
            String ts = now.format(DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss"));
            return "[" + resp + "-" + code + "-" + fec + ": " + ts + "]";
        }
        private static void prependLine(Path path, String line) throws IOException {
            List<String> lines = new ArrayList<>();
            if (Files.exists(path)) {
                try {
                    lines = Files.readAllLines(path, StandardCharsets.UTF_8);
                } catch (MalformedInputException mie) {
                    lines = new ArrayList<>();
                }
            }
            lines.add(0, line);
            Files.write(path, String.join(System.lineSeparator(), lines).getBytes(StandardCharsets.UTF_8),
                    StandardOpenOption.CREATE, StandardOpenOption.TRUNCATE_EXISTING, StandardOpenOption.WRITE);
        }

        // ------------------ Helpers de reporte (Opcion 2) ---------------------

        /**
         * Escribe el archivo de reporte en el CWD y devuelve su nombre.
         */
        private static String writeDataToFile(String dateYYYYMMDD, String data, String fileName9) throws IOException {
            logger.info("Parametro date: " + dateYYYYMMDD + " (" + dateYYYYMMDD.length() + ")");
            if (!validateDate(dateYYYYMMDD)) {
                logger.severe("Fecha ingresada no es valida: " + dateYYYYMMDD);
                return null;
            }
            final String newName = getNameFileReport(dateYYYYMMDD, fileName9);
            logger.info("Generacion de nombre de reporte es valido: " + (newName != null));
            if (newName == null) {
                logger.severe("Nombre de reporte no pudo generarse.");
                return null;
            }
            logger.info("Creando reporte...");
            try (FileOutputStream reportFile = new FileOutputStream(newName);
                 PrintStream ps = new PrintStream(reportFile, true, "UTF-8")) {
                ps.print(data);
            }
            return newName;
        }

        /** Ordena headers + detalles (parser legacy). */
        private static String orderDetails(String dataMipDato, String allOkCode) {
            String headers = extractHeaders(dataMipDato);
            String details = extractDetails(dataMipDato, allOkCode);
            return headers + details;
        }

        /** Extrae cabeceras desde el bloque recibido (reglas legacy). */
        private static String extractHeaders(String data) {
            String header = data.replace(">", "").substring(0, 20) + "]\n";
            int firstIndexDetail = data.indexOf("16");
            String headerInfo;
            if (firstIndexDetail != -1) {
                headerInfo = data.substring(data.indexOf("12"), firstIndexDetail);
            } else {
                headerInfo = data.substring(data.indexOf("12"), data.indexOf("]", data.indexOf("12")));
            }
            return header + headerInfo;
        }

        /** Extrae detalles respetando anchos fijos (reglas legacy). */
        private static String extractDetails(String data, String allOkCode) {
            int firstIndexDetail = data.indexOf("16");
            StringBuilder detail = new StringBuilder();
            if (firstIndexDetail != -1) {
                String[] detailsData = data.substring(firstIndexDetail).replace("[", "").replace("]\n", "").split("D0");
                for (int i = 1; i < detailsData.length; i++) {
                    detail.append("16");
                    if (detailsData[i].substring(57).length() < 26) {
                        String codErrors = String.format("%26s", detailsData[i].substring(57).trim().substring(0, 15));
                        detail.append(detailsData[i].substring(0, 57)).append(codErrors);
                        continue;
                    }
                    if (i == detailsData.length - 1) {
                        if (detailsData[i].substring(57).length() < 26) {
                            String codErrors = String.format("%26s", detailsData[i].substring(57).trim().substring(0, 15));
                            detail.append(detailsData[i].substring(0, 57)).append(codErrors).append(allOkCode);
                        } else {
                            int codresp = detailsData[i].indexOf(allOkCode);
                            if (codresp != -1) {
                                detail.append(detailsData[i].substring(0, codresp + allOkCode.length()));
                            }
                        }
                        break;
                    }
                    detail.append(detailsData[i].substring(0, 83));
                }
                return detail.toString().replace("D0", "\nD0");
            }
            return detail.toString();
        }

        /** Nombre de archivo de reporte: NNNN-YYYYMMDD-Archivo de Cambio Confirmacion */
        private static String getNameFileReport(String dateYYYYMMDD, String fileName9) {
            final String description = "-Archivo de Cambio Confirmacion";
            DateTimeFormatter inputFormatter = DateTimeFormatter.ofPattern("yyyyMMdd");
            DateTimeFormatter outputFormatter = DateTimeFormatter.ofPattern("yyyyMMdd");
            String prefix = fileName9.substring(0, 4) + "-";
            try {
                LocalDate fecha = LocalDate.parse(dateYYYYMMDD, inputFormatter);
                return prefix + fecha.format(outputFormatter) + description;
            } catch (Exception e) {
                logger.severe("Parametro date(" + dateYYYYMMDD + ") incorrecto.");
                return null;
            }
        }

        // --------------------- IO/Permisos/Bytes utilities --------------------

        /** Log de permisos de un directorio. */
        private static void logDirPerms(String label, File dir) {
            logger.info(label + " (" + dir.getAbsolutePath() + "):");
            logger.info("Lectura: " + (dir.canRead() ? "Permitido" : "No permitido"));
            logger.info("Escritura: " + (dir.canWrite() ? "Permitido" : "No permitido"));
            logger.info("Ejecucion: " + (dir.canExecute() ? "Permitido" : "No permitido"));
        }

        /** Valida permisos requeridos para envio. */
        private static void validateEnvironmentForSend(Config cfg) {
            File cwd = new File(System.getProperty("user.dir"));
            logDirPerms("Directorio actual", cwd);
            if (!cwd.canRead() || !cwd.canExecute()) {
                throw new IllegalStateException("El directorio actual no tiene permisos suficientes (lectura y ejecucion).");
            }
            File dataFile = cfg.dataFilePath.toFile();
            if (!dataFile.exists() || !dataFile.isFile()) {
                throw new IllegalStateException("No existe el archivo de datos o no es regular: " + cfg.dataFilePath);
            }
            logger.info("Permisos del archivo de datos (" + dataFile.getName() + "):");
            logger.info("Lectura: " + (dataFile.canRead() ? "Permitido" : "No permitido"));
            logger.info("Escritura: " + (dataFile.canWrite() ? "Permitido" : "No permitido"));
            if (!dataFile.canRead()) {
                throw new IllegalStateException("No hay permisos de lectura sobre el archivo de datos: " + dataFile.getAbsolutePath());
            }
            File histFile = cfg.historyFilePath.toFile();
            File histDir  = histFile.getAbsoluteFile().getParentFile();
            if (histDir != null) {
                logDirPerms("Directorio del historico", histDir);
                if (!histDir.canWrite() || !histDir.canExecute()) {
                    throw new IllegalStateException("El directorio del historico no permite escribir/ejecutar: " + histDir.getAbsolutePath());
                }
            }
            try (FileChannel ignore = FileChannel.open(cfg.historyFilePath,
                    StandardOpenOption.CREATE, StandardOpenOption.WRITE, StandardOpenOption.APPEND)) {
                // OK
            } catch (IOException e) {
                throw new IllegalStateException("No se puede crear/escribir en el historico: " + cfg.historyFilePath + " - " + e.getMessage(), e);
            }
        }

        /** Valida permisos para reporte (necesita escribir en CWD). */
        private static void validateEnvironmentForReport() {
            File cwd = new File(System.getProperty("user.dir"));
            logDirPerms("Directorio actual", cwd);
            if (!cwd.canRead() || !cwd.canExecute() || !cwd.canWrite()) {
                throw new IllegalStateException("El directorio actual no tiene permisos suficientes (lectura/ejecucion/escritura) para generar el reporte.");
            }
        }

        /** Lee el payload desde disco. */
        private static byte[] readPayload(Path p) {
            logger.info("Leyendo payload: " + p.toAbsolutePath());
            try {
                byte[] data = Files.readAllBytes(p);
                logger.info("Tamano payload: " + data.length + " bytes");
                return data;
            } catch (AccessDeniedException e) {
                throw new RuntimeException("Sin permisos para leer: " + p, e);
            } catch (NoSuchFileException e) {
                throw new RuntimeException("No existe el archivo: " + p, e);
            } catch (IOException e) {
                throw new RuntimeException("Error leyendo archivo: " + p + " - " + e.getMessage(), e);
            }
        }

        /** Parte bytes en trozos de tamaño fijo. */
        private static List<byte[]> split(byte[] data, int chunkSize) {
            List<byte[]> parts = new ArrayList<>();
            int total = data.length;
            for (int off = 0; off < total; off += chunkSize) {
                int len = Math.min(chunkSize, total - off);
                parts.add(Arrays.copyOfRange(data, off, off + len));
            }
            return parts;
        }

        /** Entero sin signo a big-endian usando N bytes. */
        private static byte[] lengthToBytes(int num, int byts) {
            byte[] r = new byte[byts];
            for (int i = byts - 1; i >= 0; --i) {
                r[i] = (byte)(num & 0xFF);
                num >>>= 8;
            }
            return r;
        }
    }
}

