//=================================================================================================
// McBatchSender
//
// Proposito:
//   Envia un archivo por TCP (Opcion 1) y genera/descarga reportes (Opciones 2, 3, 4 y 5)
//   con un menu interactivo cuando se ejecuta sin parametros.
//
// Protocolo:
//   - Cada trama: header de 2 bytes (longitud big-endian) + cuerpo en EBCDIC (conversion manual).
//   - Opcion 1 (envio): cada parte se envia con prefijo ASCII 'R' y luego se convierte a EBCDIC.
//     Trailer final: 11 bytes = EBCDIC(acceptedCode de 7 chars) + contador(4B con translateByteForDiscrepancy).
//
// Flujo (resumen):
//   Opcion 1 (Envio):
//     - Valida entorno, lee/pieza archivo, arma nombre con plantilla, handshake, envia tramas,
//       trailer, confirmacion final, historico.
//
//   Opcion 2 (Reporte MIP):
//     - Arma base "reportNameTemplate", consulta secuencias 01..99.
//     - Si parsear=Y: procesa headers+details (robusto). Si N: guarda crudo.
//     - Genera archivo: NNNN-YYYYMMDD-Archivo de Cambio Confirmacion.
//
//   Opcion 3 (Descarga T120) y 4 (Descarga T112):
//     - Descarga crudo del nombre:
//       YTF.AR.T{120|112}.F.E0002840.D{YYMMDD}.T{HHMMSS}.A001
//
//   Opcion 5 (Descarga por nombre completo - MANUAL):
//     - NO usa INI. Requiere IP, PUERTO y NOMBRE COMPLETO por parametros o por submenu.
//       Envia exactamente el nombre completo que indiques y guarda crudo.
//
// Parametrizacion (INI):
//   - host, port, connectTimeoutMs, soTimeoutMs, chunkSize
//   - dataFilePath, historyFilePath
//   - acceptedCode (lista separada por comas; uno de 7 chars se usa en trailer)
//   - alreadySentSubstring, defaultFailCode
//   - date (YYYYMMDD opcional para plantillas; ignorada si CLI/menu define fecha)
//   - nameTemplate (ej: "00401{file}{julian}")
//   - fileNameTemplate (si no pasas FILE_NAME: literal 9, o RXXXX + {rand}/{ddmm} -> 9 chars)
//   - reportNameTemplate (ej: "10101{file}{julian}")
//   - report.process=Y|N (Y=procesa headers+details; N=escribe crudo)
//   *** Nota: YA NO se usa "codePage" del INI. ***
//
// Uso por parametros:
//   - Opcion 1/2: java McBatchSender <OPC> <SECCION> <FILE_NAME> <DATE>
//   - Opcion 3/4: java McBatchSender <OPC> <SECCION> <HHMMSS> <DATE>
//   - Opcion 5  : java McBatchSender 5 <IP> <PUERTO> <FULL_NAME>
//
// Uso sin parametros: menu interactivo.
//
// Codigos de salida:
//   0=OK | 1=error inesperado | 2=uso invalido | 3=INI no encontrado | 4=INI/argumento invalido
//=================================================================================================

import java.io.*;
import java.net.*;
import java.nio.charset.MalformedInputException;
import java.nio.charset.StandardCharsets;
import java.nio.file.*;
import java.nio.channels.FileChannel;
import java.time.*;
import java.time.format.DateTimeFormatter;
import java.util.*;
import java.util.logging.Logger;

public class McBatchSender {
    private static final Logger logger = Logger.getLogger(McBatchSender.class.getName());

    // Entidad fija para opciones 3/4
    private static final String FIXED_ENTITY_Txx = "E0002840";
    // Defaults para opcion 5 (manual)
    private static final int DEFAULT_CONNECT_TIMEOUT_MS = 60000;
    private static final int DEFAULT_SO_TIMEOUT_MS = 60000;
    private static final List<String> DEFAULT_ACCEPTED_CODES = Collections.singletonList("9980100");

    // -------- Util compartido --------

    private static boolean validateDate(String date) {
        DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyyMMdd");
        try { LocalDate.parse(date, formatter); return true; } catch (Exception e) { return false; }
    }
    private static boolean validateHHMMSS(String hhmmss) {
        if (hhmmss == null || !hhmmss.matches("\\d{6}")) return false;
        int hh = Integer.parseInt(hhmmss.substring(0,2));
        int mm = Integer.parseInt(hhmmss.substring(2,4));
        int ss = Integer.parseInt(hhmmss.substring(4,6));
        return (hh >= 0 && hh <= 23) && (mm >= 0 && mm <= 59) && (ss >= 0 && ss <= 59);
    }

    public static void main(String[] args) {
        final String iniPath = System.getProperty("mcsender.config", "mcsender.ini");
        final Path ini = Paths.get(iniPath);

        if (args.length == 0) {
            try {
                IniFile cfgFile = null;
                try {
                    cfgFile = IniFile.load(ini);
                } catch (NoSuchFileException nf) {
                    cfgFile = new IniFile();
                }
                Interactive.runInteractive(cfgFile);
                System.exit(0);
            } catch (Exception e) {
                System.err.println("Error inesperado en modo interactivo: " + e.getMessage());
                System.exit(1);
            }
        }

        final String optionStr = args[0].trim();
        final int option;
        try { option = Integer.parseInt(optionStr); }
        catch (NumberFormatException nfe) {
            System.err.println("OPCION debe ser 1, 2, 3, 4 o 5. Valor: '" + optionStr + "'");
            System.exit(4); return;
        }
        if (option < 1 || option > 5) {
            System.err.println("OPCION invalida. Use 1, 2, 3, 4 o 5.");
            System.exit(4);
        }

        boolean isTxx = (option == 3 || option == 4);
        boolean isManual = (option == 5);

        String section = null;
        String nameParam;
        String date;
        String manualHost = null;
        Integer manualPort = null;

        if (option == 1 || option == 2) {
            if (args.length != 4) {
                System.err.println("Uso Opcion 1/2: java McBatchSender <OPC> <SECCION> <FILE_NAME> <DATE>");
                System.exit(2);
            }
            section = args[1].trim();
            nameParam = args[2].trim().toUpperCase();
            date = args[3].trim();
            if (!validateDate(date)) {
                System.err.println("DATE debe ser AAAAMMDD. Valor: '" + date + "'");
                System.exit(4);
            }
        } else if (isTxx) {
            if (args.length != 4) {
                System.err.println("Uso Opcion 3/4: java McBatchSender <OPC> <SECCION> <HHMMSS> <DATE>");
                System.exit(2);
            }
            section   = args[1].trim();
            nameParam = args[2].trim();
            date      = args[3].trim();
            if (!validateHHMMSS(nameParam)) {
                System.err.println("HHMMSS invalido. Debe ser 6 digitos. Valor: '" + nameParam + "'");
                System.exit(4);
            }
            if (!validateDate(date)) {
                System.err.println("DATE debe ser AAAAMMDD. Valor: '" + date + "'");
                System.exit(4);
            }
        } else {
            if (args.length != 4) {
                System.err.println("Uso Opcion 5: java McBatchSender 5 <IP> <PUERTO> <FULL_NAME>");
                System.exit(2);
            }
            manualHost = args[1].trim();
            try {
                manualPort = Integer.parseInt(args[2].trim());
            } catch (NumberFormatException nfe) {
                System.err.println("PUERTO invalido. Valor: '" + args[2] + "'");
                System.exit(4); return;
            }
            nameParam  = args[3].trim();
            date       = LocalDate.now().format(DateTimeFormatter.BASIC_ISO_DATE);
        }

        try {
            Config cfg = null;
            if (!isManual) {
                IniFile cfgFile = IniFile.load(ini);
                cfg = Config.from(cfgFile, section);

                logger.info("OPCION: " + option);
                logger.info("Seccion: " + section);
                logger.info("Host: " + cfg.host);
                logger.info("Puerto: " + cfg.port);
                logger.info("nameTemplate: " + cfg.nameTemplate);
                logger.info("acceptedCodes: " + cfg.acceptedCodes);
                logger.info("trailerCode (7 chars): " + cfg.trailerCodeSeven());
                logger.info("reportNameTemplate: " + cfg.reportNameTemplate + " | report.process=" + (cfg.reportProcess ? "Y" : "N"));
            } else {
                logger.info("OPCION: 5 (manual)");
                logger.info("Host manual: " + manualHost);
                logger.info("Puerto manual: " + manualPort);
                logger.info("FullName: " + nameParam);
            }

            Boolean parseOverride = null;
            new Sender(cfg, option, nameParam, date, parseOverride, manualHost, manualPort, DEFAULT_ACCEPTED_CODES).run();
            System.exit(0);
        } catch (NoSuchFileException e) {
            System.err.println("No se encontro el archivo de configuracion: " + e.getFile());
            System.exit(3);
        } catch (IllegalArgumentException e) {
            System.err.println("Configuracion/argumento invalido: " + e.getMessage());
            System.exit(4);
        } catch (Exception e) {
            System.err.println("Error inesperado: " + e.getMessage());
            System.exit(1);
        }
    }

    // -------------------------------- Interactivo --------------------------------

    static class Interactive {
        static void runInteractive(IniFile cfgFile) throws Exception {
            Scanner sc = new Scanner(System.in);

            List<String> sections = cfgFile.sectionNames();

            System.out.println("\n=== McBatchSender (Modo Interactivo) ===");
            if (sections.isEmpty()) {
                System.out.println("No se encontraron secciones en mcsender.ini (solo funcionara la opcion 5 manual).");
            } else {
                System.out.println("Secciones disponibles: " + String.join(", ", sections));
            }

            System.out.println("\nOpciones:");
            System.out.println("  1) Envio (envia archivo de datos)");
            System.out.println("  2) Reporte MIP (consulta 10101...)");
            System.out.println("  3) Descarga T120 (YTF.AR.T120.F.E0002840.DYYMMDD.THHMMSS.A001)");
            System.out.println("  4) Descarga T112 (YTF.AR.T112.F.E0002840.DYYMMDD.THHMMSS.A001)");
            System.out.println("  5) Descarga por nombre completo (manual: IP, puerto, nombre)");
            int option = askInt(sc, "Ingrese la opcion [1-5]: ", 1, 5);

            String fileNameArg = null;
            String hhmmss = null;
            String fullName = null;
            String date;
            String section = null;
            Config cfg = null;

            if (option == 5) {
                String ip = askString(sc, "Ingrese IP del servidor: ").trim();
                int port  = askInt(sc, "Ingrese PUERTO: ", 1, 65535);
                fullName  = askString(sc, "Ingrese FULL_NAME a consultar (tal cual): ").trim();
                if (fullName.isEmpty()) throw new IllegalArgumentException("Nombre completo vacio.");

                date = LocalDate.now().format(DateTimeFormatter.BASIC_ISO_DATE);

                System.out.println("\nResumen:");
                System.out.println("  Opcion: 5 (manual)");
                System.out.println("  Host: " + ip);
                System.out.println("  Puerto: " + port);
                System.out.println("  FULL_NAME: " + fullName);
                System.out.println();

                new Sender(null, 5, fullName, date, null, ip, port, DEFAULT_ACCEPTED_CODES).run();
                return;
            }

            if (sections.isEmpty()) {
                throw new IllegalArgumentException("No hay INI cargado. Las opciones 1-4 requieren seccion.");
            }

            section = askString(sc, "Ingrese la seccion (ej. " + sections.get(0) + "): ").trim();
            if (cfgFile.section(section) == null) {
                throw new IllegalArgumentException("La seccion [" + section + "] no existe en el INI.");
            }
            cfg = Config.from(cfgFile, section);

            if (option == 1 || option == 2) {
                String tpl = cfg.fileNameTemplate;
                String hoy = LocalDate.now().format(DateTimeFormatter.BASIC_ISO_DATE);
                String ejemplo = "<no disponible>";
                if (tpl != null && !tpl.trim().isEmpty()) {
                    try { ejemplo = Sender.generateFileNameFromTemplate(tpl, hoy); }
                    catch (Exception e) { ejemplo = "<template invalido: " + e.getMessage() + ">"; }
                }
                System.out.println("\nPatron del nombre por defecto (fileNameTemplate): " + tpl);
                System.out.println("Ejemplo (hoy " + hoy + "): " + ejemplo);

                boolean usarTemplate = askYesNo(sc, "Desea usar el nombre por defecto segun el patron? (S/N) ");
                if (!usarTemplate) {
                    fileNameArg = askString(sc, "Ingrese FILE_NAME (cualquier longitud): ").trim().toUpperCase();
                    if (fileNameArg.isEmpty()) fileNameArg = null;
                }
            } else if (option == 3 || option == 4) {
                while (true) {
                    hhmmss = askString(sc, "Ingrese HHMMSS (6 digitos): ").trim();
                    if (validateHHMMSS(hhmmss)) break;
                    System.out.println("HHMMSS invalido. Intente de nuevo.");
                }
            }

            if (option == 1 || option == 2 || option == 3 || option == 4) {
                while (true) {
                    date = askString(sc, "Ingrese DATE (AAAAMMDD): ").trim();
                    if (validateDate(date)) break;
                    System.out.println("Fecha invalida. Intente de nuevo.");
                }
            } else {
                date = LocalDate.now().format(DateTimeFormatter.BASIC_ISO_DATE);
            }

            Boolean parseOverride = null;
            if (option == 2) {
                boolean parse = askYesNo(sc, "Para el reporte, desea parsear (ordenar) el contenido? (S/N) ");
                parseOverride = parse;
            }

            System.out.println("\nResumen:");
            System.out.println("  Opcion: " + option);
            System.out.println("  Seccion: " + section);
            if (option == 1 || option == 2)
                System.out.println("  FILE_NAME: " + (fileNameArg == null ? "<template INI>" : fileNameArg));
            if (option == 3 || option == 4)
                System.out.println("  HHMMSS: " + hhmmss);
            if (option != 5)
                System.out.println("  DATE: " + date);
            if (option == 2) System.out.println("  Reporte (parsear): " + (parseOverride ? "SI" : "NO"));
            System.out.println();

            String nameParam;
            if (option == 3 || option == 4) nameParam = hhmmss;
            else                            nameParam = fileNameArg;

            new Sender(cfg, option, nameParam, date, parseOverride, null, null, DEFAULT_ACCEPTED_CODES).run();
        }

        private static int askInt(Scanner sc, String prompt, int min, int max) {
            while (true) {
                System.out.print(prompt);
                String s = sc.nextLine().trim();
                try { int v = Integer.parseInt(s); if (v < min || v > max) throw new NumberFormatException(); return v; }
                catch (NumberFormatException e) { System.out.println("Valor invalido. Ingrese un numero entre " + min + " y " + max + "."); }
            }
        }
        private static String askString(Scanner sc, String prompt) {
            System.out.print(prompt);
            return sc.nextLine();
        }
        private static boolean askYesNo(Scanner sc, String prompt) {
            while (true) {
                System.out.print(prompt);
                String s = sc.nextLine().trim().toUpperCase(Locale.ROOT);
                if (s.equals("S") || s.equals("SI") || s.equals("Y") || s.equals("YES")) return true;
                if (s.equals("N") || s.equals("NO")) return false;
                System.out.println("Responda S/N.");
            }
        }
    }

    // -------------------------------- Config --------------------------------

    static class Config {
        final String host;
        final int port;
        final int connectTimeoutMs;
        final int soTimeoutMs;
        final int chunkSize;
        final Path dataFilePath;
        final Path historyFilePath;
        final List<String> acceptedCodes;
        final String alreadySentSubstring;
        final String defaultFailCode;
        final String dateOverride;
        final String nameTemplate;
        final String fileNameTemplate;
        final String reportNameTemplate;
        final boolean reportProcess;

        private Config(String host, int port, int connectTimeoutMs, int soTimeoutMs, int chunkSize,
                       Path dataFilePath, Path historyFilePath, List<String> acceptedCodes,
                       String alreadySentSubstring, String defaultFailCode,
                       String dateOverride,
                       String nameTemplate, String fileNameTemplate,
                       String reportNameTemplate, boolean reportProcess) {
            this.host = host;
            this.port = port;
            this.connectTimeoutMs = connectTimeoutMs;
            this.soTimeoutMs = soTimeoutMs;
            this.chunkSize = chunkSize;
            this.dataFilePath = dataFilePath;
            this.historyFilePath = historyFilePath;
            this.acceptedCodes = acceptedCodes;
            this.alreadySentSubstring = alreadySentSubstring;
            this.defaultFailCode = defaultFailCode;
            this.dateOverride = dateOverride;
            this.nameTemplate = nameTemplate;
            this.fileNameTemplate = fileNameTemplate;
            this.reportNameTemplate = reportNameTemplate;
            this.reportProcess = reportProcess;
        }

        static Config from(IniFile ini, String section) {
            Map<String,String> s = ini.section(section);
            if (s == null) throw new IllegalArgumentException("No existe la seccion ["+section+"].");

            String host = req(s, "host");
            int port = parseInt(s.get("port"), 1, 65535, "port");
            int connectTimeout = parseInt(s.getOrDefault("connectTimeoutMs","60000"), 1000, 300000, "connectTimeoutMs");
            int soTimeout = parseInt(s.getOrDefault("soTimeoutMs","60000"), 1000, 300000, "soTimeoutMs");
            int chunk = parseInt(s.getOrDefault("chunkSize","980"), 1, 65535, "chunkSize");

            String dataFileStr = s.getOrDefault("dataFilePath", "MIPFILE_DATI");
            String historyFileStr = s.getOrDefault("historyFilePath", "MIPFILE_HISTORY_R");

            List<String> acceptedList = parseList(s.getOrDefault("acceptedCode","9980100"));
            String already = s.getOrDefault("alreadySentSubstring","9288W");
            String failDef = s.getOrDefault("defaultFailCode","9980101");

            String dateOverride = s.get("date");

            String nameTemplate = s.getOrDefault("nameTemplate", "00401{file}{julian}");
            String fileNameTemplate = s.get("fileNameTemplate");

            String reportNameTemplate = s.getOrDefault("reportNameTemplate", "10101{file}{julian}");
            String reportProcessStr   = s.getOrDefault("report.process", "Y");
            boolean reportProcess     = reportProcessStr.trim().equalsIgnoreCase("Y");

            Path dataPath = resolveAgainstCwd(dataFileStr);
            Path histPath = resolveAgainstCwd(historyFileStr);

            String trailer = pickTrailerCodeSeven(acceptedList);
            if (trailer == null) {
                throw new IllegalArgumentException("acceptedCode debe incluir al menos un valor de 7 caracteres para el trailer.");
            }

            logger.info("CWD (user.dir): " + Paths.get(System.getProperty("user.dir")).toAbsolutePath());
            logger.info("dataFilePath   : " + dataPath.toAbsolutePath());
            logger.info("historyFilePath: " + histPath.toAbsolutePath());

            return new Config(host, port, connectTimeout, soTimeout, chunk,
                              dataPath, histPath, acceptedList, already, failDef,
                              dateOverride, nameTemplate, fileNameTemplate,
                              reportNameTemplate, reportProcess);
        }

        private static Path resolveAgainstCwd(String p) {
            Path path = Paths.get(p);
            if (path.isAbsolute()) return path.normalize();
            return Paths.get(System.getProperty("user.dir")).resolve(p).normalize();
        }
        private static String req(Map<String,String> m, String key) {
            String v = m.get(key);
            if (v == null || v.trim().isEmpty()) throw new IllegalArgumentException("Falta "+key);
            return v.trim();
        }
        private static int parseInt(String s, int min, int max, String name) {
            try {
                int v = Integer.parseInt(s.trim());
                if (v < min || v > max) throw new IllegalArgumentException(name+" fuera de rango ["+min+","+max+"]");
                return v;
            } catch (NumberFormatException e) {
                throw new IllegalArgumentException(name+" no numerico: "+s);
            }
        }
        private static List<String> parseList(String csv) {
            List<String> out = new ArrayList<>();
            if (csv == null) return Collections.emptyList();
            for (String p : csv.split(",")) {
                String t = p.trim();
                if (!t.isEmpty()) out.add(t);
            }
            return out.isEmpty() ? Collections.emptyList() : Collections.unmodifiableList(out);
        }
        String firstAcceptedCodeOrDefault() {
            return acceptedCodes.isEmpty() ? defaultFailCode : acceptedCodes.get(0);
        }
        String trailerCodeSeven() {
            String t = pickTrailerCodeSeven(acceptedCodes);
            if (t == null) throw new IllegalArgumentException("acceptedCode debe incluir un valor de 7 caracteres para trailer.");
            return t;
        }
        private static String pickTrailerCodeSeven(List<String> codes) {
            if (codes == null) return null;
            for (String c : codes) {
                String t = (c == null ? "" : c.trim());
                if (t.length() == 7) return t;
            }
            return null;
        }
    }

    // ----------------------------- INI simple -----------------------------

    static class IniFile {
        private final Map<String, Map<String,String>> data = new LinkedHashMap<>();
        IniFile() {}
        static IniFile load(Path path) throws IOException {
            if (!Files.exists(path)) throw new NoSuchFileException(path.toString());
            IniFile f = new IniFile();
            Map<String,String> cur = null;
            try (BufferedReader br = Files.newBufferedReader(path, StandardCharsets.UTF_8)) {
                String line;
                while ((line = br.readLine()) != null) {
                    String ln = line.trim();
                    if (ln.isEmpty() || ln.startsWith("#") || ln.startsWith(";")) continue;
                    if (ln.startsWith("[") && ln.endsWith("]")) {
                        String sec = ln.substring(1, ln.length()-1).trim();
                        cur = f.data.computeIfAbsent(sec, k -> new LinkedHashMap<>());
                    } else {
                        int eq = ln.indexOf('=');
                        if (eq < 0 || cur == null) continue;
                        String k = ln.substring(0, eq).trim();
                        String v = ln.substring(eq+1).trim();
                        cur.put(k, v);
                    }
                }
            }
            return f;
        }
        Map<String,String> section(String name) { return data.get(name); }
        List<String> sectionNames() { return new ArrayList<>(data.keySet()); }
    }

    // ------------------------------ Sender ------------------------------

    static class Sender {
        private final Config cfg;
        private final int option;
        private final String fileNameOrParam; // 1/2: FILE_NAME; 3/4: HHMMSS; 5: FULL_NAME
        private final String date;            // AAAAMMDD (no usado en 5)
        private final Boolean reportProcessOverride;

        private final String manualHost;
        private final Integer manualPort;
        private final List<String> manualAcceptedCodes;

        Sender(Config cfg,
               int option,
               String fileNameOrParam,
               String cliDateParam,
               Boolean reportProcessOverride,
               String manualHost,
               Integer manualPort,
               List<String> manualAcceptedCodes) {
            this.cfg = cfg;
            this.option = option;
            this.fileNameOrParam = (fileNameOrParam == null || fileNameOrParam.isEmpty())
                    ? null : (option == 5 ? fileNameOrParam : fileNameOrParam.toUpperCase());
            this.reportProcessOverride = reportProcessOverride;

            if (option == 5) {
                this.date = LocalDate.now().format(DateTimeFormatter.BASIC_ISO_DATE);
            } else {
                String cfgDate = (cfg != null ? cfg.dateOverride : null);
                this.date = (cliDateParam != null && validateDate(cliDateParam))
                        ? cliDateParam
                        : (cfgDate != null && validateDate(cfgDate)
                            ? cfgDate
                            : LocalDate.now().format(DateTimeFormatter.BASIC_ISO_DATE));
                logger.info("Fecha efectiva: " + this.date);
            }

            this.manualHost = manualHost;
            this.manualPort = manualPort;
            this.manualAcceptedCodes = (manualAcceptedCodes == null || manualAcceptedCodes.isEmpty())
                    ? DEFAULT_ACCEPTED_CODES : manualAcceptedCodes;
        }

        void run() {
            if (option == 1) runSend();
            else if (option == 2) runReport();
            else if (option == 3) runDownloadByNomenclature(120);
            else if (option == 4) runDownloadByNomenclature(112);
            else if (option == 5) runDownloadByExactNameManual();
            else throw new IllegalArgumentException("OPCION invalida: " + option);
        }

        // --------------------------- Opcion 1: Envio ---------------------------

        private void runSend() {
            logger.info("=== OPCION 1: Envio ===");
            if (cfg == null) throw new IllegalStateException("Config requerida para opcion 1.");

            validateEnvironmentForSend(cfg);

            byte[] payload = readPayload(cfg.dataFilePath);
            if (payload.length == 0) {
                logger.warning("El archivo de datos esta vacio: " + cfg.dataFilePath);
                createShippingHistory(cfg.defaultFailCode, "<NOFILE>", this.date, cfg.historyFilePath);
                return;
            }

            List<byte[]> parts = split(payload, cfg.chunkSize);
            logger.info("Partes a enviar: " + parts.size() + " (chunkSize=" + cfg.chunkSize + ")");

            String effectiveFileName = (fileNameOrParam != null) ? fileNameOrParam
                    : generateFileNameFromTemplate(cfg.fileNameTemplate, this.date);

            if (effectiveFileName == null || effectiveFileName.isEmpty()) {
                throw new IllegalArgumentException("No hay FILE_NAME: CLI/menu o fileNameTemplate requerido.");
            }
            logger.info("FILE_NAME efectivo: " + effectiveFileName);

            String nameToSend = applyNameTemplate(cfg.nameTemplate, effectiveFileName, this.date);
            logger.info("Nombre a enviar: " + nameToSend);

            String finalStatus = cfg.defaultFailCode;
            try (Socket sock = new Socket()) {
                sock.connect(new InetSocketAddress(cfg.host, cfg.port), cfg.connectTimeoutMs);
                sock.setSoTimeout(cfg.soTimeoutMs);
                logger.info(String.format("Conectado a %s:%d (SO_TIMEOUT=%dms)", cfg.host, cfg.port, cfg.soTimeoutMs));

                // Envio de nombre (EBCDIC manual)
                writeNameFrame(sock, nameToSend);

                // Aprobacion
                String resp = readResponse(sock).trim();
                logger.info("Respuesta aprobacion: [" + resp + "]");

                if (!cfg.alreadySentSubstring.isEmpty() && resp.contains(cfg.alreadySentSubstring)) {
                    logger.info("Servidor indica 'ya enviado'.");
                    finalStatus = cfg.firstAcceptedCodeOrDefault();
                } else if (matchesAny(resp, cfg.acceptedCodes)) {
                    logger.info("*** Enviando Tramas... [CANT:" + parts.size() + "]");
                    for (byte[] p : parts) {
                        writeChunkFrame(sock, p);
                        logger.info("Trama enviada [OK]");
                    }

                    // Trailer 11B (EBCDIC manual + discrepancy para contador)
                    writeTrailerFrame(sock, parts.size() + 1, cfg.trailerCodeSeven());

                    // Confirmacion final
                    logger.info("Esperando confirmacion final...");
                    String resp2 = readResponse(sock).trim();
                    logger.info("Confirmacion final: [" + resp2 + "]");
                    if (matchesAny(resp2, cfg.acceptedCodes)) {
                        finalStatus = cfg.firstAcceptedCodeOrDefault();
                        logger.info("RESULTADO DE ENVIO [OK]");
                    } else {
                        logger.warning("RESULTADO DE ENVIO [FAIL] (codigo final no coincide)");
                    }
                } else {
                    logger.warning("Nombre rechazado por el hub.");
                }
            } catch (Exception e) {
                logger.severe("Error en envio: " + e.getMessage());
            } finally {
                createShippingHistory(finalStatus, effectiveFileName, this.date, cfg.historyFilePath);
            }

            logger.info("=== FIN OPCION 1 ===");
        }

        // --------------------------- Opcion 2: Reporte -------------------------

        private void runReport() {
            logger.info("=== OPCION 2: Reporte ===");
            if (cfg == null) throw new IllegalStateException("Config requerida para opcion 2.");

            validateEnvironmentForReport();

            String effectiveFileName = (fileNameOrParam != null) ? fileNameOrParam
                    : generateFileNameFromTemplate(cfg.fileNameTemplate, this.date);

            if (effectiveFileName == null || effectiveFileName.isEmpty()) {
                throw new IllegalArgumentException("No hay FILE_NAME: CLI/menu o fileNameTemplate requerido.");
            }
            logger.info("FILE_NAME efectivo: " + effectiveFileName);

            String nameBase = applyNameTemplate(cfg.reportNameTemplate, effectiveFileName, this.date);
            logger.info("Nombre base de reporte: " + nameBase);

            String acceptedFirst = cfg.firstAcceptedCodeOrDefault();
            boolean found = false;

            StringBuilder finalRaw = new StringBuilder();
            StringBuilder finalFmt = new StringBuilder();

            try (Socket sock = new Socket()) {
                logger.info("[IP:" + cfg.host + "][PTO:" + cfg.port + "]");
                sock.connect(new InetSocketAddress(cfg.host, cfg.port), cfg.connectTimeoutMs);
                sock.setSoTimeout(cfg.soTimeoutMs);
                logger.info("Estado de conexion con el MIP: " + sock.isConnected());

                for (int i = 1; i <= 99; i++) {
                    String secStr = String.format("%02d", i);
                    String queryName = nameBase + secStr;

                    logger.info("*** Consultando: " + queryName);
                    writeNameFrame(sock, queryName);

                    StringBuilder rawAcc = new StringBuilder();
                    StringBuilder fmtAcc = new StringBuilder();

                    boolean moreData = true;
                    while (moreData) {
                        String chunk = readLegacyBlock(sock);
                        fmtAcc.append('[').append(chunk).append("]\n");
                        rawAcc.append(chunk);

                        if (chunk.isEmpty() || containsAnyAcceptedPrefix(fmtAcc.toString(), cfg.acceptedCodes)) {
                            moreData = false;
                        }
                    }

                    if (containsAny(rawAcc.toString(), cfg.acceptedCodes)) {
                        logger.info("Archivo encontrado [OK]");
                        found = true;
                        finalRaw.setLength(0);
                        finalFmt.setLength(0);
                        finalRaw.append(rawAcc);
                        finalFmt.append(fmtAcc);
                        break;
                    } else {
                        logger.info("Buscando...");
                    }
                }

                if (found) {
                    logger.info("*** Generando archivo de respuesta...");
                    String dataToWrite;
                    boolean process = (reportProcessOverride != null) ? reportProcessOverride : cfg.reportProcess;
                    if (process) {
                        try {
                            dataToWrite = orderDetails(finalFmt.toString(), acceptedFirst);
                        } catch (Exception ex) {
                            logger.severe("Error al ordenar contenido: " + ex.getMessage());
                            dataToWrite = finalRaw.toString();
                        }
                    } else {
                        dataToWrite = finalRaw.toString();
                    }

                    writeDataToFile(this.date, dataToWrite, effectiveFileName);
                    logger.info("*** Reporte generado [OK]");
                } else {
                    logger.severe("*** Archivo no encontrado [FAIL]");
                }
            } catch (Exception e) {
                logger.severe("Error en reporte: " + e.getMessage());
            }

            logger.info("=== FIN OPCION 2 ===");
        }

        // ---------------------- Opcion 3/4: Descarga T120/T112 -----------------

        private void runDownloadByNomenclature(int tCode) {
            logger.info("=== OPCION " + (tCode == 120 ? "3" : "4") + ": Descarga T" + tCode + " ===");
            if (cfg == null) throw new IllegalStateException("Config requerida para opcion " + (tCode == 120 ? "3" : "4") + ".");

            if (fileNameOrParam == null || !validateHHMMSS(fileNameOrParam)) {
                throw new IllegalArgumentException("HHMMSS invalido o ausente.");
            }
            String hhmmss = fileNameOrParam;

            LocalDate d = LocalDate.parse(this.date, DateTimeFormatter.BASIC_ISO_DATE);
            String yymmdd = String.format("%02d%02d%02d", d.getYear() % 100, d.getMonthValue(), d.getDayOfMonth());

            String queryName = "YTF.AR.T" + tCode + ".F." + FIXED_ENTITY_Txx + ".D" + yymmdd + ".T" + hhmmss + ".A001";
            logger.info("Nombre a solicitar: " + queryName);

            try (Socket sock = new Socket()) {
                logger.info("[IP:" + cfg.host + "][PTO:" + cfg.port + "]");
                sock.connect(new InetSocketAddress(cfg.host, cfg.port), cfg.connectTimeoutMs);
                sock.setSoTimeout(cfg.soTimeoutMs);
                logger.info("Estado de conexion con el MIP: " + sock.isConnected());

                writeNameFrame(sock, queryName);

                StringBuilder rawAcc = new StringBuilder();
                boolean moreData = true;
                while (moreData) {
                    String chunk = readLegacyBlock(sock);
                    rawAcc.append(chunk);
                    if (chunk.isEmpty() || containsAnyAcceptedPrefix(rawAcc.toString(), cfg.acceptedCodes)) {
                        moreData = false;
                    }
                }

                String preview = rawAcc.substring(0, Math.min(120, rawAcc.length())).replace("\n","\\n");
                logger.info("Preview respuesta (" + rawAcc.length() + "B): " + preview);

                boolean found =
                        containsAny(rawAcc.toString(), cfg.acceptedCodes)
                     || containsAnyAcceptedPrefix(rawAcc.toString(), cfg.acceptedCodes)
                     || rawAcc.length() > 0;

                if (found) {
                    logger.info("Archivo encontrado [OK] -> guardando crudo");
                    writeRawToNamedFile(queryName, rawAcc.toString());
                    logger.info("*** Descarga completada [OK]");
                } else {
                    logger.severe("*** Archivo no encontrado [FAIL]");
                }
            } catch (Exception e) {
                logger.severe("Error en descarga por nomenclatura: " + e.getMessage());
            }

            logger.info("=== FIN OPCION " + (tCode == 120 ? "3" : "4") + " ===");
        }

        // --------------- Opcion 5: Descarga por nombre completo (MANUAL) ------

        private void runDownloadByExactNameManual() {
            logger.info("=== OPCION 5: Descarga por nombre completo (manual) ===");

            if (manualHost == null || manualHost.isEmpty() || manualPort == null) {
                throw new IllegalArgumentException("Host/puerto manual no establecidos.");
            }
            if (fileNameOrParam == null || fileNameOrParam.trim().isEmpty()) {
                throw new IllegalArgumentException("Nombre completo vacio.");
            }
            String fullName = fileNameOrParam.trim();

            logger.info("Nombre a solicitar: " + fullName);

            try (Socket sock = new Socket()) {
                logger.info("[IP:" + manualHost + "][PTO:" + manualPort + "]");
                sock.connect(new InetSocketAddress(manualHost, manualPort), DEFAULT_CONNECT_TIMEOUT_MS);
                sock.setSoTimeout(DEFAULT_SO_TIMEOUT_MS);
                logger.info("Estado de conexion con el MIP: " + sock.isConnected());

                writeNameFrame(sock, fullName);

                StringBuilder rawAcc = new StringBuilder();
                boolean moreData = true;
                while (moreData) {
                    String chunk = readLegacyBlock(sock);
                    rawAcc.append(chunk);
                    if (chunk.isEmpty() || containsAnyAcceptedPrefix(rawAcc.toString(), manualAcceptedCodes)) {
                        moreData = false;
                    }
                }

                String preview = rawAcc.substring(0, Math.min(120, rawAcc.length())).replace("\n","\\n");
                logger.info("Preview respuesta (" + rawAcc.length() + "B): " + preview);

                boolean found =
                        containsAny(rawAcc.toString(), manualAcceptedCodes)
                     || containsAnyAcceptedPrefix(rawAcc.toString(), manualAcceptedCodes)
                     || rawAcc.length() > 0;

                if (found) {
                    logger.info("Archivo encontrado [OK] -> guardando crudo");
                    writeRawToNamedFile(fullName, rawAcc.toString());
                    logger.info("*** Descarga completada [OK]");
                } else {
                    logger.severe("*** Archivo no encontrado [FAIL]");
                }
            } catch (Exception e) {
                logger.severe("Error en descarga por nombre completo (manual): " + e.getMessage());
            }

            logger.info("=== FIN OPCION 5 ===");
        }

        // ----------------------------- Utilidades -----------------------------

        private static boolean matchesAny(String value, List<String> options) {
            if (options == null || options.isEmpty()) return false;
            for (String o : options) if (value.equals(o)) return true;
            return false;
        }
        private static boolean containsAny(String haystack, List<String> options) {
            if (options == null || options.isEmpty()) return false;
            for (String o : options) if (haystack.contains(o)) return true;
            return false;
        }
        private static boolean containsAnyAcceptedPrefix(String haystack, List<String> options) {
            if (options == null || options.isEmpty()) return false;
            for (String o : options) {
                String p = o.trim();
                if (p.isEmpty()) continue;
                String pref = (p.length() >= 6 ? p.substring(0, 6) : p);
                if (haystack.contains(pref)) return true;
            }
            return false;
        }

        // ------------------------ E/S de frames (EBCDIC manual) ----------------

        private static void writeTrailerFrame(Socket s, int count, String trailerCode7) throws IOException {
            if (trailerCode7 == null || trailerCode7.length() != 7) {
                throw new IllegalArgumentException("El codigo de trailer debe tener 7 caracteres.");
            }
            // 7 chars del accepted code (ASCII -> EBCDIC manual)
            byte[] codeAscii = trailerCode7.getBytes(StandardCharsets.US_ASCII);
            byte[] codeEbcdic = asciiToEbcdic(codeAscii);

            // 4 bytes contador big-endian + translateByteForDiscrepancy
            byte[] cnt = lengthToBytes(count, 4);
            for (int i = 0; i < cnt.length; i++) {
                cnt[i] = (byte) translateByteForDiscrepancy(cnt[i] & 0xFF);
            }

            byte[] bodyEbcdic = new byte[11];
            System.arraycopy(codeEbcdic, 0, bodyEbcdic, 0, 7);
            System.arraycopy(cnt,        0, bodyEbcdic, 7, 4);

            writeFrameRaw(s, bodyEbcdic);
        }

        static String generateFileNameFromTemplate(String template, String yyyymmdd) {
            if (template == null || template.trim().isEmpty()) {
                throw new IllegalArgumentException("fileNameTemplate no definido en el INI.");
            }
            String base = template.trim();
            LocalDate d = LocalDate.parse(yyyymmdd, DateTimeFormatter.BASIC_ISO_DATE);
            String ddmm = String.format("%02d%02d", d.getDayOfMonth(), d.getMonthValue());

            base = base.replaceAll("(?i)\\{ddmm\\}", ddmm);

            if (base.matches("(?i).*\\{rand\\}.*")) {
                String rand4 = String.format("%04d", new Random().nextInt(10000));
                base = base.replaceAll("(?i)\\{rand\\}", rand4);
            }

            base = base.toUpperCase(Locale.ROOT);

            if (base.length() != 9) {
                throw new IllegalArgumentException("fileNameTemplate debe producir 9 caracteres. Obtenido '" + base + "' (" + base.length() + ")");
            }
            return base;
        }

        private static String applyNameTemplate(String template, String fileName, String yyyymmdd) {
            LocalDate d = LocalDate.parse(yyyymmdd, DateTimeFormatter.BASIC_ISO_DATE);
            String julian = String.format("%03d", d.getDayOfYear());
            String yy = String.format("%02d", d.getYear() % 100);
            String mm = String.format("%02d", d.getMonthValue());
            String dd = String.format("%02d", d.getDayOfMonth());

            String out = template;
            out = out.replaceAll("(?i)\\{file\\}",     java.util.regex.Matcher.quoteReplacement(fileName));
            out = out.replaceAll("(?i)\\{julian\\}",   julian);
            out = out.replaceAll("(?i)\\{yyyymmdd\\}", yyyymmdd);
            out = out.replaceAll("(?i)\\{yy\\}",       yy);
            out = out.replaceAll("(?i)\\{mm\\}",       mm);
            out = out.replaceAll("(?i)\\{dd\\}",       dd);
            return out;
        }

        private static void validateEnvironmentForSend(Config cfg) {
            File cwd = new File(System.getProperty("user.dir"));
            logDirPerms("Directorio actual", cwd);
            if (!cwd.canRead() || !cwd.canExecute()) {
                throw new IllegalStateException("El directorio actual no tiene permisos suficientes (lectura y ejecucion).");
            }

            File dataFile = cfg.dataFilePath.toFile();
            if (!dataFile.exists() || !dataFile.isFile()) {
                throw new IllegalStateException("No existe el archivo de datos o no es regular: " + cfg.dataFilePath);
            }
            logger.info("Permisos del archivo de datos (" + dataFile.getName() + "):");
            logger.info("Lectura: " + (dataFile.canRead() ? "Permitido" : "No permitido"));
            logger.info("Escritura: " + (dataFile.canWrite() ? "Permitido" : "No permitido"));
            if (!dataFile.canRead()) {
                throw new IllegalStateException("No hay permisos de lectura sobre el archivo de datos: " + dataFile.getAbsolutePath());
            }

            File histFile = cfg.historyFilePath.toFile();
            File histDir  = histFile.getAbsoluteFile().getParentFile();
            if (histDir != null) {
                logDirPerms("Directorio del historico", histDir);
                if (!histDir.canWrite() || !histDir.canExecute()) {
                    throw new IllegalStateException("El directorio del historico no permite escribir/ejecutar: " + histDir.getAbsolutePath());
                }
            }

            try (FileChannel ignore = FileChannel.open(cfg.historyFilePath,
                    StandardOpenOption.CREATE, StandardOpenOption.WRITE, StandardOpenOption.APPEND)) {
                // OK
            } catch (IOException e) {
                throw new IllegalStateException("No se puede crear/escribir en el historico: " + cfg.historyFilePath + " - " + e.getMessage(), e);
            }
        }

        private static void validateEnvironmentForReport() {
            File cwd = new File(System.getProperty("user.dir"));
            logDirPerms("Directorio actual", cwd);
            if (!cwd.canRead() || !cwd.canExecute() || !cwd.canWrite()) {
                throw new IllegalStateException("El directorio actual no tiene permisos suficientes (lectura/ejecucion/escritura).");
            }
        }

        private static void logDirPerms(String label, File dir) {
            logger.info(label + " (" + dir.getAbsolutePath() + "):");
            logger.info("Lectura: " + (dir.canRead() ? "Permitido" : "No permitido"));
            logger.info("Escritura: " + (dir.canWrite() ? "Permitido" : "No permitido"));
            logger.info("Ejecucion: " + (dir.canExecute() ? "Permitido" : "No permitido"));
        }

        private static byte[] readPayload(Path p) {
            logger.info("Leyendo payload: " + p.toAbsolutePath());
            try {
                byte[] data = Files.readAllBytes(p);
                logger.info("Tamano payload: " + data.length + " bytes");
                return data;
            } catch (Exception e) {
                throw new RuntimeException("Error leyendo archivo: " + p + " - " + e.getMessage(), e);
            }
        }

        private static List<byte[]> split(byte[] data, int chunkSize) {
            List<byte[]> parts = new ArrayList<>();
            int total = data.length;
            for (int off = 0; off < total; off += chunkSize) {
                int len = Math.min(chunkSize, total - off);
                parts.add(Arrays.copyOfRange(data, off, off + len));
            }
            return parts;
        }

        private static byte[] lengthToBytes(int num, int byts) {
            byte[] r = new byte[byts];
            for (int i = byts - 1; i >= 0; --i) { r[i] = (byte)(num & 0xFF); num >>>= 8; }
            return r;
        }

        // --------- Conversion manual EBCDIC/ASCII (estilo original) ---------

        private static byte[] asciiToEbcdic(byte[] ascii) {
            byte[] out = new byte[ascii.length];
            for (int i = 0; i < ascii.length; i++) {
                int a = ascii[i] & 0xFF;
                out[i] = (byte) translateByte("toEBC", a);
            }
            return out;
        }

        private static String ebcdicToAsciiString(byte[] ebcdic, int len) {
            StringBuilder sb = new StringBuilder(len);
            for (int i = 0; i < len; i++) {
                int b = ebcdic[i] & 0xFF;
                char c = (char) translateByte("toASC", b);
                if (c != '\0' && c >= ' ' && c <= '~') {
                    sb.append(c);
                } else if (c == '\n') {
                    sb.append('\n');
                }
            }
            return sb.toString();
        }

        private static void writeNameFrame(Socket s, String text) throws IOException {
            byte[] ascii = text.getBytes(StandardCharsets.US_ASCII);
            byte[] bodyEbcdic = asciiToEbcdic(ascii);
            writeFrameRaw(s, bodyEbcdic);
        }

        private static void writeChunkFrame(Socket s, byte[] asciiChunk) throws IOException {
            ByteArrayOutputStream baos = new ByteArrayOutputStream(1 + asciiChunk.length);
            baos.write((byte) 'R');
            baos.write(asciiChunk);
            byte[] asciiBody = baos.toByteArray();
            byte[] bodyEbcdic = asciiToEbcdic(asciiBody);
            writeFrameRaw(s, bodyEbcdic);
        }

        private static void writeFrameRaw(Socket s, byte[] bodyAlreadyEbcdic) throws IOException {
            int len = bodyAlreadyEbcdic.length;
            byte[] header = lengthToBytes(len, 2);
            OutputStream os = s.getOutputStream();
            os.write(header);
            os.write(bodyAlreadyEbcdic);
            os.flush();
        }

        private static String readResponse(Socket s) throws IOException {
            ByteArrayOutputStream baos = new ByteArrayOutputStream();
            InputStream is = s.getInputStream();
            byte[] buf = new byte[1024];
            while (true) {
                try {
                    int n = is.read(buf);
                    if (n == -1) break;
                    baos.write(buf, 0, n);
                    if (n < buf.length) break;
                } catch (SocketTimeoutException te) {
                    if (baos.size() == 0) throw te;
                    break;
                }
            }
            byte[] ebcdicBytes = baos.toByteArray();
            return ebcdicToAsciiString(ebcdicBytes, ebcdicBytes.length);
        }

        private static String readLegacyBlock(Socket s) throws IOException {
            InputStream is = s.getInputStream();
            byte[] buf = new byte[1024];
            int n = is.read(buf, 0, 1024);
            if (n <= 0) return "";
            return ebcdicToAsciiString(buf, n);
        }

        // ------------------ Historico (solo Opcion 1) ----------------------

        private static void createShippingHistory(String respCode, String fileName, String dateYYYYMMDD, Path historyPath) {
            try {
                monthlyRotateIfFirstDay(historyPath);
                String record = formatHistory(respCode, fileName, dateYYYYMMDD, LocalDateTime.now());
                prependLine(historyPath, record);
                logger.info("Historico actualizado: " + historyPath);
            } catch (Exception e) {
                logger.severe("No se pudo actualizar el historico: " + e.getMessage());
            }
        }

        private static void monthlyRotateIfFirstDay(Path historyPath) {
            if (LocalDate.now().getDayOfMonth() == 1) {
                try {
                    Files.write(historyPath, new byte[0],
                            StandardOpenOption.CREATE, StandardOpenOption.TRUNCATE_EXISTING);
                } catch (IOException e) {
                    logger.warning("No se pudo rotar historico mensual: " + e.getMessage());
                }
            }
        }

        private static String formatHistory(String resp, String code, String fec, LocalDateTime now) {
            String ts = now.format(DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss"));
            return "[" + resp + "-" + code + "-" + fec + ": " + ts + "]";
        }

        private static void prependLine(Path path, String line) throws IOException {
            List<String> lines = new ArrayList<>();
            if (Files.exists(path)) {
                try {
                    lines = Files.readAllLines(path, StandardCharsets.UTF_8);
                } catch (MalformedInputException mie) {
                    lines = new ArrayList<>();
                }
            }
            lines.add(0, line);
            Files.write(path, String.join(System.lineSeparator(), lines).getBytes(StandardCharsets.UTF_8),
                    StandardOpenOption.CREATE, StandardOpenOption.TRUNCATE_EXISTING, StandardOpenOption.WRITE);
        }

        // ------------------ Helpers de reporte (Opcion 2) ---------------------

        private static void writeDataToFile(String dateYYYYMMDD, String data, String fileNameAnyLen) throws IOException {
            logger.info("Parametro date: " + dateYYYYMMDD);
            if (!validateDate(dateYYYYMMDD)) {
                logger.severe("Fecha ingresada no es valida: " + dateYYYYMMDD);
                return;
            }
            final String newName = getNameFileReport(dateYYYYMMDD, fileNameAnyLen);
            logger.info("Nombre de reporte generado: " + newName);
            if (newName == null) {
                logger.severe("No se pudo generar nombre de reporte.");
                return;
            }
            logger.info("Creando reporte...");
            try (FileOutputStream reportFile = new FileOutputStream(newName);
                 PrintStream ps = new PrintStream(reportFile, true, "UTF-8")) {
                ps.print(data);
            }
            logger.info("Reporte: " + newName + " [GENERADO]");
        }

        private static String orderDetails(String dataMipDato, String allOkCode) {
            String fixed = normalizeTHArtifact(dataMipDato);
            String headers = extractHeaders(fixed);
            String details = extractDetails(fixed, allOkCode);
            return headers + details;
        }

        private static String extractHeaders(String data) {
            String src = (data == null) ? "" : data;

            String sansGt  = src.replace(">", "");
            String first20 = sansGt.length() >= 20 ? sansGt.substring(0, 20)
                                                   : String.format("%-20s", sansGt);
            String header = first20 + "]\n";

            int start12 = src.indexOf("12");
            int startH  = src.indexOf("H0");
            int start   = (start12 >= 0) ? start12 : (startH >= 0 ? startH : -1);

            if (start < 0) return header;

            int end16   = src.indexOf("16", start);
            int endD0   = src.indexOf("D0", start);
            int endBrkt = src.indexOf("]",  start);
            int end = firstNonNegMin(end16, endD0, endBrkt);
            if (end < 0) end = src.length();

            return header + safeSub(src, start, end);
        }

        private static String extractDetails(String data, String allOkCode) {
            String src = (data == null) ? "" : data;

            int start16 = src.indexOf("16");
            int startD0 = src.indexOf("D0");
            int start   = (start16 >= 0) ? start16 : (startD0 >= 0 ? startD0 : -1);
            if (start < 0) return "";

            String cleaned = safeSub(src, start, src.length()).replace("[","").replace("]\n","");

            String[] detailsData = cleaned.split("D0", -1);
            StringBuilder out = new StringBuilder();
            out.append('\n');

            boolean first = true;
            for (int i = 1; i < detailsData.length; i++) {
                String seg = detailsData[i];

                if (!first) out.append('\n');
                first = false;

                out.append("D0");

                String head = seg.length() >= 57 ? seg.substring(0,57) : String.format("%-57s", seg);
                String tail = seg.length()  > 57 ? seg.substring(57)   : "";

                if (i == detailsData.length - 1) {
                    if (tail.length() < 26) {
                        String t = tail.trim();
                        if (t.length() > 15) t = t.substring(0, 15);
                        String codErrors = String.format("%26s", t);
                        out.append(head).append(codErrors).append(allOkCode);
                    } else {
                        int okPos = seg.indexOf(allOkCode);
                        if (okPos >= 0) {
                            out.append(seg, 0, okPos + allOkCode.length());
                        } else {
                            out.append(seg, 0, Math.min(83, seg.length()));
                        }
                    }
                    break;
                }

                out.append(seg, 0, Math.min(83, seg.length()));
            }

            return out.toString();
        }

        private static String getNameFileReport(String dateYYYYMMDD, String fileNameAnyLen) {
            final String description = "-Archivo de Cambio Confirmacion";
            DateTimeFormatter inputFormatter = DateTimeFormatter.ofPattern("yyyyMMdd");
            DateTimeFormatter outputFormatter = DateTimeFormatter.ofPattern("yyyyMMdd");

            String prefix;
            if (fileNameAnyLen == null || fileNameAnyLen.isEmpty()) {
                prefix = "";
            } else {
                prefix = (fileNameAnyLen.length() >= 4) ? fileNameAnyLen.substring(0, 4) : fileNameAnyLen;
            }
            prefix = prefix + "-";

            try {
                LocalDate fecha = LocalDate.parse(dateYYYYMMDD, inputFormatter);
                return prefix + fecha.format(outputFormatter) + description;
            } catch (Exception e) {
                logger.severe("Parametro date(" + dateYYYYMMDD + ") incorrecto.");
                return null;
            }
        }

        private static String normalizeTHArtifact(String s) {
            if (s == null) return "";
            return s.replaceAll("(?m)^T(?=H)", "");
        }
        private static String safeSub(String s, int from, int to) {
            if (s == null) return "";
            int a = Math.max(0, Math.min(from, s.length()));
            int b = Math.max(a, Math.min(to,   s.length()));
            return s.substring(a, b);
        }
        private static int firstNonNegMin(int... idx) {
            int best = -1;
            for (int v : idx) if (v >= 0 && (best < 0 || v < best)) best = v;
            return best;
        }

        private static void writeRawToNamedFile(String fileName, String data) throws IOException {
            try (FileOutputStream fos = new FileOutputStream(fileName);
                 PrintStream ps = new PrintStream(fos, true, "UTF-8")) {
                ps.print(data);
            }
            logger.info("Archivo escrito: " + fileName);
        }

        // ------------------ MAPEO MANUAL (TABLA ORIGINAL) ------------------

        private static int translateByte(final String translationType, final int paramInt) {
            final int[] asciiArray  = { 32, 33,  34,  35, 36,  37, 38,  39, 40, 41, 42, 43,  44, 45, 46, 47,  48,  49,  50,  51,  52,  53,  54,  55,  56,  57,  58, 59, 60,  61,  62,  63,  64,  65,  66,  67,  68,  69,  70,  71,  72,  73,  74,  75,  76,  77,  78,  79,  80,  81,  82,  83,  84,  85,  86,  87,  88,  89,  90,  91,  92,  93, 94,  95,  96,  97,  98,  99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126 };
            final int[] ebcdicArray = { 64, 90, 127, 123, 91, 108, 80, 125, 77, 93, 92, 78, 107, 96, 75, 97, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 122, 94, 76, 126, 110, 111, 124, 193, 194, 195, 196, 197, 198, 199, 200, 201, 209, 210, 211, 212, 213, 214, 215, 216, 217, 226, 227, 228, 229, 230, 231, 232, 233, 173, 224, 189, 95, 109, 121, 129, 130, 131, 132, 133, 134, 135, 136, 137, 145, 146, 147, 148, 149, 150, 151, 152, 153, 162, 163, 164, 165, 166, 167, 168, 169, 192, 106, 208, 161 };
            for (int i = 0; i < asciiArray.length; i++) {
                if (translationType.equals("toEBC")) { if (paramInt == asciiArray[i]) return ebcdicArray[i]; }
                else { if (paramInt == ebcdicArray[i]) return asciiArray[i]; }
            }
            return paramInt;
        }

        private static int translateByteForDiscrepancy(final int paramInt) {
            int[] discrepancyArray = new int[126];
            for (int i = 0; i < discrepancyArray.length; i++) {
                discrepancyArray[i]  = i + 1;
            }
            for (int i = 0; i < discrepancyArray.length; i++) {
                if (paramInt == discrepancyArray[i]) {
                    return discrepancyArray[i];
                }
            }
            return paramInt;
        }
    }
}
