//=================================================================================================
// McBatchSender
//
// Proposito:
//   Envia un archivo por TCP (Opcion 1) y genera/descarga reportes (Opciones 2, 3, 4, 5 y 6)
//   con un menu interactivo cuando se ejecuta sin parametros.
//
// Protocolo:
//   - Cada trama: header de 2 bytes (longitud big-endian) + cuerpo en EBCDIC (personalizado).
//   - Opcion 1 (envio): cada parte se envia con prefijo ASCII 'R' y luego se convierte a EBCDIC.
//     Trailer final: 11 bytes = EBCDIC(acceptedCode de 7 chars) + contador(4B).
//
// Modificacion Clave:
//   - Se reemplazo la codificacion estandar Charset.forName("Cp037") por una tabla de conversion
//     manual (metodo translateByte) extraida de un programa anterior (GCO_MIP) para asegurar
//     la compatibilidad con el servidor MIP.
//=================================================================================================

import java.io.*;
import java.net.*;
import java.nio.charset.MalformedInputException;
import java.nio.charset.StandardCharsets;
import java.nio.file.*;
import java.nio.channels.FileChannel;
import java.time.*;
import java.time.format.DateTimeFormatter;
import java.util.*;
import java.util.logging.Logger;

public class McBatchSender {
    private static final Logger logger = Logger.getLogger(McBatchSender.class.getName());

    // Entidad fija para opciones 3/4
    private static final String FIXED_ENTITY_Txx = "E0002840";

    // -------- Util compartido --------

    // Valida fecha AAAAMMDD
    private static boolean validateDate(String date) {
        if (date == null) return false;
        DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyyMMdd");
        try { LocalDate.parse(date, formatter); return true; } catch (Exception e) { return false; }
    }
    // Valida HHMMSS
    private static boolean validateHHMMSS(String hhmmss) {
        if (hhmmss == null || !hhmmss.matches("\\d{6}")) return false;
        int hh = Integer.parseInt(hhmmss.substring(0,2));
        int mm = Integer.parseInt(hhmmss.substring(2,4));
        int ss = Integer.parseInt(hhmmss.substring(4,6));
        return (hh >= 0 && hh <= 23) && (mm >= 0 && mm <= 59) && (ss >= 0 && ss <= 59);
    }

    /**
     * Punto de entrada:
     * - Sin argumentos: modo interactivo.
     * - Con argumentos:
     * Opcion 1/2: <OPC> <SECCION> <FILE_NAME> <DATE>
     * Opcion 3/4: <OPC> <SECCION> <HHMMSS> <DATE>
     * Opcion 5  : 5 <SECCION> <FULL_NAME>
     * Opcion 6  : 6 <SECCION> <PREFIX> <DATE_START> <DATE_END> <SEQ_START> <SEQ_END>
     */
    public static void main(String[] args) {
        final String iniPath = System.getProperty("mcsender.config", "mcsender.ini");
        final Path ini = Paths.get(iniPath);

        if (args.length == 0) {
            // Interactivo
            try {
                IniFile cfgFile = IniFile.load(ini);
                Interactive.runInteractive(cfgFile);
                System.exit(0);
            } catch (NoSuchFileException e) {
                System.err.println("No se encontro el archivo de configuracion: " + e.getFile());
                System.exit(3);
            } catch (Exception e) {
                System.err.println("Error inesperado en modo interactivo: " + e.getMessage());
                e.printStackTrace();
                System.exit(1);
            }
        }

        // Parametros
        final String optionStr = args[0].trim();
        final int option;
        try { option = Integer.parseInt(optionStr); }
        catch (NumberFormatException nfe) {
            System.err.println("OPCION debe ser un numero. Valor: '" + optionStr + "'");
            System.exit(4); return;
        }
        if (option < 1 || option > 6) {
            System.err.println("OPCION invalida. Use 1, 2, 3, 4, 5 o 6.");
            System.exit(4);
        }

        try {
            IniFile cfgFile = IniFile.load(ini);
            String section;
            Sender sender;

            if (option >= 1 && option <= 4) {
                 if (args.length != 4) {
                    System.err.println("Uso Opcion 1/2: java McBatchSender <OPC> <SECCION> <FILE_NAME> <DATE>");
                    System.err.println("Uso Opcion 3/4: java McBatchSender <OPC> <SECCION> <HHMMSS> <DATE>");
                    System.exit(2);
                }
                section = args[1].trim();
                Config cfg = Config.from(cfgFile, section);
                String nameParam = args[2].trim();
                String date = args[3].trim();
                sender = new Sender(cfg, option, nameParam, date, null);
            } else if (option == 5) {
                if (args.length != 3) {
                    System.err.println("Uso Opcion 5: java McBatchSender 5 <SECCION> <FULL_NAME>");
                    System.exit(2);
                }
                section = args[1].trim();
                Config cfg = Config.from(cfgFile, section);
                String fullName = args[2].trim();
                sender = new Sender(cfg, 5, fullName, null, null);
            } else if (option == 6) {
                 if (args.length != 7) {
                    System.err.println("Uso Opcion 6: java McBatchSender 6 <SECCION> <PREFIX> <FECHA_INI> <FECHA_FIN> <SEQ_INI> <SEQ_FIN>");
                    System.exit(2);
                }
                section = args[1].trim();
                Config cfg = Config.from(cfgFile, section);
                String prefix = args[2].trim();
                String dateStart = args[3].trim();
                String dateEnd = args[4].trim();
                int seqStart = Integer.parseInt(args[5].trim());
                int seqEnd = Integer.parseInt(args[6].trim());
                sender = new Sender(cfg, 6, prefix, dateStart, dateEnd, seqStart, seqEnd);
            } else {
                 throw new IllegalArgumentException("Logica de argumentos no implementada para opcion: " + option);
            }
            
            sender.run();
            System.exit(0);

        } catch (NoSuchFileException e) {
            System.err.println("No se encontro el archivo de configuracion: " + e.getFile());
            System.exit(3);
        } catch (IllegalArgumentException e) {
            System.err.println("Configuracion/argumento invalido: " + e.getMessage());
            System.exit(4);
        } catch (Exception e) {
            System.err.println("Error inesperado: " + e.getMessage());
            e.printStackTrace();
            System.exit(1);
        }
    }

    // -------------------------------- Interactivo --------------------------------

    static class Interactive {
        static void runInteractive(IniFile cfgFile) throws Exception {
            Scanner sc = new Scanner(System.in);

            List<String> sections = cfgFile.sectionNames();
            if (sections.isEmpty()) throw new IllegalArgumentException("El INI no contiene secciones.");
            System.out.println("\n=== McBatchSender (Modo Interactivo) ===");
            System.out.println("Secciones disponibles: " + String.join(", ", sections));

            System.out.println("\nOpciones:");
            System.out.println("  1) Envio (envia archivo de datos)");
            System.out.println("  2) Reporte MIP (consulta 10101...)");
            System.out.println("  3) Descarga T120 (YTF.AR.T120...)");
            System.out.println("  4) Descarga T112 (YTF.AR.T112...)");
            System.out.println("  5) Descarga por nombre completo");
            System.out.println("  6) Descarga por Patron (busca multiples archivos)");
            int option = askInt(sc, "Ingrese la opcion [1-6]: ", 1, 6);

            String section = askString(sc, "Ingrese la seccion (ej. " + sections.get(0) + "): ").trim();
            if (cfgFile.section(section) == null) {
                throw new IllegalArgumentException("La seccion [" + section + "] no existe en el INI.");
            }
            Config cfg = Config.from(cfgFile, section);
            Sender sender;

            if (option == 1 || option == 2) {
                String fileNameArg = askString(sc, "Ingrese FILE_NAME (ej. R27802840): ").trim().toUpperCase();
                String date = askDate(sc, "Ingrese DATE (AAAAMMDD): ");
                sender = new Sender(cfg, option, fileNameArg, date, null);
                if (option == 2) {
                    boolean parse = askYesNo(sc, "Para el reporte, desea parsear (ordenar) el contenido? (S/N) ");
                    sender.setReportProcessOverride(parse);
                }
            } else if (option == 3 || option == 4) {
                String hhmmss = askHHMMSS(sc, "Ingrese HHMMSS (6 digitos): ");
                String date = askDate(sc, "Ingrese DATE (AAAAMMDD): ");
                sender = new Sender(cfg, option, hhmmss, date, null);
            } else if (option == 5) {
                String fullName = askString(sc, "Ingrese el nombre completo a consultar (tal cual): ").trim();
                sender = new Sender(cfg, option, fullName, null, null);
            } else if (option == 6) {
                String prefix = askString(sc, "Ingrese prefijo del patron (ej. YTF.AR.T112.F.E0002840): ").trim();
                String dateStart = askDate(sc, "Ingrese Fecha INICIO (AAAAMMDD): ");
                String dateEnd = askDate(sc, "Ingrese Fecha FIN (AAAAMMDD): ");
                int seqStart = askInt(sc, "Ingrese secuencia INICIAL (ej. 1): ", 1, 9999);
                int seqEnd = askInt(sc, "Ingrese secuencia FINAL (ej. 999): ", seqStart, 9999);
                sender = new Sender(cfg, 6, prefix, dateStart, dateEnd, seqStart, seqEnd);
            } else {
                throw new IllegalStateException("Opcion no manejada");
            }
            
            sender.run();
        }
        
        private static String askDate(Scanner sc, String prompt) {
            while (true) {
                String date = askString(sc, prompt).trim();
                if (validateDate(date)) return date;
                System.out.println("Fecha invalida. Intente de nuevo.");
            }
        }
        
        private static String askHHMMSS(Scanner sc, String prompt) {
            while (true) {
                String hhmmss = askString(sc, prompt).trim();
                if (validateHHMMSS(hhmmss)) return hhmmss;
                System.out.println("HHMMSS invalido. Intente de nuevo.");
            }
        }
        
        private static int askInt(Scanner sc, String prompt, int min, int max) {
            while (true) {
                System.out.print(prompt); String s = sc.nextLine().trim();
                try { int v = Integer.parseInt(s); if (v < min || v > max) throw new NumberFormatException(); return v; }
                catch (NumberFormatException e) { System.out.println("Valor invalido. Ingrese un numero entre " + min + " y " + max + "."); }
            }
        }
        private static String askString(Scanner sc, String prompt) {
            System.out.print(prompt); return sc.nextLine();
        }
        private static boolean askYesNo(Scanner sc, String prompt) {
            while (true) {
                System.out.print(prompt); String s = sc.nextLine().trim().toUpperCase(Locale.ROOT);
                if (s.equals("S") || s.equals("SI") || s.equals("Y") || s.equals("YES")) return true;
                if (s.equals("N") || s.equals("NO")) return false;
                System.out.println("Responda S/N.");
            }
        }
    }

    // -------------------------------- Config --------------------------------

    static class Config {
        final String host; final int port; final int connectTimeoutMs; final int soTimeoutMs; final int chunkSize;
        final Path dataFilePath; final Path historyFilePath; final List<String> acceptedCodes;
        final String alreadySentSubstring; final String defaultFailCode; final String dateOverride;
        final String nameTemplate; final String fileNameTemplate; final String reportNameTemplate;
        final boolean reportProcess;

        private Config(String host, int port, int connectTimeoutMs, int soTimeoutMs, int chunkSize, Path dataFilePath, Path historyFilePath, List<String> acceptedCodes, String alreadySentSubstring, String defaultFailCode, String dateOverride, String nameTemplate, String fileNameTemplate, String reportNameTemplate, boolean reportProcess) {
            this.host = host; this.port = port; this.connectTimeoutMs = connectTimeoutMs; this.soTimeoutMs = soTimeoutMs;
            this.chunkSize = chunkSize; this.dataFilePath = dataFilePath; this.historyFilePath = historyFilePath;
            this.acceptedCodes = acceptedCodes; this.alreadySentSubstring = alreadySentSubstring; this.defaultFailCode = defaultFailCode;
            this.dateOverride = dateOverride; this.nameTemplate = nameTemplate; this.fileNameTemplate = fileNameTemplate;
            this.reportNameTemplate = reportNameTemplate; this.reportProcess = reportProcess;
        }

        static Config from(IniFile ini, String section) {
            Map<String,String> s = ini.section(section);
            if (s == null) throw new IllegalArgumentException("No existe la seccion ["+section+"].");

            String host = req(s, "host"); int port = parseInt(s.get("port"), 1, 65535, "port");
            int connectTimeout = parseInt(s.getOrDefault("connectTimeoutMs","60000"), 1000, 300000, "connectTimeoutMs");
            int soTimeout = parseInt(s.getOrDefault("soTimeoutMs","60000"), 1000, 300000, "soTimeoutMs");
            int chunk = parseInt(s.getOrDefault("chunkSize","980"), 1, 65535, "chunkSize");
            String dataFileStr = s.getOrDefault("dataFilePath", "MIPFILE_DATI");
            String historyFileStr = s.getOrDefault("historyFilePath", "MIPFILE_HISTORY_R");
            List<String> acceptedList = parseList(s.getOrDefault("acceptedCode","9980100"));
            String already = s.getOrDefault("alreadySentSubstring","9288W"); String failDef = s.getOrDefault("defaultFailCode","9980101");
            String dateOverride = s.get("date"); String nameTemplate = s.getOrDefault("nameTemplate", "00401{file}{julian}");
            String fileNameTemplate = s.get("fileNameTemplate"); String reportNameTemplate = s.getOrDefault("reportNameTemplate", "10101{file}{julian}");
            boolean reportProcess = s.getOrDefault("report.process", "Y").trim().equalsIgnoreCase("Y");
            Path dataPath = resolveAgainstCwd(dataFileStr); Path histPath = resolveAgainstCwd(historyFileStr);
            if (pickTrailerCodeSeven(acceptedList) == null) throw new IllegalArgumentException("acceptedCode debe incluir al menos un valor de 7 caracteres.");
            return new Config(host, port, connectTimeout, soTimeout, chunk, dataPath, histPath, acceptedList, already, failDef, dateOverride, nameTemplate, fileNameTemplate, reportNameTemplate, reportProcess);
        }
        private static Path resolveAgainstCwd(String p) { Path path = Paths.get(p); if (path.isAbsolute()) return path.normalize(); return Paths.get(System.getProperty("user.dir")).resolve(p).normalize(); }
        private static String req(Map<String,String> m, String key) { String v = m.get(key); if (v == null || v.trim().isEmpty()) throw new IllegalArgumentException("Falta "+key); return v.trim(); }
        private static int parseInt(String s, int min, int max, String name) { try { int v = Integer.parseInt(s.trim()); if (v < min || v > max) throw new IllegalArgumentException(name+" fuera de rango ["+min+","+max+"]"); return v; } catch (NumberFormatException e) { throw new IllegalArgumentException(name+" no numerico: "+s); } }
        private static List<String> parseList(String csv) { List<String> out = new ArrayList<>(); if (csv != null) for (String p : csv.split(",")) { String t = p.trim(); if (!t.isEmpty()) out.add(t); } return out.isEmpty() ? Collections.emptyList() : Collections.unmodifiableList(out); }
        String firstAcceptedCodeOrDefault() { return acceptedCodes.isEmpty() ? defaultFailCode : acceptedCodes.get(0); }
        String trailerCodeSeven() { String t = pickTrailerCodeSeven(acceptedCodes); if (t == null) throw new IllegalArgumentException("acceptedCode debe incluir un valor de 7 caracteres para trailer."); return t; }
        private static String pickTrailerCodeSeven(List<String> codes) { if (codes != null) for (String c : codes) { String t = (c == null ? "" : c.trim()); if (t.length() == 7) return t; } return null; }
    }

    // ----------------------------- INI simple -----------------------------

    static class IniFile {
        private final Map<String, Map<String,String>> data = new LinkedHashMap<>(); private IniFile() {}
        static IniFile load(Path path) throws IOException { if (!Files.exists(path)) throw new NoSuchFileException(path.toString()); IniFile f = new IniFile(); Map<String,String> cur = null; try (BufferedReader br = Files.newBufferedReader(path, StandardCharsets.UTF_8)) { String line; while ((line = br.readLine()) != null) { String ln = line.trim(); if (ln.isEmpty() || ln.startsWith("#") || ln.startsWith(";")) continue; if (ln.startsWith("[") && ln.endsWith("]")) { String sec = ln.substring(1, ln.length()-1).trim(); cur = f.data.computeIfAbsent(sec, k -> new LinkedHashMap<>()); } else { int eq = ln.indexOf('='); if (eq < 0 || cur == null) continue; String k = ln.substring(0, eq).trim(); String v = ln.substring(eq+1).trim(); cur.put(k, v); } } } return f; }
        Map<String,String> section(String name) { return data.get(name); }
        List<String> sectionNames() { return new ArrayList<>(data.keySet()); }
    }

    // ------------------------------ Sender ------------------------------

    static class Sender {
        private final Config cfg;
        private final int option;
        private final String param;
        private final String date;
        private final String dateEnd;
        private final int seqStart;
        private final int seqEnd;
        private Boolean reportProcessOverride;

        // Constructor para Opciones 1-5
        Sender(Config cfg, int option, String param, String date, Boolean reportProcessOverride) {
            this(cfg, option, param, date, null, 0, 0);
            this.reportProcessOverride = reportProcessOverride;
        }

        // Constructor para Opcion 6
        Sender(Config cfg, int option, String prefix, String dateStart, String dateEnd, int seqStart, int seqEnd) {
            this(cfg, option, prefix, dateStart, dateEnd, seqStart, seqEnd);
        }

        private Sender(Config cfg, int option, String param, String date, String dateEnd, int seqStart, int seqEnd) {
            this.cfg = cfg;
            this.option = option;
            this.param = param; // No forzar a UpperCase aqui, la lógica específica lo hará si es necesario
            this.date = date; // Para Opc 6, es dateStart
            this.dateEnd = dateEnd;
            this.seqStart = seqStart;
            this.seqEnd = seqEnd;
        }

        public void setReportProcessOverride(Boolean reportProcessOverride) {
            this.reportProcessOverride = reportProcessOverride;
        }

        void run() {
            if (option == 1) runSend();
            else if (option == 2) runReport();
            else if (option == 3) runDownloadByNomenclature(120);
            else if (option == 4) runDownloadByNomenclature(112);
            else if (option == 5) runDownloadByExactName();
            else if (option == 6) runDownloadByPattern();
            else throw new IllegalArgumentException("OPCION invalida: " + option);
        }
        
        // --------------------------- Opcion 1: Envio ---------------------------
        
        private void runSend() {
             logger.info("=== OPCION 1: Envio ===");
             validateEnvironmentForSend(cfg);
             byte[] payload = readPayload(cfg.dataFilePath);
             if (payload.length == 0) {
                 logger.warning("El archivo de datos esta vacio: " + cfg.dataFilePath);
                 createShippingHistory(cfg.defaultFailCode, "<NOFILE>", this.date, cfg.historyFilePath);
                 return;
             }
             List<byte[]> parts = split(payload, cfg.chunkSize);
             logger.info("Partes a enviar: " + parts.size() + " (chunkSize=" + cfg.chunkSize + ")");
             String effectiveFileName = (param != null) ? param.toUpperCase() : generateFileNameFromTemplate(cfg.fileNameTemplate, this.date);
             if (effectiveFileName == null || effectiveFileName.isEmpty()) {
                 throw new IllegalArgumentException("No hay FILE_NAME: CLI/menu o fileNameTemplate requerido.");
             }
             logger.info("FILE_NAME efectivo: " + effectiveFileName);
             String nameToSend = applyNameTemplate(cfg.nameTemplate, effectiveFileName, this.date);
             logger.info("Nombre a enviar: " + nameToSend);
             String finalStatus = cfg.defaultFailCode;
             try (Socket sock = new Socket()) {
                 sock.connect(new InetSocketAddress(cfg.host, cfg.port), cfg.connectTimeoutMs);
                 sock.setSoTimeout(cfg.soTimeoutMs);
                 logger.info(String.format("Conectado a %s:%d", cfg.host, cfg.port));
                 writeNameFrame(sock, nameToSend);
                 String resp = readResponse(sock).trim();
                 logger.info("Respuesta aprobacion: [" + resp + "]");
                 if (!cfg.alreadySentSubstring.isEmpty() && resp.contains(cfg.alreadySentSubstring)) {
                     logger.info("Servidor indica 'ya enviado'.");
                     finalStatus = cfg.firstAcceptedCodeOrDefault();
                 } else if (matchesAny(resp, cfg.acceptedCodes)) {
                     logger.info("*** Enviando Tramas... [CANT:" + parts.size() + "]");
                     for (byte[] p : parts) {
                         writeChunkFrame(sock, p);
                     }
                     writeTrailerFrame(sock, parts.size() + 1, cfg.trailerCodeSeven());
                     logger.info("Esperando confirmacion final...");
                     String resp2 = readResponse(sock).trim();
                     logger.info("Confirmacion final: [" + resp2 + "]");
                     if (matchesAny(resp2, cfg.acceptedCodes)) {
                         finalStatus = cfg.firstAcceptedCodeOrDefault();
                         logger.info("RESULTADO DE ENVIO [OK]");
                     } else {
                         logger.warning("RESULTADO DE ENVIO [FAIL] (codigo final no coincide)");
                     }
                 } else {
                     logger.warning("Nombre rechazado por el hub.");
                 }
             } catch (Exception e) {
                 logger.severe("Error en envio: " + e.getMessage());
                 e.printStackTrace();
             } finally {
                 createShippingHistory(finalStatus, effectiveFileName, this.date, cfg.historyFilePath);
             }
             logger.info("=== FIN OPCION 1 ===");
        }

        // --------------------------- Opcion 2: Reporte -------------------------
        private void runReport() {
            logger.info("=== OPCION 2: Reporte ===");
            validateEnvironmentForReport();
            String effectiveFileName = (param != null) ? param.toUpperCase() : generateFileNameFromTemplate(cfg.fileNameTemplate, this.date);
            if (effectiveFileName == null || effectiveFileName.isEmpty()) {
                 throw new IllegalArgumentException("No hay FILE_NAME: CLI/menu o fileNameTemplate requerido.");
            }
            logger.info("FILE_NAME efectivo: " + effectiveFileName);
            String nameBase = applyNameTemplate(cfg.reportNameTemplate, effectiveFileName, this.date);
            logger.info("Nombre base de reporte: " + nameBase);
            boolean found = false;
            StringBuilder finalRaw = new StringBuilder();

            try (Socket sock = new Socket()) {
                sock.connect(new InetSocketAddress(cfg.host, cfg.port), cfg.connectTimeoutMs);
                sock.setSoTimeout(cfg.soTimeoutMs);
                logger.info("Conectado a " + cfg.host + ":" + cfg.port);

                for (int i = 1; i <= 99; i++) {
                    String secStr = String.format("%02d", i);
                    String queryName = nameBase + secStr;
                    logger.info("*** Consultando: " + queryName);
                    writeNameFrame(sock, queryName);
                    StringBuilder rawAcc = new StringBuilder();
                    boolean moreData = true;
                    while (moreData) {
                        String chunk = readLegacyBlock(sock);
                        rawAcc.append(chunk);
                        if (chunk.isEmpty() || rawAcc.toString().contains("998010")) {
                            moreData = false;
                        }
                    }
                    if (containsAny(rawAcc.toString(), cfg.acceptedCodes)) {
                        logger.info("Archivo encontrado [OK]");
                        found = true;
                        finalRaw.append(rawAcc);
                        break;
                    } else {
                        logger.info("Buscando...");
                    }
                }
                if (found) {
                     logger.info("*** Generando archivo de respuesta...");
                     String dataToWrite;
                     boolean process = (reportProcessOverride != null) ? reportProcessOverride : cfg.reportProcess;
                     if(process) {
                         dataToWrite = orderDetails(finalRaw.toString(), cfg.firstAcceptedCodeOrDefault());
                     } else {
                         dataToWrite = finalRaw.toString();
                     }
                     writeDataToFile(this.date, dataToWrite, effectiveFileName);
                     logger.info("*** Reporte generado [OK]");
                } else {
                     logger.severe("*** Archivo no encontrado [FAIL]");
                }
            } catch (Exception e) {
                 logger.severe("Error en reporte: " + e.getMessage());
                 e.printStackTrace();
            }
             logger.info("=== FIN OPCION 2 ===");
        }
        
        // ---------------------- Opcion 3/4/5/6: Descargas -----------------
        private void runDownloadByNomenclature(int tCode) {
            logger.info("=== OPCION " + (tCode == 120 ? "3" : "4") + ": Descarga T" + tCode + " ===");
            if (param == null || !validateHHMMSS(param)) throw new IllegalArgumentException("HHMMSS invalido o ausente.");
            if (date == null || !validateDate(date)) throw new IllegalArgumentException("DATE invalida o ausente.");
            LocalDate d = LocalDate.parse(this.date, DateTimeFormatter.BASIC_ISO_DATE);
            String yymmdd = String.format("%02d%02d%02d", d.getYear() % 100, d.getMonthValue(), d.getDayOfMonth());
            String queryName = "YTF.AR.T" + tCode + ".F." + FIXED_ENTITY_Txx + ".D" + yymmdd + ".T" + param + ".A001";
            
            if (downloadSingleFile(queryName)) {
                logger.info("*** Descarga completada [OK]");
            } else {
                logger.severe("*** Archivo no encontrado [FAIL]");
            }
        }
        
        private void runDownloadByExactName() {
            logger.info("=== OPCION 5: Descarga por nombre completo ===");
            if (param == null) throw new IllegalArgumentException("Nombre completo vacio.");
            if (downloadSingleFile(param)) {
                logger.info("*** Descarga completada [OK]");
            } else {
                logger.severe("*** Archivo no encontrado [FAIL]");
            }
        }
        
        private void runDownloadByPattern() {
            logger.info("=== OPCION 6: Descarga por Patrón ===");
            if (param == null || date == null || dateEnd == null) throw new IllegalArgumentException("Argumentos para patron incompletos.");
            logger.info(String.format("Patrón: %s | Fechas: %s-%s | Secuencias: %d-%d", param, date, dateEnd, seqStart, seqEnd));

            DateTimeFormatter formatter = DateTimeFormatter.BASIC_ISO_DATE;
            LocalDate start = LocalDate.parse(date, formatter);
            LocalDate end = LocalDate.parse(dateEnd, formatter);
            int downloadedCount = 0;

            for (LocalDate d = start; !d.isAfter(end); d = d.plusDays(1)) {
                String yymmdd = String.format("%02d%02d%02d", d.getYear() % 100, d.getMonthValue(), d.getDayOfMonth());
                for (int i = seqStart; i <= seqEnd; i++) {
                    // Formato de nombre de archivo. AJUSTAR SEGUN SEA NECESARIO.
                    // Ejemplo: YTF.AR.T112.F.E0002840.D251009.A001
                    // Aquí usamos un formato simple: PREFIX + .DYYMMDD. + AXXX
                    String sequence = String.format("A%03d", i);
                    String queryName = param + ".D" + yymmdd + "." + sequence;
                    
                    if (downloadSingleFile(queryName)) {
                        downloadedCount++;
                    }
                }
            }
            logger.info("Búsqueda finalizada. Total de archivos descargados: " + downloadedCount);
        }

        private boolean downloadSingleFile(String fullName) {
            logger.info("Intentando descargar: " + fullName);
            try (Socket sock = new Socket()) {
                sock.connect(new InetSocketAddress(cfg.host, cfg.port), cfg.connectTimeoutMs);
                sock.setSoTimeout(cfg.soTimeoutMs);

                writeNameFrame(sock, fullName);

                StringBuilder rawAcc = new StringBuilder();
                boolean moreData = true;
                while (moreData) {
                    String chunk = readLegacyBlock(sock);
                    rawAcc.append(chunk);
                    // Usamos "998010" como señal de fin, igual que el programa original.
                    if (chunk.isEmpty() || rawAcc.toString().contains("998010")) {
                        moreData = false;
                    }
                }

                // -- L ORIGINAL (ELIMINADA) --
                // if (containsAny(rawAcc.toString(), cfg.acceptedCodes)) {
                //     logger.info("-> Archivo encontrado [OK]. Guardando...");
                //     writeRawToNamedFile(fullName, rawAcc.toString());
                //     return true;
                // } else {
                //     logger.info("-> Archivo no encontrado o respuesta invalida.");
                //     return false;
                // }
                
                // --  NUEVA 
                // Ahora, simplemente verificamos si recibimos CUALQUIER dato.
                if (rawAcc.length() > 0) {
                    logger.info("-> Respuesta recibida del servidor (" + rawAcc.length() + " caracteres). Guardando sin validar el código.");
                    writeRawToNamedFile(fullName, rawAcc.toString());
                    return true; // Se considera "éxito" si se recibió y guardó algo.
                } else {
                    logger.info("-> No se recibio ninguna respuesta del servidor.");
                    return false;
                }

            } catch (Exception e) {
                logger.warning("Error al intentar descargar " + fullName + ": " + e.getMessage());
                return false;
            }
        }

        // =================================================================================
        // == LOGICA DE COMUNICACION Y TRADUCCION EBCDIC (IMPORTADA DE GCO_MIP)
        // =================================================================================

        private static void writeNameFrame(Socket s, String text) throws IOException {
            byte[] body = translateStringToEbcdicCustom(text);
            writeFrameRaw(s, body);
        }

        private static void writeChunkFrame(Socket s, byte[] asciiChunk) throws IOException {
            ByteArrayOutputStream baos = new ByteArrayOutputStream(1 + asciiChunk.length);
            baos.write((byte) 'R');
            baos.write(asciiChunk);
            String asText = new String(baos.toByteArray(), StandardCharsets.US_ASCII);
            byte[] body = translateStringToEbcdicCustom(asText);
            writeFrameRaw(s, body);
        }
        
        private static void writeTrailerFrame(Socket s, int count, String trailerCode7) throws IOException {
             byte[] prefix = translateStringToEbcdicCustom(trailerCode7);
             byte[] cntRaw = lengthToBytes(count, 4);
             // Replicar logica de GCO_MIP para el contador en el trailer
             byte[] cntFinal = new byte[4];
             for(int i=0; i<4; i++) {
                 cntFinal[i] = (byte)translateByteForDiscrepancy(cntRaw[i]);
             }
             
             byte[] body = new byte[11];
             System.arraycopy(prefix, 0, body, 0, 7);
             System.arraycopy(cntFinal, 0, body, 7, 4);
             writeFrameRaw(s, body);
        }

        private static void writeFrameRaw(Socket s, byte[] body) throws IOException {
            byte[] header = lengthToBytes(body.length, 2);
            OutputStream os = s.getOutputStream();
            os.write(header);
            os.write(body);
            os.flush();
        }
        
        private static String readResponse(Socket s) throws IOException {
             ByteArrayOutputStream baos = new ByteArrayOutputStream();
             InputStream is = s.getInputStream();
             byte[] buf = new byte[1024];
             try {
                 int n = is.read(buf);
                 if (n > 0) {
                     baos.write(buf, 0, n);
                 }
             } catch (SocketTimeoutException ignored) {
                 if (baos.size() == 0) throw ignored;
             }
             byte[] ebcdicBytes = baos.toByteArray();
             return translateEbcdicToStringCustom(ebcdicBytes, ebcdicBytes.length);
        }

        private static String readLegacyBlock(Socket s) throws IOException {
            InputStream is = s.getInputStream();
            byte[] buf = new byte[1024];
            int n = -1;
            try {
                n = is.read(buf, 0, 1024);
            } catch (SocketTimeoutException e) {
                return ""; // Timeout sin datos es como un chunk vacío.
            }

            if (n <= 0) return "";
            
            String decoded = translateEbcdicToStringCustom(buf, n);

            StringBuilder out = new StringBuilder(decoded.length());
            for (int i = 0; i < decoded.length(); i++) {
                char c = decoded.charAt(i);
                if (c >= ' ' && c <= '~' || c == '\n') out.append(c);
            }
            return out.toString();
        }

        private static byte[] translateStringToEbcdicCustom(String text) {
            byte[] originalBytes = text.getBytes(StandardCharsets.US_ASCII);
            byte[] ebcdicBytes = new byte[originalBytes.length];
            for (int i = 0; i < originalBytes.length; i++) {
                ebcdicBytes[i] = (byte) translateByte("toEBC", originalBytes[i]);
            }
            return ebcdicBytes;
        }

        private static String translateEbcdicToStringCustom(byte[] ebcdicBytes, int length) {
            StringBuilder asciiString = new StringBuilder();
            for (int i = 0; i < length; i++) {
                 int ebcdicChar = ebcdicBytes[i] & 0xFF; // Asegurarse de que es un valor positivo 0-255
                 char asciiChar = (char) translateByte("toASC", ebcdicChar);
                 asciiString.append(asciiChar);
            }
            return asciiString.toString();
        }

        private static int translateByte(final String translationType, final int paramInt) {
            final int[] asciiArray  = { 32, 33,  34,  35, 36,  37, 38,  39, 40, 41, 42, 43,  44, 45, 46, 47,  48,  49,  50,  51,  52,  53,  54,  55,  56,  57,  58, 59, 60,  61,  62,  63,  64,  65,  66,  67,  68,  69,  70,  71,  72,  73,  74,  75,  76,  77,  78,  79,  80,  81,  82,  83,  84,  85,  86,  87,  88,  89,  90,  91,  92,  93, 94,  95,  96,  97,  98,  99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126 };
            final int[] ebcdicArray = { 64, 90, 127, 123, 91, 108, 80, 125, 77, 93, 92, 78, 107, 96, 75, 97, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 122, 94, 76, 126, 110, 111, 124, 193, 194, 195, 196, 197, 198, 199, 200, 201, 209, 210, 211, 212, 213, 214, 215, 216, 217, 226, 227, 228, 229, 230, 231, 232, 233, 173, 224, 189, 95, 109, 121, 129, 130, 131, 132, 133, 134, 135, 136, 137, 145, 146, 147, 148, 149, 150, 151, 152, 153, 162, 163, 164, 165, 166, 167, 168, 169, 192, 106, 208, 161 };
            for (int i = 0; i < asciiArray.length; i++) {
                if (translationType.equals("toEBC")) { if (paramInt == asciiArray[i]) return ebcdicArray[i]; }
                else { if (paramInt == ebcdicArray[i]) return asciiArray[i]; }
            }
            return paramInt;
        }
        
        private static int translateByteForDiscrepancy(final int paramInt) {
            return paramInt;
        }
        // =================================================================================
        // == FIN DE LA LOGICA DE COMUNICACION
        // =================================================================================


        // ----------------------------- Utilidades (el resto del código) -----------------------------

        private static boolean matchesAny(String value, List<String> options) { if (options == null || options.isEmpty()) return false; for (String o : options) if (value.equals(o)) return true; return false; }
        private static boolean containsAny(String haystack, List<String> options) { if (options == null || options.isEmpty()) return false; for (String o : options) if (haystack.contains(o)) return true; return false; }
        
        static String generateFileNameFromTemplate(String template, String yyyymmdd) {
             if (template == null || template.trim().isEmpty()) { throw new IllegalArgumentException("fileNameTemplate no definido en el INI."); }
             String base = template.trim(); LocalDate d = LocalDate.parse(yyyymmdd, DateTimeFormatter.BASIC_ISO_DATE);
             String ddmm = String.format("%02d%02d", d.getDayOfMonth(), d.getMonthValue());
             base = base.replaceAll("(?i)\\{ddmm\\}", ddmm);
             if (base.matches("(?i).*\\{rand\\}.*")) { String rand4 = String.format("%04d", new Random().nextInt(10000)); base = base.replaceAll("(?i)\\{rand\\}", rand4); }
             base = base.toUpperCase(Locale.ROOT);
             if (base.length() != 9) { throw new IllegalArgumentException("fileNameTemplate debe producir 9 caracteres. Obtenido '" + base + "'"); }
             return base;
        }

        private static String applyNameTemplate(String template, String fileName, String yyyymmdd) {
            LocalDate d = LocalDate.parse(yyyymmdd, DateTimeFormatter.BASIC_ISO_DATE);
            String julian = String.format("%03d", d.getDayOfYear());
            String out = template;
            out = out.replaceAll("(?i)\\{file\\}", java.util.regex.Matcher.quoteReplacement(fileName));
            out = out.replaceAll("(?i)\\{julian\\}", julian);
            return out;
        }
        
        private static byte[] readPayload(Path p) {
            logger.info("Leyendo payload: " + p.toAbsolutePath());
            try {
                byte[] data = Files.readAllBytes(p);
                logger.info("Tamano payload: " + data.length + " bytes");
                return data;
            } catch (Exception e) {
                throw new RuntimeException("Error leyendo archivo: " + p + " - " + e.getMessage(), e);
            }
        }
        private static List<byte[]> split(byte[] data, int chunkSize) {
            List<byte[]> parts = new ArrayList<>();
            for (int off = 0; off < data.length; off += chunkSize) {
                int len = Math.min(chunkSize, data.length - off);
                parts.add(Arrays.copyOfRange(data, off, off + len));
            }
            return parts;
        }
        private static byte[] lengthToBytes(int num, int byts) {
            byte[] r = new byte[byts];
            for (int i = byts - 1; i >= 0; --i) { r[i] = (byte)(num & 0xFF); num >>>= 8; }
            return r;
        }
        
        private static void validateEnvironmentForSend(Config cfg) {
            File cwd = new File(System.getProperty("user.dir"));
            if (!cwd.canRead() || !cwd.canExecute()) {
                throw new IllegalStateException("El directorio actual no tiene permisos suficientes (lectura y ejecucion).");
            }
            File dataFile = cfg.dataFilePath.toFile();
            if (!dataFile.exists() || !dataFile.isFile() || !dataFile.canRead()) {
                throw new IllegalStateException("No existe el archivo de datos o no hay permisos de lectura: " + cfg.dataFilePath);
            }
            File histFile = cfg.historyFilePath.toFile();
            File histDir  = histFile.getAbsoluteFile().getParentFile();
            if (histDir != null && (!histDir.canWrite() || !histDir.canExecute())) {
                throw new IllegalStateException("El directorio del historico no permite escribir/ejecutar: " + histDir.getAbsolutePath());
            }
            try (FileChannel ignore = FileChannel.open(cfg.historyFilePath, StandardOpenOption.CREATE, StandardOpenOption.WRITE, StandardOpenOption.APPEND)) {
                // OK
            } catch (IOException e) {
                throw new IllegalStateException("No se puede crear/escribir en el historico: " + cfg.historyFilePath, e);
            }
        }

        private static void validateEnvironmentForReport() {
            File cwd = new File(System.getProperty("user.dir"));
            if (!cwd.canRead() || !cwd.canExecute() || !cwd.canWrite()) {
                throw new IllegalStateException("El directorio actual no tiene permisos suficientes (lectura/ejecucion/escritura).");
            }
        }
        
        private static void createShippingHistory(String respCode, String fileName, String dateYYYYMMDD, Path historyPath) {
            try {
                String record = "[" + respCode + "-" + fileName + "-" + dateYYYYMMDD + ": " + LocalDateTime.now().format(DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss")) + "]";
                List<String> lines = new ArrayList<>();
                if (Files.exists(historyPath)) {
                    try {
                        lines = Files.readAllLines(historyPath, StandardCharsets.UTF_8);
                    } catch (MalformedInputException ignored) {}
                }
                lines.add(0, record);
                Files.write(historyPath, String.join(System.lineSeparator(), lines).getBytes(StandardCharsets.UTF_8), StandardOpenOption.CREATE, StandardOpenOption.TRUNCATE_EXISTING, StandardOpenOption.WRITE);
                logger.info("Historico actualizado: " + historyPath);
            } catch (Exception e) {
                logger.severe("No se pudo actualizar el historico: " + e.getMessage());
            }
        }
        
        private static void writeDataToFile(String dateYYYYMMDD, String data, String fileNameAnyLen) throws IOException {
            String prefix = (fileNameAnyLen != null && fileNameAnyLen.length() >= 4) ? fileNameAnyLen.substring(0, 4) : "REPORT";
            String reportName = prefix + "-" + dateYYYYMMDD + "-Archivo de Cambio Confirmacion";
            logger.info("Nombre de reporte generado: " + reportName);
            try (FileOutputStream fos = new FileOutputStream(reportName); PrintStream ps = new PrintStream(fos, true, "UTF-8")) {
                ps.print(data);
            }
            logger.info("Reporte: " + reportName + " [GENERADO]");
        }

        private static String orderDetails(String dataMipDato, String allOkCode) {
            // Esta es una función compleja de parseo. La mantengo simple aquí.
            // Para una implementación completa, se debería copiar la lógica detallada de GCO_MIP.
            logger.info("Parseando contenido del reporte (lógica simplificada)...");
            return dataMipDato.replace("[","").replace("]\n","\n");
        }

        private static void writeRawToNamedFile(String fileName, String data) throws IOException {
            // Reemplazar caracteres no válidos para nombres de archivo en Windows/Linux
            String safeFileName = fileName.replaceAll("[^a-zA-Z0-9.-]", "_");
            try (FileOutputStream fos = new FileOutputStream(safeFileName); PrintStream ps = new PrintStream(fos, true, "UTF-8")) {
                ps.print(data);
            }
            logger.info("Archivo escrito: " + safeFileName);
        }
    }
}
