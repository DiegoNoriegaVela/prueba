import java.io.*;
import java.net.*;
import java.nio.charset.Charset;
import java.nio.file.*;
import java.time.*;
import java.time.format.DateTimeFormatter;
import java.util.*;
import java.util.logging.Logger;

public class McBatchSender {
    private static final Logger logger = Logger.getLogger(McBatchSender.class.getName());
    private static final Charset EBCDIC = Charset.forName("Cp037");

    // ============================== MAIN ==============================
    public static void main(String[] args) {
        try {
            if (args == null || args.length == 0) {
                Interactive.run();
                return;
            }
            int option = Integer.parseInt(args[0].trim());

            if (option == 4) {
                if (args.length < 4) {
                    System.err.println("Uso: java McBatchSender 4 <IP> <PUERTO> <FULL_NAME>");
                    System.exit(2);
                }
                String ip = args[1].trim();
                int port = Integer.parseInt(args[2].trim());
                String fullName = args[3].trim();

                IniFile ini = IniFile.load(Paths.get("mcsender.ini"));
                General general = General.from(ini);
                Sender.runManualSend(general, ip, port, fullName);
                return;
            }

            if (args.length < 4) {
                System.err.println("Uso: java McBatchSender <OPCION> <SECCION> <FILE> <YYYYMMDD>");
                System.exit(2);
            }

            String section = args[1].trim();
            String fileParam = args[2].trim();
            String yyyymmdd = args[3].trim();

            if (!validateDate(yyyymmdd)) {
                System.err.println("Fecha invalida: " + yyyymmdd);
                System.exit(4);
            }

            IniFile ini = IniFile.load(Paths.get("mcsender.ini"));
            General general = General.from(ini);
            Business biz = Business.from(ini, section);

            final boolean isMIP = isMIPSection(section);

            if (option == 1) {
                Sender.runSend(general, biz, fileParam, yyyymmdd);
            } else if (option == 2) {
                Sender.runReport(general, biz, fileParam, yyyymmdd, isMIP);
            } else if (option == 3) {
                Sender.runDownload(general, biz, fileParam, yyyymmdd);
            } else {
                System.err.println("Opcion invalida.");
                System.exit(4);
            }
        } catch (NoSuchFileException e) {
            System.err.println("INI no encontrado: " + e.getFile());
            System.exit(3);
        } catch (Exception e) {
            System.err.println("Error: " + e.getMessage());
            System.exit(1);
        }
    }

    // ============================== CONFIG ==============================

    static class General {
        final int connectTimeoutMs;
        final int soTimeoutMs;
        final int chunkSize;
        final List<String> acceptedCode;
        final String alreadySentSubstring;
        final String defaultFailCode;

        General(int cto, int sto, int chunk, List<String> acc, String already, String fail) {
            this.connectTimeoutMs = cto;
            this.soTimeoutMs = sto;
            this.chunkSize = chunk;
            this.acceptedCode = acc;
            this.alreadySentSubstring = already;
            this.defaultFailCode = fail;
        }

        static General from(IniFile ini) {
            Map<String,String> g = ini.section("GENERAL");
            if (g == null) throw new IllegalArgumentException("Falta seccion [GENERAL]");

            int cto = parseIntStrict(g.getOrDefault("connectTimeoutMs","60000"), 1000, 300000, "connectTimeoutMs");
            int sto = parseIntStrict(g.getOrDefault("soTimeoutMs","60000"), 1000, 300000, "soTimeoutMs");
            int chunk = parseIntStrict(g.getOrDefault("chunkSize","980"), 2, 65535, "chunkSize");
            List<String> acc = parseList(g.getOrDefault("acceptedCode","9980100"));
            String already = g.getOrDefault("alreadySentSubstring","9288W");
            String fail = g.getOrDefault("defaultFailCode","9980101");
            return new General(cto, sto, chunk, acc, already, fail);
        }
    }

    static class Business {
        final String host;
        final int port;
        final String originalFile;
        final String historyFile;
        final String formatSendMC;
        final String formatRecieveMC;

        Business(String host, int port, String of, String hf, String fs, String fr) {
            this.host = host;
            this.port = port;
            this.originalFile = of;
            this.historyFile = hf;
            this.formatSendMC = fs;
            this.formatRecieveMC = fr;
        }

        static Business from(IniFile ini, String section) {
            Map<String,String> s = ini.section(section);
            if (s == null) throw new IllegalArgumentException("No existe la seccion ["+section+"]");

            // ✅ Usar 'hostRef' como en el INI
            String hostSec = s.getOrDefault("hostRef", s.getOrDefault("hostSection", "HOST_MC"));
            Map<String,String> hs = ini.section(hostSec);
            if (hs == null) throw new IllegalArgumentException("No existe la seccion ["+hostSec+"]");
            String host = req(hs, "host");
            int port = parseIntStrict(req(hs, "port"), 1, 65535, "port");

            String of = req(s, "originalFile");
            String hf = req(s, "historyFile");
            String fs = req(s, "formatSendMC");
            String fr = req(s, "formatRecieveMC");

            return new Business(host, port, of, hf, fs, fr);
        }
    }

    // ============================== INI SIMPLE ==============================

    static class IniFile {
        private final Map<String, Map<String,String>> data = new LinkedHashMap<>();
        private IniFile() {}

        static IniFile load(Path path) throws IOException {
            if (!Files.exists(path)) throw new NoSuchFileException(path.toString());
            IniFile f = new IniFile();
            Map<String,String> cur = null;

            for (String raw : Files.readAllLines(path)) {
                String line = raw.trim();
                if (line.isEmpty() || line.startsWith("#") || line.startsWith(";")) continue;
                if (line.startsWith("[") && line.endsWith("]")) {
                    String name = line.substring(1, line.length()-1).trim();
                    cur = new LinkedHashMap<>();
                    f.data.put(name, cur);
                } else if (cur != null) {
                    int p = line.indexOf('=');
                    if (p > 0) {
                        String k = line.substring(0, p).trim();
                        String v = line.substring(p+1).trim();
                        cur.put(k, v);
                    }
                }
            }
            return f;
        }

        Map<String,String> section(String name) { return data.get(name); }
    }

    // ============================== SENDER ==============================
    static class Sender {

        // ------------------- Opcion 1: Envio -------------------
        static void runSend(General g, Business b, String fileParam, String yyyymmdd) {
            logger.info("=== OPCION 1: Envio ===");
            logger.info("Host: " + b.host + " Puerto: " + b.port);

            File cwd = new File(System.getProperty("user.dir"));
            if (!cwd.exists() || !cwd.isDirectory()) {
                throw new IllegalStateException("CWD invalido");
            }
            if (!cwd.canRead() || !cwd.canExecute()) {
                throw new IllegalStateException("CWD sin permisos de lectura/ejecucion");
            }
            Path dataFile = Paths.get(b.originalFile);
            Path history = Paths.get(b.historyFile);

            byte[] payload = readAllBytesOrEmpty(dataFile);
            if (payload.length == 0) {
                logger.warning("Archivo de datos vacio: " + dataFile);
                createHistoryRecord(g.defaultFailCode, fileParam, yyyymmdd, history);
                logger.info("=== FIN OPCION 1 ===");
                return;
            }

            List<byte[]> parts = splitWithPrefixR(payload, g.chunkSize);
            String nameToSend = applyFormat(b.formatSendMC, fileParam, yyyymmdd);

            logger.info("Nombre a enviar  : " + nameToSend);
            logger.info("Partes a enviar  : " + parts.size());
            logger.info("ChunkSize (bytes): " + g.chunkSize);

            String finalStatus = g.defaultFailCode;
            try (Socket sock = new Socket()) {
                sock.connect(new InetSocketAddress(b.host, b.port), g.connectTimeoutMs);
                sock.setSoTimeout(g.soTimeoutMs);

                writeFrameName(sock, nameToSend);

                int count = 0;
                for (byte[] p : parts) {
                    writeFrameData(sock, p);
                    count++;
                }

                writeTrailer(sock, count);

                String resp = readResponse(sock);
                logger.info("Resp (envio): " + preview80(resp));

                if (resp != null && resp.contains(g.alreadySentSubstring)) {
                    logger.warning("*** Advertencia: el servidor indico que ya estaba enviado (" + g.alreadySentSubstring + ")");
                    finalStatus = g.defaultFailCode;
                } else if (hasAccepted(resp, g.acceptedCode)) {
                    finalStatus = firstAcceptedOrDefault(g);
                    logger.info("Envio OK (" + finalStatus + ")");
                } else {
                    logger.severe("*** Envio FALLIDO (sin acceptedCode)");
                    finalStatus = g.defaultFailCode;
                }
            } catch (Exception ex) {
                logger.severe("Error envio: " + ex.getMessage());
            } finally {
                createHistoryRecord(finalStatus, fileParam, yyyymmdd, history);
                logger.info("=== FIN OPCION 1 ===");
            }
        }

        // ------------------- Opcion 2: Descarga y genera reporte -------------------
        static void runReport(General g, Business b, String fileParam, String yyyymmdd, boolean isMIP) {
            logger.info("=== OPCION 2: Descarga y genera reporte ===");
            logger.info("Host: " + b.host + " Puerto: " + b.port);

            String base = applyFormat(b.formatRecieveMC, fileParam, yyyymmdd);
            logger.info("Nombre base: " + base);

            boolean found = false;
            String foundQuery = null;
            StringBuilder allChunks = new StringBuilder();

            try (Socket sock = new Socket()) {
                sock.connect(new InetSocketAddress(b.host, b.port), g.connectTimeoutMs);
                sock.setSoTimeout(g.soTimeoutMs);

                // Buscar el archivo correcto (01, 02, 03...)
                for (int i = 1; i <= 99; i++) {
                    String sec = String.format("%02d", i);
                    String query = base + sec;

                    logger.info("Consultando: " + query);
                    writeFrameName(sock, query);

                    // ✅ Leer TODOS los chunks de ESTE archivo consultado
                    allChunks = new StringBuilder();
                    boolean moreData = true;
                    
                    while (moreData) {
                        String chunk = readSingleChunk(sock);
                        allChunks.append(chunk);
                        
                        // Verifica si llegó el código de éxito
                        if (chunk.contains("998010")) {
                            moreData = false;
                        }
                    }

                    // ✅ Verifica si ESTE archivo específico existe
                    String accumulated = allChunks.toString();
                    if (hasAccepted(accumulated, g.acceptedCode)) {
                        found = true;
                        foundQuery = query;
                        logger.info("Archivo encontrado [OK]");
                        break;
                    } else {
                        logger.info("Buscando...");
                    }
                }

                if (!found) {
                    logger.severe("*** Archivo no encontrado [FAIL]");
                    String errorDump = allChunks.toString();
                    logger.info("[Preview 80B] " + preview80(errorDump));
                    writeErrorDump(fileParam, yyyymmdd, errorDump);
                    logger.info("=== FIN OPCION 2 ===");
                    return;
                }

                String rawContent = allChunks.toString();

                if (isMIP) {
                    // ✅ MIP: Genera reporte formateado
                    String dataToWrite;
                    String allOk = firstAcceptedOrDefault(g);
                    try {
                        dataToWrite = orderDetailsMIP(rawContent, allOk);
                    } catch (Exception ex) {
                        logger.severe("Error al ordenar; se guarda crudo");
                        dataToWrite = rawContent;
                    }
                    writeReportFile(yyyymmdd, dataToWrite, fileParam);
                    logger.info("Reporte MIP generado OK");
                } else {
                    // ✅ GCO: Guarda en crudo con el nombre del archivo consultado
                    writeRawWithQueryName(foundQuery, rawContent);
                    logger.info("Archivo GCO descargado OK (crudo): " + foundQuery);
                }

            } catch (Exception ex) {
                logger.severe("Error reporte: " + ex.getMessage());
            } finally {
                logger.info("=== FIN OPCION 2 ===");
            }
        }

        // ------------------- Opcion 3: Descarga cruda -------------------
        static void runDownload(General g, Business b, String fileParam, String yyyymmdd) {
            logger.info("=== OPCION 3: Descarga ===");
            logger.info("Host: " + b.host + " Puerto: " + b.port);

            String base = applyFormat(b.formatRecieveMC, fileParam, yyyymmdd);
            logger.info("Nombre base: " + base);

            boolean found = false;
            String foundName = null;
            StringBuilder allChunks = new StringBuilder();

            try (Socket sock = new Socket()) {
                sock.connect(new InetSocketAddress(b.host, b.port), g.connectTimeoutMs);
                sock.setSoTimeout(g.soTimeoutMs);

                // Buscar el archivo correcto (01, 02, 03...)
                for (int i = 1; i <= 99; i++) {
                    String sec = String.format("%02d", i);
                    String query = base + sec;

                    logger.info("Consultando: " + query);
                    writeFrameName(sock, query);

                    // ✅ Leer TODOS los chunks de ESTE archivo consultado
                    allChunks = new StringBuilder();
                    boolean moreData = true;
                    
                    while (moreData) {
                        String chunk = readSingleChunk(sock);
                        allChunks.append(chunk);
                        
                        // Verifica si llegó el código de éxito
                        if (chunk.contains("998010")) {
                            moreData = false;
                        }
                    }

                    // ✅ Verifica si ESTE archivo específico existe
                    String accumulated = allChunks.toString();
                    if (hasAccepted(accumulated, g.acceptedCode)) {
                        found = true;
                        foundName = query;
                        logger.info("Archivo encontrado [OK]");
                        break; // ✅ Encontró el archivo, sale del loop
                    } else {
                        logger.info("Buscando...");
                    }
                }

                if (!found) {
                    logger.severe("*** Archivo no encontrado [FAIL]");
                    String errorDump = allChunks.toString();
                    logger.info("[Preview 80B] " + preview80(errorDump));
                    writeErrorDump(fileParam, yyyymmdd, errorDump);
                    logger.info("=== FIN OPCION 3 ===");
                    return;
                }

                // ✅ Construir con el nombre encontrado + TODO el contenido
                String finalContent = "[" + foundName + "]\n" + allChunks.toString();
                writeRawDownloadFile(yyyymmdd, finalContent, fileParam);
                logger.info("Descarga OK");
                logger.info("[Preview 80B] " + preview80(finalContent));

            } catch (Exception ex) {
                logger.severe("Error descarga: " + ex.getMessage());
            } finally {
                logger.info("=== FIN OPCION 3 ===");
            }
        }

        // ------------------- Opcion 4: Envio manual -------------------
        static void runManualSend(General g, String ip, int port, String fullName) {
            logger.info("=== OPCION 4: Envio manual ===");
            logger.info("Host: " + ip + " Puerto: " + port);
            logger.info("Nombre a enviar: " + fullName);

            try (Socket sock = new Socket()) {
                sock.connect(new InetSocketAddress(ip, port), g.connectTimeoutMs);
                sock.setSoTimeout(g.soTimeoutMs);

                writeFrameName(sock, fullName);

                // ✅ Leer TODOS los chunks que envíe el servidor
                StringBuilder allData = new StringBuilder();
                boolean moreData = true;
                
                while (moreData) {
                    try {
                        String chunk = readSingleChunk(sock);
                        allData.append(chunk);
                        
                        if (chunk.contains("998010")) {
                            moreData = false;
                        }
                    } catch (SocketTimeoutException e) {
                        // No hay más datos
                        moreData = false;
                    }
                }

                String finalData = allData.toString();

                // Escribir exactamente en el archivo indicado
                try (PrintStream ps = new PrintStream(new FileOutputStream(fullName), true, "UTF-8")) {
                    ps.print(finalData);
                }

                logger.info("Resp: [" + finalData.trim() + "]");
            } catch (Exception ex) {
                logger.severe("Error envio manual: " + ex.getMessage());
            } finally {
                logger.info("=== FIN OPCION 4 ===");
            }
        }

        // ==================== I/O de red y framing ====================

        private static void writeFrameName(Socket s, String name) throws IOException {
            byte[] body = toEbcdic(name.getBytes("UTF-8"));
            writeRawFrame(s, body);
        }

        private static void writeFrameData(Socket s, byte[] asciiChunkWithR) throws IOException {
            byte[] body = toEbcdic(asciiChunkWithR);
            writeRawFrame(s, body);
        }

        private static void writeTrailer(Socket s, int count) throws IOException {
            String ok = "9980100";
            byte[] pre = toEbcdic(ok.getBytes("UTF-8"));
            byte[] cntBE = intToBytesBE(count, 4);
            for (int i = 0; i < cntBE.length; i++) {
                cntBE[i] = (byte) translateByteForDiscrepancy(cntBE[i] & 0xFF);
            }
            byte[] cnt = toEbcdic(cntBE);
            byte[] body = new byte[11];
            System.arraycopy(pre, 0, body, 0, 7);
            System.arraycopy(cnt, 0, body, 7, 4);
            writeRawFrame(s, body);
        }

        private static void writeRawFrame(Socket s, byte[] body) throws IOException {
            int len = body.length;
            byte[] header = intToBytesBE(len, 2);
            OutputStream os = s.getOutputStream();
            os.write(header);
            os.write(body);
            os.flush();
        }

        private static String readResponse(Socket s) throws IOException {
            ByteArrayOutputStream baos = new ByteArrayOutputStream();
            InputStream is = s.getInputStream();
            byte[] buf = new byte[4096];
            int n;
            while (true) {
                try {
                    n = is.read(buf);
                    if (n == -1) break;
                    baos.write(buf, 0, n);
                    if (n < buf.length) break;
                } catch (SocketTimeoutException te) {
                    if (baos.size() == 0) throw te;
                    break;
                }
            }
            byte[] ebcdicBytes = baos.toByteArray();
            if (ebcdicBytes.length == 0) return "";
            return fromEbcdic(ebcdicBytes);
        }

        // ✅ NUEVO: Lee UN SOLO chunk (como InSocket del original)
        private static String readSingleChunk(Socket s) throws IOException {
            InputStream is = s.getInputStream();
            byte[] buf = new byte[1024];
            int n = is.read(buf, 0, 1024);
            if (n <= 0) return "";
            
            String decoded = fromEbcdic(Arrays.copyOf(buf, n));
            
            // Sanitizar a ASCII visible + saltos de linea
            StringBuilder out = new StringBuilder(decoded.length());
            for (int i = 0; i < decoded.length(); i++) {
                char c = decoded.charAt(i);
                if (c >= ' ' && c <= '~') out.append(c);
                else if (c == '\n') out.append('\n');
            }
            return out.toString();
        }

        // ==================== Archivos locales ====================

        private static byte[] readAllBytesOrEmpty(Path p) {
            try { return Files.readAllBytes(p); }
            catch (Exception e) { return new byte[0]; }
        }

        private static List<byte[]> splitWithPrefixR(byte[] payload, int chunkSize) {
            List<byte[]> out = new ArrayList<>();
            int maxDataPerChunk = Math.max(1, chunkSize - 1);
            int pos = 0;
            while (pos < payload.length) {
                int len = Math.min(maxDataPerChunk, payload.length - pos);
                byte[] part = new byte[len + 1];
                part[0] = 'R';
                System.arraycopy(payload, pos, part, 1, len);
                out.add(part);
                pos += len;
            }
            return out;
        }

        private static void writeReportFile(String yyyymmdd, String content, String fileName9) throws IOException {
            String name = reportFileName(yyyymmdd, fileName9);
            try (PrintStream ps = new PrintStream(new FileOutputStream(name), true, "UTF-8")) {
                ps.print(content == null ? "" : content);
            }
            logger.info("Reporte escrito: " + name);
        }

        private static void writeRawDownloadFile(String yyyymmdd, String data, String fileParam) throws IOException {
            String out = (fileParam == null || fileParam.isEmpty()) ? "DESCARGA" : fileParam;
            String name = out + "-" + yyyymmdd + ".out";
            try (PrintStream ps = new PrintStream(new FileOutputStream(name), true, "UTF-8")) {
                ps.print(data == null ? "" : data);
            }
            logger.info("Archivo escrito: " + name);
        }

        private static void writeRawWithQueryName(String queryName, String data) throws IOException {
            String name = (queryName == null || queryName.isEmpty()) ? "ARCHIVO_CRUDO" : queryName;
            try (PrintStream ps = new PrintStream(new FileOutputStream(name), true, "UTF-8")) {
                ps.print(data == null ? "" : data);
            }
            logger.info("Archivo escrito: " + name);
        }

        private static void createHistoryRecord(String respCode, String fileName, String yyyymmdd, Path historyPath) {
            try {
                String record = "[" + respCode + "-" + fileName + "-" + yyyymmdd + ": " +
                        LocalDateTime.now().format(DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss")) + "]";
                prependLine(historyPath, record);
            } catch (Exception e) {
                logger.severe("No se pudo actualizar el historico: " + e.getMessage());
            }
        }

        private static void prependLine(Path path, String line) throws IOException {
            List<String> lines = new ArrayList<>();
            if (Files.exists(path)) {
                try { lines = Files.readAllLines(path); } catch (Exception ignore) {}
            }
            lines.add(0, line);
            Files.write(path, String.join(System.lineSeparator(), lines).getBytes(),
                    StandardOpenOption.CREATE, StandardOpenOption.TRUNCATE_EXISTING, StandardOpenOption.WRITE);
        }

        private static String reportFileName(String yyyymmdd, String fileName9) {
            String prefix = (fileName9 == null || fileName9.length() < 4) ? "FILE" : fileName9.substring(0, 4);
            return prefix + "-" + yyyymmdd + "-Archivo de Cambio Confirmacion";
        }
    }

    // ============================== HELPERS GLOBALES ==============================

    private static boolean isMIPSection(String sectionName) {
        return sectionName != null && sectionName.trim().equalsIgnoreCase("MIP");
    }

    private static boolean hasAccepted(String text, List<String> acceptedCodes) {
        if (text == null || acceptedCodes == null || acceptedCodes.isEmpty()) return false;
        for (String c : acceptedCodes) {
            if (c != null && !c.isEmpty() && text.contains(c)) return true;
        }
        return false;
    }

    private static String firstAcceptedOrDefault(General g) {
        if (g != null && g.acceptedCode != null) {
            for (String c : g.acceptedCode) {
                if (c != null && !c.trim().isEmpty()) {
                    return c.trim();
                }
            }
        }
        return (g != null && g.defaultFailCode != null && !g.defaultFailCode.isEmpty())
                ? g.defaultFailCode
                : "9980101";
    }

    private static String preview80(String s) {
        if (s == null) return "";
        String p = s.replace("\r", " ").replace("\n", " ");
        return p.length() > 80 ? p.substring(0, 80) : p;
    }

    private static void writeErrorDump(String fileParam, String yyyymmdd, String content) {
        String safe = (fileParam == null || fileParam.isEmpty()) ? "NONAME" : fileParam;
        String outName = "ERROR_" + safe;
        try (PrintStream ps = new PrintStream(new FileOutputStream(outName), true, "UTF-8")) {
            ps.print(content == null ? "" : content);
        } catch (Exception e) {
            logger.severe("No se pudo escribir " + outName + ": " + e.getMessage());
        }
    }

    private static String applyFormat(String template, String file, String yyyymmdd) {
        if (template == null) template = "";
        if (file == null) file = "";
        LocalDate d = LocalDate.parse(yyyymmdd, DateTimeFormatter.BASIC_ISO_DATE);
        String jul = String.format("%03d", d.getDayOfYear());
        String yy = String.format("%02d", d.getYear() % 100);
        String mm = String.format("%02d", d.getMonthValue());
        String dd = String.format("%02d", d.getDayOfMonth());
        return template
                .replace("{FILE}", file)
                .replace("{julianDate}", jul)
                .replace("{yyyymmdd}", yyyymmdd)
                .replace("{yy}", yy)
                .replace("{mm}", mm)
                .replace("{dd}", dd);
    }

    private static byte[] toEbcdic(byte[] ascii) {
        if (ascii == null || ascii.length == 0) return new byte[0];
        String asStr = new String(ascii, Charset.forName("UTF-8"));
        return asStr.getBytes(EBCDIC);
    }
    
    private static String fromEbcdic(byte[] ebcdic) {
        if (ebcdic == null || ebcdic.length == 0) return "";
        return new String(ebcdic, EBCDIC);
    }

    private static int translateByteForDiscrepancy(final int paramInt) {
        return paramInt;
    }

    private static boolean validateDate(String date) {
        try { LocalDate.parse(date, DateTimeFormatter.BASIC_ISO_DATE); return true; }
        catch (Exception e) { return false; }
    }
    
    private static List<String> parseList(String csv) {
        if (csv == null) return Collections.emptyList();
        List<String> out = new ArrayList<>();
        for (String p : csv.split(",")) {
            String t = p.trim();
            if (!t.isEmpty()) out.add(t);
        }
        return out;
    }
    
    private static String req(Map<String,String> m, String key) {
        String v = (m == null) ? null : m.get(key);
        if (v == null || v.trim().isEmpty())
            throw new IllegalArgumentException("Falta clave obligatoria: " + key);
        return v.trim();
    }
    
    private static int parseIntStrict(String s, int min, int max, String k) {
        int v = Integer.parseInt(s.trim());
        if (v < min || v > max) throw new IllegalArgumentException("Parametro fuera de rango: " + k + " ("+v+")");
        return v;
    }
    
    private static byte[] intToBytesBE(int value, int size) {
        if (size <= 0 || size > 8) throw new IllegalArgumentException("size invalido");
        byte[] out = new byte[size];
        for (int i = 0; i < size; i++) {
            int shift = (size - 1 - i) * 8;
            out[i] = (byte)((value >> shift) & 0xFF);
        }
        return out;
    }

    // ====================== REGLAS MIP ======================

    private static String orderDetailsMIP(String data, String allOkCode) {
        String headers = extractHeadersMIP(data);
        String details = extractDetailsMIP(data, allOkCode);
        return headers + details;
    }

    private static String extractHeadersMIP(String data) {
        // ✅ Buscar la primera ocurrencia de "TH"
        int idxTH = data.indexOf("TH");
        
        if (idxTH == -1) {
            // No encontró "TH", fallback al comportamiento anterior
            String name = extractBracketedName(data);
            String header = "[" + name + "]\n";
            int firstIndexDetail = data.indexOf("D");
            int idxH = data.indexOf("H");
            if (idxH == -1) idxH = 0;
            String headerInfo;
            if (firstIndexDetail != -1 && firstIndexDetail > idxH) {
                headerInfo = data.substring(idxH, firstIndexDetail);
            } else {
                headerInfo = data.substring(idxH, data.indexOf("]", idxH));
            }
            return header + headerInfo;
        }
        
        // ✅ Extraer TODO lo que está ANTES de "TH"
        String beforeTH = data.substring(0, idxTH);
        
        // ✅ Limpiar: remover corchetes [] y saltos de línea del nombre
        String cleanName = beforeTH.replace("[", "").replace("]", "").replace("\n", "").trim();
        
        // ✅ Construir header con nombre limpio
        String header = "[" + cleanName + "]\n";
        
        // ✅ Desde la "H" (saltando la "T") hasta el primer "D0"
        int idxH = idxTH + 1; // +1 para saltar la "T" y empezar desde "H"
        int firstIndexDetail = data.indexOf("D0", idxH);
        String headerInfo;
        
        if (firstIndexDetail != -1) {
            // Desde "H..." hasta antes del primer "D0"
            headerInfo = data.substring(idxH, firstIndexDetail);
        } else {
            // Si no hay "D0", toma todo desde "H" hasta el final
            headerInfo = data.substring(idxH);
        }
        
        return header + headerInfo;
    }

    private static String extractDetailsMIP(String data, String allOkCode) {
        int firstIndexDetail = data.indexOf("D");
        StringBuilder detail = new StringBuilder();
        if (firstIndexDetail != -1) {
            String[] detailsData = data.substring(firstIndexDetail)
                                       .replace("[", "")
                                       .replace("]\n", "")
                                       .split("D0");
            for (int i = 1; i < detailsData.length; i++) {
                detail.append("D0");
                String cur = detailsData[i];
                String tail = (cur.length() > 57) ? cur.substring(57) : "";

                if (tail.length() < 26) {
                    String codErrors = String.format("%26s", tail.trim().substring(0, Math.min(15, tail.trim().length())));
                    detail.append(cur.substring(0, Math.min(57, cur.length()))).append(codErrors);
                    if (i == detailsData.length - 1) detail.append(allOkCode);
                    continue;
                }

                if (i == detailsData.length - 1) {
                    int codresp = cur.indexOf(allOkCode);
                    if (codresp != -1) {
                        detail.append(cur.substring(0, Math.min(codresp + allOkCode.length(), cur.length())));
                        break;
                    }
                }

                detail.append(cur.substring(0, Math.min(83, cur.length())));
            }
            return detail.toString().replace("D0", "\nD0");
        }
        return detail.toString();
    }

    private static String extractBracketedName(String data) {
        if (data == null || data.isEmpty()) return "";
        
        // Buscar el primer "TH" o "12" o "16" o "H" para saber dónde termina el nombre
        int idxTH = data.indexOf("TH");
        int idx12 = data.indexOf("12");
        int idx16 = data.indexOf("16");
        int idxH = data.indexOf("H");
        
        // Tomar el índice más cercano al inicio
        int endIdx = -1;
        if (idxTH != -1) endIdx = idxTH;
        if (idx12 != -1 && (endIdx == -1 || idx12 < endIdx)) endIdx = idx12;
        if (idx16 != -1 && (endIdx == -1 || idx16 < endIdx)) endIdx = idx16;
        if (idxH != -1 && (endIdx == -1 || idxH < endIdx)) endIdx = idxH;
        
        if (endIdx == -1) {
            // No encontró ningún marcador, devolver limpio hasta el final
            return data.replace("[", "").replace("]", "").replace("\n", "").trim();
        }
        
        // Extraer desde el inicio hasta el marcador encontrado
        String name = data.substring(0, endIdx);
        return name.replace("[", "").replace("]", "").replace("\n", "").trim();
    }

    // ============================== INTERACTIVO ==============================
    static class Interactive {
        static void run() throws Exception {
            IniFile ini = IniFile.load(Paths.get("mcsender.ini"));
            General general = General.from(ini);
            Scanner sc = new Scanner(System.in);

            System.out.println("1) Envio");
            System.out.println("2) Descarga y genera reporte");
            System.out.println("3) Descarga");
            System.out.println("4) Envio manual");
            System.out.print("Opcion: ");
            int op = Integer.parseInt(sc.nextLine().trim());

            if (op == 4) {
                System.out.print("IP: ");
                String ip = sc.nextLine().trim();
                System.out.print("Puerto: ");
                int port = Integer.parseInt(sc.nextLine().trim());
                System.out.print("Nombre completo a enviar: ");
                String full = sc.nextLine().trim();
                Sender.runManualSend(general, ip, port, full);
                return;
            }

            System.out.print("Seccion INI: ");
            String sec = sc.nextLine().trim();
            System.out.print("FILE param : ");
            String fileParam = sc.nextLine().trim();
            System.out.print("Fecha (YYYYMMDD): ");
            String date = sc.nextLine().trim();

            IniFile ini2 = IniFile.load(Paths.get("mcsender.ini"));
            Business biz = Business.from(ini2, sec);

            if (!validateDate(date)) {
                System.err.println("Fecha invalida");
                return;
            }

            String preview = (op == 1)
                    ? applyFormat(biz.formatSendMC, fileParam, date)
                    : applyFormat(biz.formatRecieveMC, fileParam, date);
            System.out.println("Nombre exacto: " + preview);

            boolean isMIP = isMIPSection(sec);

            if (op == 1) Sender.runSend(general, biz, fileParam, date);
            else if (op == 2) Sender.runReport(general, biz, fileParam, date, isMIP);
            else if (op == 3) Sender.runDownload(general, biz, fileParam, date);
            else System.err.println("Opcion invalida");
        }
    }
}
