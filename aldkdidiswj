//=================================================================================================
// McBatchSender
//
// Proposito:
//   Cliente TCP simple para envio y descarga de archivos contra el hub (ej. Mastercard).
//   - Opcion 1: Envio (particiona en tramas y envia trailer).
//   - Opcion 2: Descarga y genera reporte (procesa headers+details).
//   - Opcion 3: Descarga cruda (solo guarda lo recibido, sin parseo).
//   - Opcion 4: Envio manual (host/puerto/archivo por consola).
//
// Protocolo de marco:
//   Cada trama: header de 2 bytes (longitud big-endian) + cuerpo en EBCDIC.
//   - Nombre: texto plano en EBCDIC.
//   - Trama de datos: prefijo ASCII 'R' + bytes del archivo (todo convertido a EBCDIC).
//   - Trailer 11B: 7 chars de acceptedCode + contador(4B) big-endian (los 4B pasan por
//     translateByteForDiscrepancy para calzar con el legado).
//
// Notas de comportamiento:
//   - La verificacion de exito ahora es estricta: solo se considera OK si la respuesta del
//     servidor contiene al menos uno de los codigos en acceptedCode. Caso contrario, se registra
//     preview de 80B y se crea un archivo ERROR_<FILE> con el cuerpo crudo.
//   - La conversion EBCDIC es manual, basada en tablas del programa original.
//
// Uso tipico:
//   javac McBatchSender.java
//   java McBatchSender <OPCION> <SECCION> <FILE> <YYYYMMDD>
//   Si no pasas parametros, entra a modo interactivo (menu).
//
// Codigos de salida:
//   0 OK | 2 uso invalido | 3 INI no encontrado | 4 config invalida | 1 error inesperado
//=================================================================================================
//=================================================================================================
// McBatchSender
//
// Proposito (resumen):
//   Flujo por TCP con 2B de encabezado big-endian y cuerpo en EBCDIC (mapeo manual).
//   Opcion 1: Envio en tramas (prefijo 'R' ASCII por trama) + trailer 11B.
//   Opcion 2: Descarga y genera reporte (parsea headers y detalles como el legado).
//   Opcion 3: Descarga cruda (sin parseo), solo escribe si el servidor responde con acceptedCode.
//   Opcion 4: Envio manual (host y puerto directos) usando parametros de [GENERAL].
//
// Notas clave de esta version:
//   - Verifica exito por presencia de cualquier acceptedCode de [GENERAL].
//   - Si NO hay acceptedCode: se muestra preview 80B y se genera ERROR_{FILE} con lo devuelto.
//   - Menu interactivo renombrado: "Envio manual" (opcion 4).
//   - Envio manual: CLI = <OPC> <HOST> <PUERTO> <FULL_NAME>, usa timeouts de [GENERAL].
//   - INI: [GENERAL], [HOST_xxx] y secciones de negocio con formatos.
//
// Uso basico (CLI, formatos obligatorios):
//   javac McBatchSender.java
//   java McBatchSender <OPC> <SECCION> <FILE> <YYYYMMDD>
//   Opcion 4 (envio manual): java McBatchSender 4 <IP> <PUERTO> <FULL_NAME>
//
//=================================================================================================

import java.io.*;
import java.net.*;
import java.nio.file.*;
import java.time.*;
import java.time.format.DateTimeFormatter;
import java.util.*;
import java.util.logging.Logger;

public class McBatchSender {
    private static final Logger logger = Logger.getLogger(McBatchSender.class.getName());

    // ============================== MAIN ==============================

    public static void main(String[] args) {
        System.out.println("INICIA PROCESO");

        try {
            if (args.length == 0) {
                // Modo interactivo
                Interactive.run();
                return;
            }

            // Modo CLI
            int option = Integer.parseInt(args[0].trim());

            if (option == 4) {
                // Envio manual: 4 <IP> <PUERTO> <FULL_NAME>
                if (args.length < 4) {
                    System.err.println("Uso: java McBatchSender 4 <IP> <PUERTO> <FULL_NAME>");
                    System.exit(2);
                }
                String ip = args[1].trim();
                int port = Integer.parseInt(args[2].trim());
                String fullName = args[3].trim();

                IniFile ini = IniFile.load(Paths.get("mcsender.ini")); // nombre fijo
                General general = General.from(ini);
                Sender.runManualSend(general, ip, port, fullName);
                return;
            }

            if (args.length < 4) {
                System.err.println("Uso: java McBatchSender <OPC> <SECCION> <FILE> <YYYYMMDD>");
                System.exit(2);
            }

            String section = args[1].trim();
            String fileParam = args[2].trim();
            String yyyymmdd = args[3].trim();

            if (!validateDate(yyyymmdd)) {
                System.err.println("Fecha invalida: " + yyyymmdd);
                System.exit(4);
            }

            IniFile ini = IniFile.load(Paths.get("mcsender.ini"));
            General general = General.from(ini);
            Business biz = Business.from(ini, section);

            if (option == 1) {
                Sender.runSend(general, biz, fileParam, yyyymmdd);
            } else if (option == 2) {
                Sender.runReport(general, biz, fileParam, yyyymmdd);
            } else if (option == 3) {
                Sender.runDownload(general, biz, fileParam, yyyymmdd);
            } else {
                System.err.println("Opcion invalida.");
                System.exit(4);
            }
        } catch (NoSuchFileException e) {
            System.err.println("INI no encontrado: " + e.getFile());
            System.exit(3);
        } catch (Exception e) {
            System.err.println("Error: " + e.getMessage());
            System.exit(1);
        } finally {
            System.out.println("PROCESO FINALIZADO");
        }
    }

    // ============================== CONFIG ==============================

    static class General {
        final int connectTimeoutMs;
        final int soTimeoutMs;
        final int chunkSize;
        final List<String> acceptedCode;
        final String alreadySentSubstring;
        final String defaultFailCode;

        General(int cto, int sto, int chunk, List<String> acc, String already, String fail) {
            this.connectTimeoutMs = cto;
            this.soTimeoutMs = sto;
            this.chunkSize = chunk;
            this.acceptedCode = acc;
            this.alreadySentSubstring = already;
            this.defaultFailCode = fail;
        }

        static General from(IniFile ini) {
            Map<String,String> g = ini.section("GENERAL");
            if (g == null) throw new IllegalArgumentException("Falta seccion [GENERAL]");

            int cto = parseInt(g.getOrDefault("connectTimeoutMs","60000"), 1000, 300000, "connectTimeoutMs");
            int sto = parseInt(g.getOrDefault("soTimeoutMs","60000"), 1000, 300000, "soTimeoutMs");
            int chunk = parseInt(g.getOrDefault("chunkSize","980"), 1, 65535, "chunkSize");
            List<String> acc = parseList(g.getOrDefault("acceptedCode","9980100"));
            String already = g.getOrDefault("alreadySentSubstring","9288W");
            String fail = g.getOrDefault("defaultFailCode","9980101");
            return new General(cto, sto, chunk, acc, already, fail);
        }
    }

    static class Business {
        final String host; // resuelto desde [HOST_xxx]
        final int port;
        final String originalFile;
        final String historyFile;
        final String formatSendMC;
        final String formatRecieveMC;

        Business(String host, int port, String of, String hf, String fs, String fr) {
            this.host = host;
            this.port = port;
            this.originalFile = of;
            this.historyFile = hf;
            this.formatSendMC = fs;
            this.formatRecieveMC = fr;
        }

        static Business from(IniFile ini, String section) {
            Map<String,String> s = ini.section(section);
            if (s == null) throw new IllegalArgumentException("No existe la seccion ["+section+"]");

            // Host mapping
            String hostSec = s.getOrDefault("hostSection", "HOST_MC");
            Map<String,String> hs = ini.section(hostSec);
            if (hs == null) throw new IllegalArgumentException("No existe la seccion ["+hostSec+"]");
            String host = req(hs, "host");
            int port = parseInt(req(hs, "port"), 1, 65535, "port");

            String of = req(s, "originalFile");
            String hf = req(s, "historyFile");
            String fs = req(s, "formatSendMC");
            String fr = req(s, "formatRecieveMC");

            return new Business(host, port, of, hf, fs, fr);
        }
    }

    // ============================== INI SIMPLE ==============================

    static class IniFile {
        private final Map<String, Map<String,String>> data = new LinkedHashMap<>();
        private IniFile() {}

        static IniFile load(Path path) throws IOException {
            if (!Files.exists(path)) throw new NoSuchFileException(path.toString());
            IniFile f = new IniFile();
            Map<String,String> cur = null;
            try (BufferedReader br = Files.newBufferedReader(path)) {
                String line;
                while ((line = br.readLine()) != null) {
                    String ln = line.trim();
                    if (ln.isEmpty() || ln.startsWith("#") || ln.startsWith(";")) continue;
                    if (ln.startsWith("[") && ln.endsWith("]")) {
                        String sec = ln.substring(1, ln.length()-1).trim();
                        cur = f.data.computeIfAbsent(sec, k -> new LinkedHashMap<>());
                    } else {
                        int eq = ln.indexOf('=');
                        if (eq < 0 || cur == null) continue;
                        String k = ln.substring(0, eq).trim();
                        String v = ln.substring(eq+1).trim();
                        cur.put(k, v);
                    }
                }
            }
            return f;
        }

        Map<String,String> section(String name) { return data.get(name); }
    }

    // ============================== SENDER ==============================

    static class Sender {

        // ------------------- Opcion 1: Envio -------------------
        static void runSend(General g, Business b, String fileParam, String yyyymmdd) {
            logger.info("=== OPCION 1: Envio ===");
            logger.info("Host: " + b.host + " Puerto: " + b.port);

            // Validar entorno
            File cwd = new File(System.getProperty("user.dir"));
            if (!cwd.canRead() || !cwd.canExecute()) {
                throw new IllegalStateException("CWD sin permisos de lectura/ejecucion");
            }
            Path dataFile = Paths.get(b.originalFile);
            Path history = Paths.get(b.historyFile);

            byte[] payload = readAllBytesOrEmpty(dataFile);
            if (payload.length == 0) {
                logger.warning("Archivo de datos vacio: " + dataFile);
                createHistoryRecord(g.defaultFailCode, fileParam, yyyymmdd, history);
                logger.info("=== FIN OPCION 1 ===");
                return;
            }

            List<byte[]> parts = splitWithPrefixR(payload, g.chunkSize);
            String nameToSend = applyFormat(b.formatSendMC, fileParam, yyyymmdd);
            logger.info("Nombre a enviar: " + nameToSend);

            String finalStatus = g.defaultFailCode;

            try (Socket sock = new Socket()) {
                sock.connect(new InetSocketAddress(b.host, b.port), g.connectTimeoutMs);
                sock.setSoTimeout(g.soTimeoutMs);

                // handshake: enviar nombre
                writeFrameName(sock, nameToSend);

                // respuesta
                String resp = readResponse(sock).trim();
                logger.info("Resp nombre: [" + resp + "]");

                if (!g.alreadySentSubstring.isEmpty() && resp.contains(g.alreadySentSubstring)) {
                    finalStatus = firstAcceptedOrDefault(g);
                } else if (hasAccepted(resp, g.acceptedCode)) {
                    // enviar tramas
                    for (byte[] chunk : parts) writeFrameData(sock, chunk);
                    // trailer
                    writeTrailer(sock, parts.size() + 1);
                    // confirmacion
                    String resp2 = readResponse(sock).trim();
                    logger.info("Confirmacion: ["+resp2+"]");
                    if (hasAccepted(resp2, g.acceptedCode)) {
                        finalStatus = firstAcceptedOrDefault(g);
                        logger.info("Envio OK");
                    } else {
                        logger.warning("Confirmacion no aceptada");
                    }
                } else {
                    logger.warning("Nombre rechazado");
                }
            } catch (Exception ex) {
                logger.severe("Error envio: " + ex.getMessage());
            } finally {
                createHistoryRecord(finalStatus, fileParam, yyyymmdd, history);
                logger.info("=== FIN OPCION 1 ===");
            }
        }

        // ------------------- Opcion 2: Reporte (procesa) -------------------
        static void runReport(General g, Business b, String fileParam, String yyyymmdd) {
            logger.info("=== OPCION 2: Descarga y genera reporte ===");
            logger.info("Host: " + b.host + " Puerto: " + b.port);

            String base = applyFormat(b.formatRecieveMC, fileParam, yyyymmdd);
            logger.info("Nombre base: " + base);

            boolean found = false;
            StringBuilder rawAcc = new StringBuilder();

            try (Socket sock = new Socket()) {
                sock.connect(new InetSocketAddress(b.host, b.port), g.connectTimeoutMs);
                sock.setSoTimeout(g.soTimeoutMs);

                for (int i = 1; i <= 99; i++) {
                    String sec = String.format("%02d", i);
                    String query = base + sec;

                    logger.info("Consultando: " + query);
                    writeFrameName(sock, query);

                    // lectura one-shot legacy y filtro
                    String chunk = readLegacyOneShot(sock);
                    rawAcc.setLength(0);
                    rawAcc.append("[").append(chunk).append("]\n");

                    if (hasAccepted(rawAcc.toString(), g.acceptedCode)) {
                        found = true;
                        break;
                    } else {
                        logger.info("Buscando...");
                    }
                }

                if (!found) {
                    logger.severe("*** Archivo no encontrado [FAIL]");
                    // preview y dump de error
                    String rr = rawAcc.toString();
                    logger.info("[Preview 80B] " + preview80(rr));
                    writeErrorDump(fileParam, yyyymmdd, rr);
                    logger.info("=== FIN OPCION 2 ===");
                    return;
                }

                // Exito: procesar como legado
                String dataToWrite;
                try {
                    dataToWrite = orderDetails(rawAcc.toString(), firstAcceptedOrDefault(g));
                } catch (Exception ex) {
                    // fallback crudo
                    logger.severe("Error al ordenar; se guarda crudo");
                    dataToWrite = rawAcc.toString();
                }

                // escribir reporte con nombre original
                writeReportFile(yyyymmdd, dataToWrite, fileParam);
                logger.info("Reporte OK");

            } catch (Exception ex) {
                logger.severe("Error reporte: " + ex.getMessage());
            } finally {
                logger.info("=== FIN OPCION 2 ===");
            }
        }

        // ------------------- Opcion 3: Descarga cruda -------------------
        static void runDownload(General g, Business b, String fileParam, String yyyymmdd) {
            logger.info("=== OPCION 3: Descarga ===");
            logger.info("Host: " + b.host + " Puerto: " + b.port);

            String query = applyFormat(b.formatRecieveMC, fileParam, yyyymmdd);
            logger.info("Nombre a solicitar: " + query);

            try (Socket sock = new Socket()) {
                sock.connect(new InetSocketAddress(b.host, b.port), g.connectTimeoutMs);
                sock.setSoTimeout(g.soTimeoutMs);

                writeFrameName(sock, query);

                // leer bloque
                String raw = readLegacyOneShot(sock);

                // verificacion estricta
                if (!hasAccepted(raw, g.acceptedCode)) {
                    logger.severe("*** Descarga FALLIDA (sin acceptedCode)");
                    logger.info("[Preview 80B] " + preview80(raw));
                    writeErrorDump(fileParam, yyyymmdd, raw);
                    logger.info("=== FIN OPCION 3 ===");
                    return;
                }

                // escribir tal cual
                writeRawDownloadFile(yyyymmdd, raw, fileParam);
                logger.info("Descarga OK");
                logger.info("[Preview 80B] " + preview80(raw));

            } catch (Exception ex) {
                logger.severe("Error descarga: " + ex.getMessage());
            } finally {
                logger.info("=== FIN OPCION 3 ===");
            }
        }

        // ------------------- Opcion 4: Envio manual -------------------
        static void runManualSend(General g, String ip, int port, String fullName) {
            logger.info("=== OPCION 4: Envio manual ===");
            logger.info("Host: " + ip + " Puerto: " + port);
            logger.info("Nombre a enviar: " + fullName);
        
            try (Socket sock = new Socket()) {
                sock.connect(new InetSocketAddress(ip, port), g.connectTimeoutMs);
                sock.setSoTimeout(g.soTimeoutMs);
        
                // Enviar nombre (2B header + cuerpo EBCDIC)
                writeFrameName(sock, fullName);
        
                // Leer una respuesta estilo legacy (one-shot, filtrando imprimibles)
                String raw = readLegacyOneShot(sock);
        
                // Preview 80B en consola
                String preview = (raw == null) ? "" : raw.replace("\r", " ").replace("\n", " ");
                if (preview.length() > 80) preview = preview.substring(0, 80);
                logger.info("[Preview 80B] " + preview);
        
                // Escribir exactamente en el archivo indicado por 'fullName'
                try (PrintStream ps = new PrintStream(new FileOutputStream(fullName), true, "UTF-8")) {
                    ps.print(raw == null ? "" : raw);
                }
        
                // Log compacto de la respuesta
                logger.info("Resp: [" + (raw == null ? "" : raw.trim()) + "]");
            } catch (Exception ex) {
                logger.severe("Error envio manual: " + ex.getMessage());
            } finally {
                logger.info("=== FIN OPCION 4 ===");
            }
        }


        // ==================== I/O de red y framing (EBCDIC manual) ====================

        private static void writeFrameName(Socket s, String name) throws IOException {
            // nombre en EBCDIC (mapeo manual) con header 2B
            byte[] body = toEbcdic(name.getBytes());
            writeRawFrame(s, body);
        }

        private static void writeFrameData(Socket s, byte[] asciiChunkWithR) throws IOException {
            // asciiChunkWithR ya contiene 'R' al inicio; convertir a EBCDIC y enviar
            byte[] body = toEbcdic(asciiChunkWithR);
            writeRawFrame(s, body);
        }

        private static void writeTrailer(Socket s, int count) throws IOException {
            // 11B = "9980100"(7) + contador BE(4), pero los 4 ultimos se traducen segun discrepancia
            String ok = "9980100";
            byte[] pre = toEbcdic(ok.getBytes());
            byte[] cnt = intToBytesBE(count, 4);
            // aplicar translateByteForDiscrepancy a los 4 de contador
            for (int i = 0; i < 4; i++) cnt[i] = (byte) translateByteForDiscrepancy(cnt[i]);

            byte[] body = new byte[11];
            System.arraycopy(pre, 0, body, 0, 7);
            System.arraycopy(cnt, 0, body, 7, 4);
            writeRawFrame(s, body);
        }

        private static void writeRawFrame(Socket s, byte[] body) throws IOException {
            int len = body.length;
            byte[] header = intToBytesBE(len, 2);
            OutputStream os = s.getOutputStream();
            os.write(header);
            os.write(body);
            os.flush();
        }

        private static String readResponse(Socket s) throws IOException {
            ByteArrayOutputStream baos = new ByteArrayOutputStream();
            InputStream is = s.getInputStream();
            byte[] buf = new byte[1024];
            int n;
            while (true) {
                try {
                    n = is.read(buf);
                    if (n == -1) break;
                    baos.write(buf, 0, n);
                    if (n < buf.length) break;
                } catch (SocketTimeoutException te) {
                    if (baos.size() == 0) throw te;
                    break;
                }
            }
            byte[] ebcdicBytes = baos.toByteArray();
            return fromEbcdic(ebcdicBytes);
        }

        private static String readLegacyOneShot(Socket s) throws IOException {
            InputStream is = s.getInputStream();
            byte[] buf = new byte[1024];
            int n = is.read(buf, 0, 1024);
            if (n <= 0) return "";
            String decoded = fromEbcdic(Arrays.copyOf(buf, n));
            StringBuilder out = new StringBuilder(decoded.length());
            for (int i = 0; i < decoded.length(); i++) {
                char c = decoded.charAt(i);
                if (c >= ' ' && c <= '~') out.append(c);
                else if (c == '\n') out.append('\n');
            }
            return out.toString();
        }

        // ==================== Archivos locales ====================

        private static byte[] readAllBytesOrEmpty(Path p) {
            try { return Files.readAllBytes(p); }
            catch (Exception e) { return new byte[0]; }
        }

        private static void writeReportFile(String yyyymmdd, String data, String fileName9) throws IOException {
            String newName = reportFileName(yyyymmdd, fileName9);
            try (PrintStream ps = new PrintStream(new FileOutputStream(newName), true, "UTF-8")) {
                ps.print(data);
            }
            logger.info("Reporte: " + newName);
        }

        private static void writeRawDownloadFile(String yyyymmdd, String data, String fileParam) throws IOException {
            String out = (fileParam == null || fileParam.isEmpty()) ? "DESCARGA" : fileParam;
            String name = out + "-" + yyyymmdd + ".out";
            try (PrintStream ps = new PrintStream(new FileOutputStream(name), true, "UTF-8")) {
                ps.print(data);
            }
            logger.info("Archivo escrito: " + name);
        }

        private static void createHistoryRecord(String respCode, String fileName, String yyyymmdd, Path historyPath) {
            try {
                String record = "[" + respCode + "-" + fileName + "-" + yyyymmdd + ": " +
                        LocalDateTime.now().format(DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss")) + "]";
                prependLine(historyPath, record);
            } catch (Exception e) {
                logger.severe("No se pudo actualizar el historico: " + e.getMessage());
            }
        }

        private static void prependLine(Path path, String line) throws IOException {
            List<String> lines = new ArrayList<>();
            if (Files.exists(path)) {
                try { lines = Files.readAllLines(path); } catch (Exception ignore) {}
            }
            lines.add(0, line);
            Files.write(path, String.join(System.lineSeparator(), lines).getBytes(),
                    StandardOpenOption.CREATE, StandardOpenOption.TRUNCATE_EXISTING, StandardOpenOption.WRITE);
        }

        private static String reportFileName(String yyyymmdd, String fileName9) {
            String prefix = (fileName9 == null || fileName9.length() < 4) ? "FILE" : fileName9.substring(0, 4);
            return prefix + "-" + yyyymmdd + "-Archivo de Cambio Confirmacion";
        }

        // ==================== Utilidades varias ====================

        private static List<byte[]> splitWithPrefixR(byte[] data, int chunkSize) {
            List<byte[]> parts = new ArrayList<>();
            int total = data.length;
            for (int off = 0; off < total; off += chunkSize) {
                int len = Math.min(chunkSize, total - off);
                byte[] arr = new byte[len + 1];
                arr[0] = (byte) 'R';
                System.arraycopy(data, off, arr, 1, len);
                parts.add(arr);
            }
            return parts;
        }

        private static byte[] intToBytesBE(int num, int byts) {
            byte[] r = new byte[byts];
            for (int i = byts - 1; i >= 0; --i) {
                r[i] = (byte) (num & 0xFF);
                num >>>= 8;
            }
            return r;
        }
    }

    // ============================== INTERACTIVO ==============================

    static class Interactive {
        static void run() throws Exception {
            IniFile ini = IniFile.load(Paths.get("mcsender.ini"));
            General general = General.from(ini);

            Scanner sc = new Scanner(System.in);

            System.out.println("1) Envio");
            System.out.println("2) Descarga y genera reporte");
            System.out.println("3) Descarga");
            System.out.println("4) Envio manual");
            System.out.print("Opcion: ");
            int op = Integer.parseInt(sc.nextLine().trim());

            if (op == 4) {
                System.out.print("IP: ");
                String ip = sc.nextLine().trim();
                System.out.print("Puerto: ");
                int port = Integer.parseInt(sc.nextLine().trim());
                System.out.print("Nombre completo a enviar: ");
                String fullname = sc.nextLine().trim();
                Sender.runManualSend(general, ip, port, fullname);
                return;
            }

            System.out.print("Seccion: ");
            String section = sc.nextLine().trim();

            // Validar que exista seccion y mostrar datos
            Business biz;
            try {
                biz = Business.from(ini, section);
            } catch (Exception e) {
                System.err.println("Seccion no valida: " + e.getMessage());
                return;
            }
            System.out.println("Host destino: " + biz.host + " Puerto: " + biz.port);
            System.out.println("Archivo origen: " + biz.originalFile + " | History: " + biz.historyFile);
            System.out.println("Fmt send: " + biz.formatSendMC + " | Fmt recv: " + biz.formatRecieveMC);

            System.out.print("FILE: ");
            String fileParam = sc.nextLine().trim();
            System.out.print("Fecha YYYYMMDD: ");
            String date = sc.nextLine().trim();
            if (!validateDate(date)) {
                System.err.println("Fecha invalida");
                return;
            }

            // Mostrar nombre exacto a consultar/enviar
            String preview = (op == 1)
                    ? applyFormat(biz.formatSendMC, fileParam, date)
                    : applyFormat(biz.formatRecieveMC, fileParam, date);
            System.out.println("Nombre exacto: " + preview);

            if (op == 1) Sender.runSend(general, biz, fileParam, date);
            else if (op == 2) Sender.runReport(general, biz, fileParam, date);
            else if (op == 3) Sender.runDownload(general, biz, fileParam, date);
            else System.err.println("Opcion invalida");
        }
    }

    // ============================== HELPERS GLOBALES ==============================

    // acceptedCode check
    private static boolean hasAccepted(String text, List<String> acceptedCodes) {
        if (text == null || acceptedCodes == null || acceptedCodes.isEmpty()) return false;
        for (String c : acceptedCodes) {
            if (c != null && !c.isEmpty() && text.contains(c)) return true;
        }
        return false;
    }

    // preview 80B
    private static String preview80(String s) {
        if (s == null) return "";
        String p = s.replace("\r", " ").replace("\n", " ");
        return p.length() > 80 ? p.substring(0, 80) : p;
    }

    // dump de error
    private static void writeErrorDump(String fileParam, String yyyymmdd, String content) {
        String safe = (fileParam == null || fileParam.isEmpty()) ? "NONAME" : fileParam;
        String outName = "ERROR_" + safe;
        try (PrintStream ps = new PrintStream(new FileOutputStream(outName), true, "UTF-8")) {
            ps.print(content == null ? "" : content);
        } catch (Exception e) {
            logger.severe("No se pudo escribir " + outName + ": " + e.getMessage());
        }
    }

    // aplica formato {FILE}, {julianDate}, {yyyymmdd}, {yy},{mm},{dd}
    private static String applyFormat(String template, String file, String yyyymmdd) {
        if (template == null) template = "";
        if (file == null) file = "";
        LocalDate d = LocalDate.parse(yyyymmdd, DateTimeFormatter.BASIC_ISO_DATE);
        String jul = String.format("%03d", d.getDayOfYear());
        String yy = String.format("%02d", d.getYear() % 100);
        String mm = String.format("%02d", d.getMonthValue());
        String dd = String.format("%02d", d.getDayOfMonth());
        return template
                .replace("{FILE}", file)
                .replace("{julianDate}", jul)
                .replace("{yyyymmdd}", yyyymmdd)
                .replace("{yy}", yy)
                .replace("{mm}", mm)
                .replace("{dd}", dd);
    }

    // EBCDIC manual (mapeo de tu GCO_MIP original)
    private static byte[] toEbcdic(byte[] ascii) {
        byte[] out = new byte[ascii.length];
        for (int i = 0; i < ascii.length; i++) {
            out[i] = (byte) translateByte("toEBC", ascii[i]);
        }
        return out;
    }
    private static String fromEbcdic(byte[] ebcdic) {
        StringBuilder sb = new StringBuilder(ebcdic.length);
        for (byte b : ebcdic) {
            int asc = translateByte("toASC", b & 0xFF);
            sb.append((char) asc);
        }
        return sb.toString();
    }
    private static int translateByte(final String translationType, final int paramInt) {
        final int[] asciiArray  = { 32, 33,  34,  35, 36,  37, 38,  39, 40, 41, 42, 43,  44, 45, 46, 47,  48,  49,  50,  51,  52,  53,  54,  55,  56,  57,  58, 59, 60,  61,  62,  63,  64,  65,  66,  67,  68,  69,  70,  71,  72,  73,  74,  75,  76,  77,  78,  79,  80,  81,  82,  83,  84,  85,  86,  87,  88,  89,  90,  91,  92,  93, 94,  95,  96,  97,  98,  99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126 };
        final int[] ebcdicArray = { 64, 90, 127, 123, 91, 108, 80, 125, 77, 93, 92, 78, 107, 96, 75, 97, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 122, 94, 76, 126, 110, 111, 124, 193, 194, 195, 196, 197, 198, 199, 200, 201, 209, 210, 211, 212, 213, 214, 215, 216, 217, 226, 227, 228, 229, 230, 231, 232, 233, 173, 224, 189, 95, 109, 121, 129, 130, 131, 132, 133, 134, 135, 136, 137, 145, 146, 147, 148, 149, 150, 151, 152, 153, 162, 163, 164, 165, 166, 167, 168, 169, 192, 106, 208, 161 };
        for (int i = 0; i < asciiArray.length; i++) {
            if (translationType.equals("toEBC")) { if (paramInt == asciiArray[i]) return ebcdicArray[i]; }
            else { if (paramInt == ebcdicArray[i]) return asciiArray[i]; }
        }
        return paramInt;
    }
    private static int translateByteForDiscrepancy(final int paramInt) {
        int[] discrepancyArray = new int[126];
        for (int i = 0; i < discrepancyArray.length; i++) discrepancyArray[i] = i + 1;
        for (int j : discrepancyArray) if (paramInt == j) return j;
        return paramInt;
    }

    // parse helpers
    private static boolean validateDate(String date) {
        try { LocalDate.parse(date, DateTimeFormatter.BASIC_ISO_DATE); return true; }
        catch (Exception e) { return false; }
    }
    private static List<String> parseList(String csv) {
        if (csv == null) return Collections.emptyList();
        List<String> out = new ArrayList<>();
        for (String p : csv.split(",")) {
            String t = p.trim();
            if (!t.isEmpty()) out.add(t);
        }
        return out;
    }
    private static int parseInt(String s, int min, int max, String name) {
        try {
            int v = Integer.parseInt(s.trim());
            if (v < min || v > max) throw new IllegalArgumentException(name+" fuera de rango");
            return v;
        } catch (NumberFormatException e) { throw new IllegalArgumentException(name+" no numerico: "+s); }
    }
    private static String req(Map<String,String> m, String k) {
        String v = (m == null ? null : m.get(k));
        if (v == null || v.trim().isEmpty()) throw new IllegalArgumentException("Falta "+k);
        return v.trim();
    }
    private static String firstAcceptedOrDefault(General g) {
        return (g.acceptedCode == null || g.acceptedCode.isEmpty()) ? g.defaultFailCode : g.acceptedCode.get(0);
    }

    // ---- Parser legado para opcion 2 ----

    private static String orderDetails(String dataMipDato, String allOkCode) {
        String headers = extractHeaders(dataMipDato);
        String details = extractDetails(dataMipDato, allOkCode);
        return headers + details;
    }
    private static String extractHeaders(String data) {
        String header = data.replace(">", "").substring(0, 20) + "]\n";
        int firstIndexDetail = data.indexOf("16");
        String headerInfo;
        if (firstIndexDetail != -1) {
            headerInfo = data.substring(data.indexOf("12"), firstIndexDetail);
        } else {
            headerInfo = data.substring(data.indexOf("12"), data.indexOf("]", data.indexOf("12")));
        }
        return header + headerInfo;
    }
    private static String extractDetails(String data, String allOkCode) {
        int firstIndexDetail = data.indexOf("16");
        StringBuilder detail = new StringBuilder();
        if (firstIndexDetail != -1) {
            String[] detailsData = data.substring(firstIndexDetail).replace("[", "").replace("]\n", "").split("D0");
            for (int i = 1; i < detailsData.length; i++) {
                detail.append("16");
                if (detailsData[i].substring(57).length() < 26) {
                    String codErrors = String.format("%26s", detailsData[i].substring(57).trim().substring(0, 15));
                    detail.append(detailsData[i].substring(0, 57)).append(codErrors);
                    continue;
                }
                if (i == detailsData.length - 1) {
                    if (detailsData[i].substring(57).length() < 26) {
                        String codErrors = String.format("%26s", detailsData[i].substring(57).trim().substring(0, 15));
                        detail.append(detailsData[i].substring(0, 57)).append(codErrors).append(allOkCode);
                    } else {
                        int codresp = detailsData[i].indexOf(allOkCode);
                        if (codresp != -1) {
                            detail.append(detailsData[i].substring(0, codresp + allOkCode.length()));
                        }
                    }
                    break;
                }
                detail.append(detailsData[i].substring(0, 83));
            }
            return detail.toString().replace("D0", "\nD0");
        }
        return detail.toString();
    }
}
