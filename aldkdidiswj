import java.io.*;
import java.net.*;
import java.nio.file.*;
import java.time.*;
import java.time.format.DateTimeFormatter;
import java.util.*;
import java.util.logging.*;

public class McBatchSender {
    static final Logger logger = Logger.getLogger("McBatchSender");
    static {
        try {
            logger.setUseParentHandlers(false);
            ConsoleHandler ch = new ConsoleHandler();
            ch.setLevel(Level.INFO);
            logger.addHandler(ch);
            logger.setLevel(Level.INFO);
        } catch (Exception ignored) {}
    }

    static class General {
        int connectTimeoutMs;
        int soTimeoutMs;
        int chunkSize;
        List<String> acceptedCode = new ArrayList<>();
        String alreadySentSubstring = "";
        String defaultFailCode = "9980900";
        static General fromIni(IniFile ini) {
            General g = new General();
            g.connectTimeoutMs = ini.getInt("GENERAL","connectTimeoutMs",60000);
            g.soTimeoutMs = ini.getInt("GENERAL","soTimeoutMs",60000);
            g.chunkSize = ini.getInt("GENERAL","chunkSize",980);
            String acc = ini.get("GENERAL","acceptedCode","");
            if (acc == null) acc = "";
            if (acc.contains(",")) {
                String[] arr = acc.split(",");
                for (String s : arr) {
                    String t = s.trim();
                    if (!t.isEmpty()) g.acceptedCode.add(t);
                }
            } else {
                String t = acc.trim();
                if (!t.isEmpty()) g.acceptedCode.add(t);
            }
            g.alreadySentSubstring = ini.get("GENERAL","alreadySentSubstring","");
            g.defaultFailCode = ini.get("GENERAL","defaultFailCode","9980101");
            if (g.acceptedCode.isEmpty()) g.acceptedCode = Arrays.asList("9980100");
            return g;
        }
    }

    static class Business {
        String section;
        String host;
        int port;
        String originalFile;
        String historyFile;
        String formatSendMC;
        String formatRecieveMC;
        static Business fromIni(IniFile ini, String section) {
            Map<String,String> m = ini.sections.get(section);
            if (m == null) throw new IllegalArgumentException("Seccion no encontrada: " + section);
            Business b = new Business();
            b.section = section;
            String hostRef = m.get("hostRef") == null ? "" : m.get("hostRef").trim();
            if (hostRef.isEmpty()) {
                b.host = ini.get(section,"host","");
                b.port = Integer.parseInt(ini.get(section,"port","0"));
            } else {
                Map<String,String> hm = ini.sections.get(hostRef);
                if (hm == null) throw new IllegalArgumentException("hostRef no encontrado: " + hostRef);
                b.host = hm.get("host") == null ? "" : hm.get("host").trim();
                String pv = hm.get("port") == null ? "0" : hm.get("port").trim();
                b.port = Integer.parseInt(pv);
            }
            b.originalFile = m.get("originalFile") == null ? "" : m.get("originalFile").trim();
            b.historyFile = m.get("historyFile") == null ? "" : m.get("historyFile").trim();
            b.formatSendMC = m.get("formatSendMC") == null ? "" : m.get("formatSendMC").trim();
            b.formatRecieveMC = m.get("formatRecieveMC") == null ? "" : m.get("formatRecieveMC").trim();
            if (b.host.isEmpty() || b.port <= 0) throw new IllegalArgumentException("Host/Port invalidos en seccion: " + section);
            return b;
        }
    }

    static void runSend(General g, Business b, String fileParam, String yyyymmdd) {
        logger.info("=== OPCION 1: Envio ===");
        logger.info("Host: " + b.host + " Puerto: " + b.port);
        String nameToSend = applyFormat(b.formatSendMC, fileParam, yyyymmdd);
        logger.info("Nombre a enviar: " + nameToSend);
        String finalStatus = g.defaultFailCode;
        try (Socket sock = new Socket()) {
            sock.connect(new InetSocketAddress(b.host, b.port), g.connectTimeoutMs);
            sock.setSoTimeout(g.soTimeoutMs);
            writeFrameName(sock, nameToSend);
            String resp = readResponseAscii(sock).trim();
            logger.info("Resp nombre: [" + preview80(resp) + "]");
            Path p = Paths.get(fileParam);
            byte[] data = Files.readAllBytes(p);
            List<byte[]> parts = splitWithPrefixR(data, g.chunkSize - 1);
            if (!g.alreadySentSubstring.isEmpty() && resp.contains(g.alreadySentSubstring)) {
                finalStatus = firstAcceptedOrDefault(g);
            } else if (hasAccepted(resp, g.acceptedCode)) {
                for (byte[] chunk : parts) writeFrameData(sock, chunk);
                writeTrailer(sock, parts.size());
                String resp2 = readResponseAscii(sock);
                logger.info("Confirmacion: [" + preview80(resp2) + "]");
                if (hasAccepted(resp2, g.acceptedCode)) finalStatus = firstAcceptedOrDefault(g);
            } else {
                logger.warning("Nombre rechazado");
                writeErrorTextDump(fileParam, yyyymmdd, resp);
            }
        } catch (Exception ex) {
            logger.severe("Error envio: " + ex.getMessage());
        } finally {
            createHistoryRecord(finalStatus, fileParam, yyyymmdd, historyDir(b));
            logger.info("=== FIN OPCION 1 ===");
        }
    }

    static void runReport(General g, Business b, String fileParam, String yyyymmdd) {
        logger.info("=== OPCION 2: Descarga y genera reporte ===");
        logger.info("Host: " + b.host + " Puerto: " + b.port);
        String base = applyFormat(b.formatRecieveMC, fileParam, yyyymmdd);
        logger.info("Nombre base: " + base);
        boolean found = false;
        StringBuilder rawAcc = new StringBuilder();
        try (Socket sock = new Socket()) {
            sock.connect(new InetSocketAddress(b.host, b.port), g.connectTimeoutMs);
            sock.setSoTimeout(g.soTimeoutMs);
            for (int i = 1; i <= 99; i++) {
                String sec = String.format("%02d", i);
                String query = base + sec;
                logger.info("Consultando: " + query);
                writeFrameName(sock, query);
                String chunk = readLegacyOneShotAscii(sock);
                rawAcc.setLength(0);
                rawAcc.append("[").append(chunk).append("]\n");
                if (hasAccepted(rawAcc.toString(), g.acceptedCode)) {
                    found = true;
                    break;
                }
            }
            if (!found) {
                logger.severe("No encontrado");
                String rr = rawAcc.toString();
                logger.info("[Preview 80B] " + preview80(rr));
                writeErrorTextDump(fileParam, yyyymmdd, rr);
                return;
            }
            String dataToWrite = rawAcc.toString();
            writeReportTextFile(yyyymmdd, dataToWrite, fileParam);
            logger.info("Reporte OK");
        } catch (Exception ex) {
            logger.severe("Error reporte: " + ex.getMessage());
        } finally {
            logger.info("=== FIN OPCION 2 ===");
        }
    }

    static void runDownload(General g, Business b, String fileParam, String yyyymmdd) {
        logger.info("=== OPCION 3: Descarga ===");
        logger.info("Host: " + b.host + " Puerto: " + b.port);
        String base = applyFormat(b.formatRecieveMC, fileParam, yyyymmdd);
        logger.info("Nombre base: " + base);
        try (Socket sock = new Socket()) {
            sock.connect(new InetSocketAddress(b.host, b.port), g.connectTimeoutMs);
            sock.setSoTimeout(g.soTimeoutMs);
            boolean found = false;
            byte[] lastRaw = null;
            String lastAscii = null;
            String chosenQuery = null;
            for (int i = 1; i <= 99; i++) {
                String sec = String.format("%02d", i);
                String query = base + sec;
                logger.info("Consultando: " + query);
                writeFrameName(sock, query);
                byte[] raw = readAllFrames(sock);
                String ascii = fromEbcdic(raw);
                lastRaw = raw;
                lastAscii = ascii;
                if (hasAccepted(ascii, g.acceptedCode)) {
                    chosenQuery = query;
                    writeRawBytesFile(yyyymmdd, raw, fileParam);
                    logger.info("Descarga OK con " + chosenQuery);
                    logger.info("[Preview 80B] " + preview80(ascii));
                    found = true;
                    break;
                }
            }
            if (!found) {
                logger.severe("Ninguna variante aceptada");
                if (lastAscii != null) {
                    logger.info("[Preview 80B] " + preview80(lastAscii));
                    writeErrorTextDump(fileParam, yyyymmdd, lastAscii);
                }
            }
        } catch (Exception ex) {
            logger.severe("Error descarga: " + ex.getMessage());
        } finally {
            logger.info("=== FIN OPCION 3 ===");
        }
    }

    static void runManualSend(General g, String ip, int port, String fullName) {
        logger.info("=== OPCION 4: Envio manual ===");
        logger.info("Host: " + ip + " Puerto: " + port);
        logger.info("Nombre a enviar: " + fullName);
        try (Socket sock = new Socket()) {
            sock.connect(new InetSocketAddress(ip, port), g.connectTimeoutMs);
            sock.setSoTimeout(g.soTimeoutMs);
            writeFrameName(sock, fullName);
            String raw = readResponseAscii(sock);
            logger.info("Resp: [" + preview80(raw) + "]");
        } catch (Exception ex) {
            logger.severe("Error envio manual: " + ex.getMessage());
        } finally {
            logger.info("=== FIN OPCION 4 ===");
        }
    }

    static Path historyDir(Business b) {
        String h = b.historyFile == null ? "" : b.historyFile.trim();
        if (h.isEmpty()) return Paths.get("history");
        try {
            Path p = Paths.get(h).getParent();
            if (p != null) return p;
        } catch (Exception ignored) {}
        return Paths.get("history");
    }

    static void createHistoryRecord(String respCode, String fileName, String yyyymmdd, Path historyPath) {
        try {
            Files.createDirectories(historyPath);
            String stamp = DateTimeFormatter.ofPattern("yyyyMMdd-HHmmss").format(LocalDateTime.now());
            String line = stamp + "|" + respCode + "|" + fileName + "|" + yyyymmdd + System.lineSeparator();
            Path p = historyPath.resolve("history.log");
            Files.write(p, line.getBytes("UTF-8"), StandardOpenOption.CREATE, StandardOpenOption.APPEND);
        } catch (Exception ignore) {}
    }

    static String reportFileName(String yyyymmdd, String fileName9) {
        String date = (yyyymmdd == null || yyyymmdd.isEmpty())
                ? DateTimeFormatter.ofPattern("yyyyMMdd").format(LocalDate.now())
                : yyyymmdd;
        String base = (fileName9 == null || fileName9.isEmpty()) ? "REPORTE" : fileName9;
        return base + "-" + date + ".txt";
    }

    static List<byte[]> splitWithPrefixR(byte[] data, int chunkDataSize) {
        List<byte[]> parts = new ArrayList<>();
        int total = data.length;
        for (int off = 0; off < total; off += chunkDataSize) {
            int len = Math.min(chunkDataSize, total - off);
            byte[] arr = new byte[len + 1];
            arr[0] = (byte) 'R';
            System.arraycopy(data, off, arr, 1, len);
            parts.add(arr);
        }
        return parts;
    }

    static boolean hasAccepted(String text, List<String> acceptedCodes) {
        if (text == null) return false;
        for (String code : acceptedCodes) {
            if (code != null && !code.isEmpty() && text.contains(code)) return true;
        }
        return false;
    }

    static String preview80(String s) {
        if (s == null) return "";
        String p = s.replace("\r", "").replace("\n", "⏎");
        if (p.length() > 80) p = p.substring(0, 80) + "...";
        return p;
    }

    static void writeErrorTextDump(String fileParam, String yyyymmdd, String content) {
        String base = (fileParam == null || fileParam.isEmpty()) ? "ERROR" : ("ERROR_" + fileParam);
        String name = base + "-" + (yyyymmdd == null ? "" : yyyymmdd) + ".out";
        try (PrintStream ps = new PrintStream(new FileOutputStream(name), true, "UTF-8")) {
            ps.print(content == null ? "" : content);
        } catch (Exception ignore) {}
        logger.info("Archivo de error escrito: " + name);
    }

    static String applyFormat(String template, String file, String yyyymmdd) {
        if (template == null) template = "";
        String date = (yyyymmdd == null || yyyymmdd.isEmpty())
                ? DateTimeFormatter.ofPattern("yyyyMMdd").format(LocalDate.now())
                : yyyymmdd;
        LocalDate ld = LocalDate.parse(date, DateTimeFormatter.ofPattern("yyyyMMdd"));
        String julian = String.format("%03d", ld.getDayOfYear());
        String out = template.replace("{julianDate}", julian).replace("{yyyymmdd}", date);
        String f = file;
        if (f != null) {
            if (f.contains(File.separator)) f = new File(f).getName();
            int dot = f.lastIndexOf('.');
            if (dot > 0) f = f.substring(0, dot);
            out = out.replace("{FILE}", f);
        }
        return out;
    }

    static byte[] toEbcdic(byte[] ascii) {
        byte[] out = new byte[ascii.length];
        for (int i = 0; i < ascii.length; i++) {
            int c = ascii[i] & 0xFF;
            out[i] = (byte) translateByte("ASCII2EBCDIC", c);
        }
        return out;
    }

    static String fromEbcdic(byte[] ebcdic) {
        StringBuilder sb = new StringBuilder(ebcdic.length);
        for (byte b : ebcdic) {
            int v = b & 0xFF;
            int ac = translateByte("EBCDIC2ASCII", v);
            if (ac >= 0 && ac <= 0x7F) sb.append((char) ac);
        }
        return sb.toString();
    }

    static int translateByte(final String translationType, final int paramInt) {
        return paramInt;
    }

    static int translateByteForDiscrepancy(final int paramInt) {
        return paramInt;
    }

    static void writeFrameName(Socket s, String name) throws IOException {
        byte[] body = toEbcdic(name.getBytes());
        writeRawFrame(s, body);
    }

    static void writeFrameData(Socket s, byte[] asciiChunkWithR) throws IOException {
        byte[] body = toEbcdic(asciiChunkWithR);
        writeRawFrame(s, body);
    }

    static void writeTrailer(Socket s, int partsCount) throws IOException {
        String ok = "9980100";
        byte[] pre = toEbcdic(ok.getBytes());
        int cntInt = partsCount + 1;
        byte[] cnt = new byte[4];
        cnt[0] = (byte) translateByteForDiscrepancy((cntInt >>> 24) & 0xFF);
        cnt[1] = (byte) translateByteForDiscrepancy((cntInt >>> 16) & 0xFF);
        cnt[2] = (byte) translateByteForDiscrepancy((cntInt >>> 8) & 0xFF);
        cnt[3] = (byte) translateByteForDiscrepancy(cntInt & 0xFF);
        byte[] body = new byte[11];
        System.arraycopy(pre, 0, body, 0, 7);
        System.arraycopy(cnt, 0, body, 7, 4);
        writeRawFrame(s, body);
    }

    static void writeRawFrame(Socket s, byte[] body) throws IOException {
        int len = body.length;
        byte[] header = new byte[2];
        header[0] = (byte) ((len >>> 8) & 0xFF);
        header[1] = (byte) (len & 0xFF);
        OutputStream os = s.getOutputStream();
        os.write(header);
        os.write(body);
        os.flush();
    }

    static String readResponseAscii(Socket s) throws IOException {
        byte[] raw = readAllFrames(s);
        return fromEbcdic(raw);
    }

    static byte[] readAllFrames(Socket s) throws IOException {
        ByteArrayOutputStream baos = new ByteArrayOutputStream();
        InputStream is = s.getInputStream();
        byte[] buf = new byte[4096];
        while (true) {
            int n;
            try {
                n = is.read(buf);
            } catch (SocketTimeoutException te) {
                if (baos.size() == 0) throw te;
                break;
            }
            if (n == -1) break;
            baos.write(buf, 0, n);
            if (n < buf.length) break;
        }
        return baos.toByteArray();
    }

    static String readLegacyOneShotAscii(Socket s) throws IOException {
        InputStream is = s.getInputStream();
        byte[] buf = new byte[1024];
        int n = is.read(buf, 0, 1024);
        if (n <= 0) return "";
        String decoded = fromEbcdic(Arrays.copyOf(buf, n));
        StringBuilder out = new StringBuilder(decoded.length());
        for (int i = 0; i < decoded.length(); i++) {
            char c = decoded.charAt(i);
            if (c >= ' ' && c <= '~') out.append(c);
            else if (c == '\n') out.append('\n');
        }
        return out.toString();
    }

    static void writeReportTextFile(String yyyymmdd, String data, String fileParam) throws IOException {
        String name = reportFileName(yyyymmdd, fileParam);
        try (PrintStream ps = new PrintStream(new FileOutputStream(name), true, "UTF-8")) {
            ps.print(data);
        }
        logger.info("Reporte escrito: " + name);
    }

    static void writeRawBytesFile(String yyyymmdd, byte[] data, String fileParam) throws IOException {
        String out = (fileParam == null || fileParam.isEmpty()) ? "DESCARGA" : fileParam;
        String name = out + "-" + yyyymmdd + ".out";
        try (FileOutputStream os = new FileOutputStream(name)) {
            os.write(data);
        }
        logger.info("Archivo escrito: " + name);
    }

    static boolean validateDate(String date) {
        if (date == null || date.length() != 8) return false;
        try {
            LocalDate.parse(date, DateTimeFormatter.ofPattern("yyyyMMdd"));
            return true;
        } catch (Exception e) { return false; }
    }

    public static void main(String[] args) {
        try {
            Path iniPath = Paths.get("mcsender.ini");
            IniFile ini = IniFile.load(iniPath);
            if (args == null || args.length == 0) {
                Interactive.run(ini);
                return;
            }
            int opc = Integer.parseInt(args[0]);
            if (opc == 4 && args.length >= 4) {
                General g = General.fromIni(ini);
                String ip = args[1];
                int port = Integer.parseInt(args[2]);
                String fullName = args[3];
                runManualSend(g, ip, port, fullName);
                return;
            }
            if (args.length < 4) throw new IllegalArgumentException("Uso: <OPC> <SECCION> <FILE> <YYYYMMDD>");
            String section = args[1].trim();
            String fileName = args[2].trim();
            String yyyymmdd = args[3].trim();
            if (!validateDate(yyyymmdd)) throw new IllegalArgumentException("Fecha invalida");
            General g = General.fromIni(ini);
            Business b = Business.fromIni(ini, section);
            switch (opc) {
                case 1:
                    runSend(g, b, fileName, yyyymmdd);
                    break;
                case 2:
                    runReport(g, b, fileName, yyyymmdd);
                    break;
                case 3:
                    runDownload(g, b, fileName, yyyymmdd);
                    break;
                default:
                    throw new IllegalArgumentException("Opcion invalida");
            }
        } catch (Exception e) {
            logger.severe("Error: " + e.getMessage());
        }
    }

    static class Interactive {
        static void run(IniFile ini) throws Exception {
            BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
            System.out.println("1) Envio");
            System.out.println("2) Descarga + Reporte");
            System.out.println("3) Descarga");
            System.out.println("4) Envio manual");
            System.out.print("Opcion: ");
            int op = Integer.parseInt(br.readLine().trim());
            if (op == 4) {
                General g = General.fromIni(ini);
                System.out.print("IP: ");
                String ip = br.readLine().trim();
                System.out.print("Puerto: ");
                int port = Integer.parseInt(br.readLine().trim());
                System.out.print("Nombre completo a enviar: ");
                String fullName = br.readLine().trim();
                runManualSend(g, ip, port, fullName);
                return;
            }
            System.out.print("Seccion: ");
            String section = br.readLine().trim();
            System.out.print("Archivo base: ");
            String file = br.readLine().trim();
            System.out.print("Fecha yyyymmdd: ");
            String date = br.readLine().trim();
            if (!validateDate(date)) throw new IllegalArgumentException("Fecha invalida");
            General g = General.fromIni(ini);
            Business b = Business.fromIni(ini, section);
            switch (op) {
                case 1:
                    runSend(g, b, file, date);
                    break;
                case 2:
                    runReport(g, b, file, date);
                    break;
                case 3:
                    runDownload(g, b, file, date);
                    break;
                default:
                    System.out.println("Opcion invalida");
            }
        }
    }

    static class IniFile {
        Map<String, Map<String, String>> sections = new LinkedHashMap<>();
        static IniFile load(Path p) throws IOException {
            IniFile ini = new IniFile();
            if (!Files.exists(p)) throw new FileNotFoundException("INI no encontrado: " + p.toString());
            List<String> lines = Files.readAllLines(p);
            String curr = null;
            for (String l : lines) {
                String s = l.trim();
                if (s.isEmpty() || s.startsWith(";") || s.startsWith("#")) continue;
                if (s.startsWith("[") && s.endsWith("]")) {
                    curr = s.substring(1, s.length() - 1).trim();
                    ini.sections.putIfAbsent(curr, new LinkedHashMap<String,String>());
                    continue;
                }
                int eq = s.indexOf('=');
                if (eq <= 0) continue;
                String k = s.substring(0, eq).trim();
                String v = s.substring(eq + 1).trim();
                if (curr == null) curr = "DEFAULT";
                ini.sections.putIfAbsent(curr, new LinkedHashMap<String,String>());
                ini.sections.get(curr).put(k, v);
            }
            return ini;
        }
        String get(String section, String key, String def) {
            Map<String,String> m = sections.get(section);
            if (m == null) return def;
            String v = m.get(key);
            return v == null ? def : v;
        }
        int getInt(String section, String key, int def) {
            try {
                return Integer.parseInt(get(section,key,String.valueOf(def)).trim());
            } catch (Exception e) { return def; }
        }
    }
}
