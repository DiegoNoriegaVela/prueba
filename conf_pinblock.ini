import java.io.*;
import java.net.*;
import java.nio.charset.Charset;
import java.util.Calendar;

public final class MipFileSender {

    // Charset EBCDIC CP500 (IBM500)
    private static final Charset EBCDIC = Charset.forName("Cp500");

    // Tamaño máximo de payload de datos por record (bulk) según MIP: 1014
    private static final int DATA_CHUNK = 1014;

    public static void main(String[] args) {
        try {
            Params p = Params.parse(args);
            if (p == null) {
                usage();
                System.exit(2);
            }
            sendToMip(p);
        } catch (Exception e) {
            e.printStackTrace();
            System.exit(1);
        }
    }

    private static void usage() {
        System.out.println(
            "Uso:\n" +
            "  java MipFileSender --ip <host> --port <puerto> --file <path_ipm> --ipmname <R119xxxxx[dddss]>\n" +
            "Notas:\n" +
            "  --ipmname: 9 chars (R+tipo3+endpoint5) o 14 chars completos (RtttEEEEEJJJSS).");
    }

    // ------------------------------------------------------------

    private static void sendToMip(Params p) throws Exception {
        // Normalizar Transmission ID (14 A/N en EBCDIC)
        String txId = normalizeTransmissionId(p.ipmName);

        // Abrir socket
        Socket sock = new Socket();
        sock.connect(new InetSocketAddress(p.ip, p.port), 15000);
        sock.setSoTimeout(20000);

        InputStream in = sock.getInputStream();
        OutputStream out = sock.getOutputStream();

        try {
            // 1) 004 "To Mastercard" header
            byte[] hdr004 = buildHeader004(txId);
            writeFramed(out, hdr004);

            // Leer ACK del header (998 ... Return Code 00 = OK / 01 = Refusal)
            Frame r = readFramed(in);
            check998("Header", r);

            // 2) Data records (3): 'R' + payload(<=1014)
            int blocks = 0;
            File f = new File(p.filePath);
            FileInputStream fis = new FileInputStream(f);
            try {
                byte[] buf = new byte[DATA_CHUNK];
                int n;
                while ((n = fis.read(buf)) >= 0) {
                    if (n == 0) {
                        // EOF limpio
                        break;
                    }
                    ByteArrayOutputStream rec = new ByteArrayOutputStream(1 + n);
                    rec.write(ebcdicByte('R'));        // Direction Indicator 'R' (Host->MIP)
                    rec.write(buf, 0, n);              // Bulk data
                    writeFramed(out, rec.toByteArray());
                    blocks++;

                    // El line driver suele hacer un pequeño ACK; si llega 0-len se ignora.
                    // No es obligatorio procesarlo aquí; el ack formal es el 998 trailer ack.
                }
            } finally {
                fis.close();
            }

            // 3) 998 trailer: incluye número de bloques (data) + 1 (el propio trailer)
            byte[] tr998 = buildTrailer998(blocks);
            writeFramed(out, tr998);

            // Leer ACK del trailer (998 ... Return Code 00 = OK)
            r = readFramed(in);
            check998("Trailer", r);

            // 4) 999 purge: aconsejado tras trailer OK
            byte[] p999 = buildPurge999(txId);
            writeFramed(out, p999);

            // 6A: Purge Acknowledgement
            r = readFramed(in);
            check998("Purge", r); // Return Code 00 esperado

            System.out.println("ENVÍO COMPLETADO. Bloques de datos: " + blocks + "  (más trailer).");
        } finally {
            try { sock.close(); } catch (Exception ignore) {}
        }
    }

    // --- Builders de records --------------------------------------------------

    // 004 header (AN/A en CP500, reservados binarios a cero)
    private static byte[] buildHeader004(String txId14) throws IOException {
        ByteArrayOutputStream b = new ByteArrayOutputStream(36);
        b.write(ebcdic("004"));        // Request Code (1-3)
        b.write(ebcdic("01"));         // Record Type (4-5)
        b.write(ebcdic(txId14));       // Transmission ID (6-19) => R ttt EEEEE JJJ SS
        // Reservados binarios (20-36): 17 bytes a 0x00
        for (int i = 0; i < 17; i++) b.write(0x00);
        return b.toByteArray();
    }

    // Data record (3) se construye on-the-fly: 'R' + payload<=1014

    // 998 trailer (Return Code 00 + 4 bytes binarios con número de bloques = data_blocks + 1)
    private static byte[] buildTrailer998(int dataBlocks) throws IOException {
        int count = dataBlocks + 1; // incluye el propio trailer, según especificación
        ByteArrayOutputStream b = new ByteArrayOutputStream(11);
        b.write(ebcdic("998"));     // Request Code (1-3)
        b.write(ebcdic("01"));      // Request Type (4-5)
        b.write(ebcdic("00"));      // Return Code (6-7) -> 00
        // Number of Blocks (8-11) 4 bytes binario big-endian
        b.write(intTo4BE(count), 0, 4);
        return b.toByteArray();
    }

    // 999 purge (Return Code 00 + Transmission ID 14)
    private static byte[] buildPurge999(String txId14) throws IOException {
        ByteArrayOutputStream b = new ByteArrayOutputStream(21);
        b.write(ebcdic("999"));   // Request Code
        b.write(ebcdic("01"));    // Request Type
        b.write(ebcdic("00"));    // Return Code
        b.write(ebcdic(txId14));  // Transmission ID (14)
        return b.toByteArray();
    }

    // --- Framing (longitud de 2 bytes big-endian + payload) -------------------

    private static void writeFramed(OutputStream out, byte[] payload) throws IOException {
        int len = payload.length;
        // prefijo de longitud de 2 bytes (MSB..LSB)
        out.write((len >>> 8) & 0xFF);
        out.write(len & 0xFF);
        out.write(payload);
        out.flush();
    }

    private static Frame readFramed(InputStream in) throws IOException {
        int hi = in.read();
        int lo = in.read();
        if (hi < 0 || lo < 0) throw new EOFException("Conexión cerrada esperando longitud");
        int len = ((hi & 0xFF) << 8) | (lo & 0xFF);
        byte[] buf = new byte[len];
        int off = 0;
        while (off < len) {
            int n = in.read(buf, off, len - off);
            if (n < 0) throw new EOFException("Conexión cerrada leyendo frame");
            off += n;
        }
        return new Frame(buf);
    }

    private static void check998(String stage, Frame f) {
        String code = f.asAscii(0, 3);     // "998"
        if (!"998".equals(code)) {
            System.out.println(stage + " resp: no es 998, raw=" + f.hex());
            return; // algunos line-acks pueden colarse; no abortamos
        }
        String type = f.asAscii(3, 2);     // "01"
        String rc   = f.asAscii(5, 2);     // "00" OK / "01" Error
        if (!"00".equals(rc)) {
            System.err.println(stage + " ERROR 998/" + type + " rc=" + rc + " msg=" + f.safeAscii(7));
            throw new RuntimeException(stage + " rechazado por MIP (rc=" + rc + ")");
        } else {
            System.out.println(stage + " OK 998/" + type);
        }
    }

    // --- Utilidades -----------------------------------------------------------

    private static byte[] ebcdic(String s) {
        return s.getBytes(EBCDIC);
    }

    private static byte ebcdicByte(char c) {
        return ("" + c).getBytes(EBCDIC)[0];
    }

    private static byte[] intTo4BE(int v) {
        return new byte[] {
            (byte)((v >>> 24) & 0xFF),
            (byte)((v >>> 16) & 0xFF),
            (byte)((v >>> 8)  & 0xFF),
            (byte)(v & 0xFF)
        };
    }

    private static String normalizeTransmissionId(String raw) {
        if (raw == null) throw new IllegalArgumentException("--ipmname requerido");
        String s = raw.trim();
        if (s.length() == 14) return s;
        if (s.length() != 9)
            throw new IllegalArgumentException("--ipmname debe ser de 9 o 14 chars. Ej: R11902840");

        // s = R + ttt + EEEEE   -> completar JJJ (juliano) + SS (secuencia)
        Calendar cal = Calendar.getInstance();
        int dayOfYear = cal.get(Calendar.DAY_OF_YEAR); // 1..366
        String jjj = String.format("%03d", dayOfYear);
        String ss  = "01";
        return s + jjj + ss;
    }

    // ---- Modelos simples para parsing de respuestas --------------------------

    private static final class Frame {
        final byte[] data;
        Frame(byte[] d) { this.data = d; }

        String asAscii(int start, int len) {
            if (start + len > data.length) return "";
            try {
                return new String(data, start, len, "US-ASCII");
            } catch (UnsupportedEncodingException e) {
                return new String(data, start, len);
            }
        }

        String safeAscii(int start) {
            int len = data.length - start;
            if (len <= 0) return "";
            try {
                return new String(data, start, len, "US-ASCII").replaceAll("[^\\p{Print}]", ".");
            } catch (UnsupportedEncodingException e) {
                return new String(data, start, len).replaceAll("[^\\p{Print}]", ".");
            }
        }

        String hex() {
            StringBuilder sb = new StringBuilder();
            for (byte b : data) {
                sb.append(String.format("%02X", b));
            }
            return sb.toString();
        }
    }

    private static final class Params {
        String ip;
        int port;
        String filePath;
        String ipmName;

        static Params parse(String[] a) {
            Params p = new Params();
            for (int i = 0; i < a.length; i++) {
                String s = a[i];
                if (s.startsWith("--ip=")) p.ip = s.substring(5);
                else if (s.equals("--ip") && i + 1 < a.length) p.ip = a[++i];
                else if (s.startsWith("--port=")) p.port = Integer.parseInt(s.substring(7));
                else if (s.equals("--port") && i + 1 < a.length) p.port = Integer.parseInt(a[++i]);
                else if (s.startsWith("--file=")) p.filePath = s.substring(7);
                else if (s.equals("--file") && i + 1 < a.length) p.filePath = a[++i];
                else if (s.startsWith("--ipmname=")) p.ipmName = s.substring(10);
                else if (s.equals("--ipmname") && i + 1 < a.length) p.ipmName = a[++i];
            }
            if (p.ip == null || p.port == 0 || p.filePath == null || p.ipmName == null) return null;
            return p;
        }
    }
}