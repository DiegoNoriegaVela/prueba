import java.io.*;
import java.net.*;
import java.nio.charset.Charset;
import java.util.Calendar;

public final class MipFileSender {

    private static final Charset EBCDIC = Charset.forName("Cp500"); // IBM500 en algunos JDK
    private static final int DATA_CHUNK = 1014;

    public static void main(String[] args) {
        try {
            Params p = Params.parse(args);
            if (p == null) { usage(); System.exit(2); }
            sendToMip(p);
        } catch (Exception e) {
            e.printStackTrace();
            System.exit(1);
        }
    }

    private static void usage() {
        System.out.println(
            "Uso:\n" +
            "  java MipFileSender --ip <host> --port <puerto> --file <path_ipm> --ipmname <R119xxxxx[dddss]>\n" +
            "Notas:\n" +
            "  --ipmname: 9 chars (R+tipo3+endpoint5) o 14 chars completos (RtttEEEEEJJJSS).");
    }

    private static void sendToMip(Params p) throws Exception {
        File f = new File(p.filePath);
        if (!f.exists() || !f.isFile()) {
            throw new FileNotFoundException("No existe el archivo: " + f.getAbsolutePath());
        }
        String txId = normalizeTransmissionId(p.ipmName);
        System.out.println("INICIA PROCESO");
        System.out.println("Archivo IPM: " + f.getAbsolutePath());
        System.out.println("Transmission ID (004/999): " + txId);

        Socket sock = new Socket();
        sock.connect(new InetSocketAddress(p.ip, p.port), 15000);
        sock.setSoTimeout(20000);

        InputStream in = sock.getInputStream();
        OutputStream out = sock.getOutputStream();

        try {
            // 1) 004 “To Mastercard”
            byte[] hdr004 = buildHeader004(txId);
            writeFramed(out, hdr004);

            Frame r = readFramed(in);
            checkAck("Header", r);

            // 2) Data blocks (3): 'R' + payload<=1014
            int blocks = 0;
            FileInputStream fis = new FileInputStream(f);
            try {
                byte[] buf = new byte[DATA_CHUNK];
                int n;
                while ((n = fis.read(buf)) >= 0) {
                    if (n == 0) break;
                    ByteArrayOutputStream rec = new ByteArrayOutputStream(1 + n);
                    rec.write(ebcdicByte('R'));       // Direction Indicator
                    rec.write(buf, 0, n);             // Bulk data
                    writeFramed(out, rec.toByteArray());
                    blocks++;
                }
            } finally { try { fis.close(); } catch (Exception ignore) {} }

            // 3) 998 trailer (count = data blocks + 1)
            byte[] tr998 = buildTrailer998(blocks);
            writeFramed(out, tr998);

            r = readFramed(in);
            checkAck("Trailer", r);

            // 4) 999 purge
            byte[] p999 = buildPurge999(txId);
            writeFramed(out, p999);

            r = readFramed(in);
            checkAck("Purge", r);

            System.out.println("ENVÍO COMPLETADO. Bloques de datos: " + blocks + " (más trailer).");
            System.out.println("PROCESO FINALIZADO");
        } finally {
            try { sock.close(); } catch (Exception ignore) {}
        }
    }

    /* ------------ Builders 004/998/999 ------------ */

    private static byte[] buildHeader004(String txId14) throws IOException {
        ByteArrayOutputStream b = new ByteArrayOutputStream(36);
        b.write(ebcdic("004"));
        b.write(ebcdic("01"));
        b.write(ebcdic(txId14)); // 14 chars
        for (int i = 0; i < 17; i++) b.write(0x00); // reservados binarios
        return b.toByteArray();
    }

    private static byte[] buildTrailer998(int dataBlocks) throws IOException {
        int count = dataBlocks + 1; // incluye el trailer
        ByteArrayOutputStream b = new ByteArrayOutputStream(11);
        b.write(ebcdic("998"));
        b.write(ebcdic("01"));
        b.write(ebcdic("00"));        // Return Code OK
        b.write(intTo4BE(count), 0, 4);
        return b.toByteArray();
    }

    private static byte[] buildPurge999(String txId14) throws IOException {
        ByteArrayOutputStream b = new ByteArrayOutputStream(21);
        b.write(ebcdic("999"));
        b.write(ebcdic("01"));
        b.write(ebcdic("00"));
        b.write(ebcdic(txId14));
        return b.toByteArray();
    }

    /* ------------ Framing: 2 bytes len (BE) + payload ------------ */

    private static void writeFramed(OutputStream out, byte[] payload) throws IOException {
        int len = payload.length;
        out.write((len >>> 8) & 0xFF);
        out.write(len & 0xFF);
        out.write(payload);
        out.flush();
    }

    private static Frame readFramed(InputStream in) throws IOException {
        int hi = in.read();
        int lo = in.read();
        if (hi < 0 || lo < 0) throw new EOFException("Conexión cerrada esperando longitud");
        int len = ((hi & 0xFF) << 8) | (lo & 0xFF);
        byte[] buf = new byte[len];
        int off = 0;
        while (off < len) {
            int n = in.read(buf, off, len - off);
            if (n < 0) throw new EOFException("Conexión cerrada leyendo frame");
            off += n;
        }
        return new Frame(buf);
    }

    /* ------------ Validación de ACK (EBCDIC) ------------ */

    private static void checkAck(String stage, Frame f) {
        String code = f.asEbcdic(0, 3); // "998"
        if (!"998".equals(code)) {
            System.out.println(stage + " resp: no es 998, raw=" + f.hex());
            return; // algunos nodos envían acks intermedios; no abortamos
        }
        String type = f.asEbcdic(3, 2); // "01", "6A", etc.
        String rc   = f.asEbcdic(5, 2); // "00" OK, otros = error
        if (!"00".equals(rc)) {
            System.err.println(stage + " ERROR -> 998/" + type + " rc=" + rc + " raw=" + f.hex());
            throw new RuntimeException(stage + " rechazado por MIP (rc=" + rc + ")");
        } else {
            System.out.println(stage + " OK -> 998/" + type + " rc=00");
        }
    }

    /* ------------ Utilidades ------------ */

    private static byte[] ebcdic(String s) { return s.getBytes(EBCDIC); }
    private static byte ebcdicByte(char c) { return ("" + c).getBytes(EBCDIC)[0]; }

    private static byte[] intTo4BE(int v) {
        return new byte[] {
            (byte)((v >>> 24) & 0xFF),
            (byte)((v >>> 16) & 0xFF),
            (byte)((v >>> 8)  & 0xFF),
            (byte)(v & 0xFF)
        };
    }

    private static String normalizeTransmissionId(String raw) {
        if (raw == null) throw new IllegalArgumentException("--ipmname requerido");
        String s = raw.trim();
        if (s.length() == 14) return s;
        if (s.length() != 9)
            throw new IllegalArgumentException("--ipmname debe tener 9 o 14 chars. Ej: R11902840");

        Calendar cal = Calendar.getInstance();
        int dayOfYear = cal.get(Calendar.DAY_OF_YEAR);
        String jjj = String.format("%03d", dayOfYear);
        String ss  = "01";
        return s + jjj + ss;
    }

    private static final class Frame {
        final byte[] data;
        Frame(byte[] d) { this.data = d; }

        String asEbcdic(int start, int len) {
            if (start + len > data.length) return "";
            try { return new String(data, start, len, EBCDIC); }
            catch (Exception e) { return ""; }
        }

        String hex() {
            StringBuilder sb = new StringBuilder();
            for (byte b : data) sb.append(String.format("%02X", b));
            return sb.toString();
        }
    }

    private static final class Params {
        String ip; int port; String filePath; String ipmName;
        static Params parse(String[] a) {
            Params p = new Params();
            for (int i = 0; i < a.length; i++) {
                String s = a[i];
                if (s.startsWith("--ip=")) p.ip = s.substring(5);
                else if (s.equals("--ip") && i + 1 < a.length) p.ip = a[++i];
                else if (s.startsWith("--port=")) p.port = Integer.parseInt(s.substring(7));
                else if (s.equals("--port") && i + 1 < a.length) p.port = Integer.parseInt(a[++i]);
                else if (s.startsWith("--file=")) p.filePath = s.substring(7);
                else if (s.equals("--file") && i + 1 < a.length) p.filePath = a[++i];
                else if (s.startsWith("--ipmname=")) p.ipmName = s.substring(10);
                else if (s.equals("--ipmname") && i + 1 < a.length) p.ipmName = a[++i];
            }
            if (p.ip == null || p.port == 0 || p.filePath == null || p.ipmName == null) return null;
            return p;
        }
    }
}