import java.io.*;
import java.nio.charset.Charset;
import java.util.ArrayList;
import java.util.List;

public class Rdw1014Tool {

    // Layout 1014
    private static final int BLOCK_SIZE = 1014;
    private static final int DATA_PER_BLOCK = 1012;
    private static final byte PAD_40 = 0x40;

    public static void main(String[] args) {
        if (args.length == 0 || "help".equalsIgnoreCase(args[0])) {
            printHelp();
            return;
        }
        String cmd = args[0].toLowerCase();
        if (!"decode".equals(cmd)) {
            System.err.println("Comando no soportado: " + cmd);
            printHelp();
            System.exit(2);
        }

        String inputPath = null;
        String outDir = "out";

        // Flags mínimas: --input y --output
        int i = 1;
        while (i < args.length) {
            String a = args[i];
            if ("--input".equals(a) && i + 1 < args.length) {
                inputPath = args[++i];
            } else if ("--output".equals(a) && i + 1 < args.length) {
                outDir = args[++i];
            } else {
                System.err.println("Flag desconocida o valor faltante: " + a);
                printHelp();
                System.exit(2);
            }
            i++;
        }
        if (inputPath == null) {
            System.err.println("Falta --input <ruta>");
            printHelp();
            System.exit(2);
        }

        try {
            // Salida
            File out = new File(outDir);
            if (!out.exists()) out.mkdirs();

            // Lee archivo
            byte[] raw = readAllBytes(new File(inputPath));
            System.out.println("Archivo: " + inputPath + " (" + raw.length + " bytes)");

            // 1) Detección automática de 1014-blocking
            boolean isBlocked = decideBlockedImproved(raw);
            System.out.println("1014-blocked (auto): " + isBlocked);
            byte[] vbs = isBlocked ? remove1014Blocking(raw) : raw;

            // 2) RDW fijo en IPM (4 bytes, BE) -> decodifica en registros
            List<byte[]> records = parseVbsRdwIpm(vbs);

            // 3) Output: bin + vistas de texto (EBCDIC Cp500 y ASCII legible)
            Charset cs = pickCp500();
            File report = new File(out, "report.txt");
            BufferedWriter w = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(report), "UTF-8"));
            try {
                w.write("Archivo: " + inputPath + "\n");
                w.write("Tamaño original: " + raw.length + " bytes\n");
                w.write("1014-blocked (auto): " + isBlocked + "\n");
                w.write("Variante RDW: IPM (4 bytes)\n");
                w.write("Registros: " + records.size() + "\n");
                w.write("Encoding texto (preview): " + cs.displayName() + "\n");
                w.write("------------------------------------------------------------\n");

                int idx = 1;
                for (int k = 0; k < records.size(); k++) {
                    byte[] rec = records.get(k);

                    // BIN
                    File fbin = new File(out, String.format("record_%04d.bin", idx));
                    writeAllBytes(fbin, rec);

                    // Texto EBCDIC->Unicode (Cp500)
                    String ebcdicText = new String(rec, cs);
                    BufferedWriter we = new BufferedWriter(new OutputStreamWriter(
                            new FileOutputStream(new File(out, String.format("record_%04d.ebcdic.txt", idx))), "UTF-8"));
                    try { we.write(ebcdicText); } finally { try { we.close(); } catch (Exception ex) {} }

                    // Versión ASCII imprimible
                    String asciiText = toAsciiPrintable(ebcdicText);
                    BufferedWriter wa = new BufferedWriter(new OutputStreamWriter(
                            new FileOutputStream(new File(out, String.format("record_%04d.ascii.txt", idx))), "US-ASCII"));
                    try { wa.write(asciiText); } finally { try { wa.close(); } catch (Exception ex) {} }

                    // Preview al reporte
                    String preview = previewText(ebcdicText, 64);
                    w.write(String.format("#%04d  len=%d  -> %s\n", idx, rec.length, preview));
                    idx++;
                }
            } finally {
                try { w.close(); } catch (Exception ex) {}
            }

            System.out.println("OK. Registros y vistas en: " + out.getAbsolutePath());

        } catch (Exception e) {
            System.err.println("Fallo: " + e.getMessage());
            e.printStackTrace();
            System.exit(1);
        }
    }

    private static void printHelp() {
        System.out.println(
          "Uso:\n" +
          "  java Rdw1014Tool decode --input <archivo.ipm> --output <carpeta_salida>\n" +
          "\n" +
          "Detalles:\n" +
          "  * RDW: IPM fijo (4 bytes BE = longitud del payload, EOF=00000000)\n" +
          "  * 1014-blocking: detección automática y remoción si aplica\n" +
          "  * Encoding fijo para vistas de texto: EBCDIC Cp500\n"
        );
    }

    /* ================== IO ================== */
    private static byte[] readAllBytes(File f) throws IOException {
        ByteArrayOutputStream bout = new ByteArrayOutputStream((int)Math.min(f.length(), 64*1024));
        byte[] buf = new byte[8192];
        InputStream in = new FileInputStream(f);
        try {
            int n;
            while ((n = in.read(buf)) >= 0) {
                if (n > 0) bout.write(buf, 0, n);
            }
        } finally { try { in.close(); } catch (Exception ex) {} }
        return bout.toByteArray();
    }
    private static void writeAllBytes(File f, byte[] data) throws IOException {
        OutputStream out = new FileOutputStream(f);
        try { out.write(data); } finally { try { out.close(); } catch (Exception ex) {} }
    }

    /* ================== 1014: auto-detección y unblocking ================== */
    private static boolean decideBlockedImproved(byte[] raw) {
        if (raw.length % BLOCK_SIZE != 0) return false;
        int blocks = raw.length / BLOCK_SIZE;
        if (blocks <= 0) return false;

        // Regla: si hay >1 bloque, pedimos ≥60% terminando en 0x40,0x40
        int hits = 0;
        for (int b = 0; b < blocks; b++) {
            int end = (b + 1) * BLOCK_SIZE;
            if (raw[end - 2] == PAD_40 && raw[end - 1] == PAD_40) hits++;
        }
        if (blocks > 1) return (hits * 100 / blocks) >= 60;

        // 1 solo bloque: o termina en 0x40,0x40, o tras el RDW=00000000 hay ≥80% de 0x40
        if (hits == 1) return true;
        int eof = findRdwEof(raw);
        if (eof >= 0) {
            int padCount = 0, rem = raw.length - eof;
            for (int p = eof; p < raw.length; p++) if (raw[p] == PAD_40) padCount++;
            return rem > 0 && (padCount * 100 / rem) >= 80;
        }
        return false;
    }

    private static int findRdwEof(byte[] a) {
        for (int i = 0; i + 3 < a.length; i++) {
            if (a[i]==0 && a[i+1]==0 && a[i+2]==0 && a[i+3]==0) return i+4; // pos después del EOF
        }
        return -1;
    }

    private static byte[] remove1014Blocking(byte[] raw) throws IOException {
        ByteArrayOutputStream out = new ByteArrayOutputStream(raw.length);
        int pos = 0;
        while (pos < raw.length) {
            int remaining = raw.length - pos;
            if (remaining >= BLOCK_SIZE) {
                out.write(raw, pos, DATA_PER_BLOCK); // 1012 datos
                pos += BLOCK_SIZE;                    // +2 de padding
            } else {
                int take = remaining < DATA_PER_BLOCK ? remaining : DATA_PER_BLOCK;
                if (take > 0) out.write(raw, pos, take);
                pos += remaining;
            }
        }
        return out.toByteArray();
    }

    /* ================== RDW IPM ================== */
    private static List<byte[]> parseVbsRdwIpm(byte[] vbs) throws IOException {
        List<byte[]> records = new ArrayList<byte[]>();
        int pos = 0;
        while (pos + 4 <= vbs.length) {
            int len = ((vbs[pos] & 0xFF) << 24) | ((vbs[pos + 1] & 0xFF) << 16)
                    | ((vbs[pos + 2] & 0xFF) << 8) | (vbs[pos + 3] & 0xFF);
            pos += 4;
            if (len == 0) break; // EOF
            if (len < 0 || pos + len > vbs.length) {
                throw new IOException("RDW(IPM) inválido en pos " + (pos - 4) + " len=" + len);
            }
            byte[] rec = new byte[len];
            System.arraycopy(vbs, pos, rec, 0, len);
            pos += len;
            records.add(rec);
        }
        return records;
    }

    /* ================== Texto ================== */
    private static Charset pickCp500() {
        try { return Charset.forName("Cp500"); }
        catch (Exception e) {
            try { return Charset.forName("IBM500"); } // alias en algunos JDK IBM i
            catch (Exception ex) { return Charset.forName("Cp500"); }
        }
    }

    private static String toAsciiPrintable(String s) {
        if (s == null) return "";
        StringBuffer sb = new StringBuffer(s.length());
        for (int i = 0; i < s.length(); i++) {
            char c = s.charAt(i);
            if ((c >= 32 && c <= 126) || c == '\r' || c == '\n' || c == '\t') sb.append(c);
            else sb.append('.');
        }
        return sb.toString();
    }

    private static String previewText(String s, int maxChars) {
        if (s == null) return "";
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < s.length() && sb.length() < maxChars; i++) {
            char c = s.charAt(i);
            if (c < 32 && c != '\r' && c != '\n' && c != '\t') sb.append('·');
            else sb.append(c);
        }
        if (s.length() > maxChars) sb.append('…');
        return sb.toString();
    }
}